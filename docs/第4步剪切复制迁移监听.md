结论先给：**“剪切=路径变化”。**

- **只换父目录、不改文件名** → 直接**迁移缓存**（alias 不变，不再调用 AI）。
- **同时改了文件名** → 当作**新短名**，按“词表 → 学习词典 → 规则 →（可选）AI”**重新决策一次**，并把结果写回**路径缓存**与**学习词典**。
- **剪切整个文件夹** → 对该文件夹及**所有子项**做**批量迁移**（前缀替换），避免整棵树全部重算。
- **剪切到工作区外** → 从路径缓存里**删除**那条记录；学习词典不动（下次同名仍能命中）。
- **从外部剪切进来** → 视为新节点，优先靠**学习词典**和**规则**，通常**不必再走 AI**。

下面给你一套“可直接复制”的实现（包含 VS Code 事件接入 + 缓存迁移 API），保证**移动/重命名/整目录剪切**都稳。

---

# 一、在扩展里监听“重命名/移动”事件（VS Code 自带）

> **优先**使用 `workspace.onDidRenameFiles`（用户在 VS Code 内部“移动/重命名”都会触发）。
> 对于 **外部**拖拽/移动，VS Code 通常发“删除+创建”，我们用 `FileSystemWatcher` 做兜底。

```ts
// src/features/explorer-alias/index.ts
// [module: explorer-alias] [tags: rename, move, cache-migrate]
import * as vscode from "vscode";
import * as path from "path";
import { AIExplorerProvider } from "./ui/AIExplorerProvider";
import { NameCacheStore } from "./infra/cache/NameCacheStore";
import { GlossaryPolicy } from "./domain/policies/GlossaryPolicy";
import { RuleEngine } from "./domain/policies/RuleEngine";
import { TranslateNodeUseCase } from "./app/TranslateNodeUseCase";
import { TranslateBatchUseCase } from "./app/TranslateBatchUseCase";
import { LearnedGlossaryStore } from "./infra/cache/LearnedGlossaryStore";
import { ProviderRegistry } from "@core/ai/ProviderRegistry";
import { AITranslatorRouter } from "./infra/translators/AITranslatorRouter";

export function registerExplorerAlias(context: vscode.ExtensionContext) {
  // …（你原来的依赖组装，保持不变）
  const cache = new NameCacheStore(context, ".ai-name-cache.json");
  const glossary = new GlossaryPolicy();
  const rules = new RuleEngine();
  const learned = new LearnedGlossaryStore();
  const registry = new ProviderRegistry(context, {
    warn: (m) => console.warn(m),
  });
  const aiRouter = new AITranslatorRouter(registry);
  const translateNode = new TranslateNodeUseCase(
    glossary,
    learned,
    rules,
    cache,
    aiRouter
  );
  const translateBatch = new TranslateBatchUseCase(translateNode, cache, 3);
  const provider = new AIExplorerProvider({
    cache,
    translateNode,
    translateBatch,
    showAlias: true,
  });

  // ✅ 1) VS Code 内部的“移动/重命名”事件（包含文件和文件夹）
  context.subscriptions.push(
    vscode.workspace.onDidRenameFiles(async (e) => {
      for (const { oldUri, newUri } of e.files) {
        const isDir = await isDirectory(newUri);
        const oldBase = path.basename(oldUri.fsPath);
        const newBase = path.basename(newUri.fsPath);

        if (isDir) {
          // 整个文件夹剪切：批量迁移缓存（前缀替换）
          cache.movePrefix(oldUri.fsPath, newUri.fsPath);
        } else {
          // 单文件剪切：迁移缓存
          cache.move(oldUri.fsPath, newUri.fsPath);
        }

        // 若“连文件名也变了”，我们为新名再跑一次翻译（本地链→AI→写回）
        if (oldBase !== newBase) {
          const kind = isDir ? "folder" : "file";
          await translateNode.exec(newUri.fsPath, newBase, kind);
        }
      }
      await cache.flushToDiskIfPossible();
      provider.softRefresh();
    })
  );

  // ✅ 2) 外部文件操作（删除/创建）兜底
  const watcher = vscode.workspace.createFileSystemWatcher("**/*");
  watcher.onDidDelete((uri) => {
    cache.removeOrRemovePrefix(uri.fsPath);
    provider.softRefresh();
  });
  watcher.onDidCreate(async (uri) => {
    const isDir = await isDirectory(uri);
    const base = path.basename(uri.fsPath);
    await translateNode.exec(uri.fsPath, base, isDir ? "folder" : "file"); // 学习词典多数能命中
    provider.softRefresh();
  });
  context.subscriptions.push(watcher);

  // …（注册视图与命令）
  return provider;
}

async function isDirectory(uri: vscode.Uri): Promise<boolean> {
  try {
    return (
      (await vscode.workspace.fs.stat(uri)).type === vscode.FileType.Directory
    );
  } catch {
    return false;
  }
}
```

---

# 二、给缓存实现“前缀迁移/删除”能力（文件夹剪切 & 外部删除）

```ts
// src/features/explorer-alias/infra/cache/NameCacheStore.ts
// [module: explorer-alias] [tags: cache, movePrefix, remove]
import * as vscode from "vscode";
import * as path from "path";
import { AliasResult, CacheStore } from "../../domain/ports";

export class NameCacheStore implements CacheStore {
  private key = "aiSuite.explorerAlias.cache";
  private map = new Map<string, AliasResult>();
  constructor(
    private ctx: vscode.ExtensionContext,
    private cacheFileRel?: string
  ) {
    const obj = this.ctx.workspaceState.get<Record<string, AliasResult>>(
      this.key,
      {}
    );
    for (const [k, v] of Object.entries(obj)) this.map.set(this.norm(k), v);
  }

  // 统一规范化，避免大小写/斜杠差异（Windows）
  private norm(p: string) {
    return path.resolve(p);
  }

  has(fsPath: string) {
    return this.map.has(this.norm(fsPath));
  }
  get(fsPath: string) {
    return this.map.get(this.norm(fsPath));
  }
  set(fsPath: string, v: AliasResult) {
    this.map.set(this.norm(fsPath), v);
    this.persist();
  }

  move(oldFsPath: string, newFsPath: string) {
    const oldN = this.norm(oldFsPath),
      newN = this.norm(newFsPath);
    const v = this.map.get(oldN);
    if (v) {
      this.map.delete(oldN);
      this.map.set(newN, v);
      this.persist();
    }
  }

  /** 整个目录剪切：把 oldDir 下所有项批量迁移到 newDir */
  movePrefix(oldDir: string, newDir: string) {
    const oldN = this.norm(oldDir);
    const newN = this.norm(newDir);
    const updates: Array<{ oldK: string; newK: string; v: AliasResult }> = [];
    for (const [k, v] of this.map.entries()) {
      if (isSubPath(k, oldN)) {
        const rel = path.relative(oldN, k);
        const dest = path.join(newN, rel);
        updates.push({ oldK: k, newK: this.norm(dest), v });
      }
    }
    for (const u of updates) this.map.delete(u.oldK);
    for (const u of updates) this.map.set(u.newK, u.v);
    if (updates.length) this.persist();
  }

  /** 删除单条或整棵子树（外部删除时用） */
  removeOrRemovePrefix(fsPath: string) {
    const n = this.norm(fsPath);
    let touched = false;
    if (this.map.delete(n)) touched = true;
    for (const k of Array.from(this.map.keys())) {
      if (isSubPath(k, n)) {
        this.map.delete(k);
        touched = true;
      }
    }
    if (touched) this.persist();
  }

  async loadFromDiskIfPossible() {
    /* 保持你原有实现 */
  }
  async flushToDiskIfPossible() {
    /* 保持你原有实现 */
  }

  private persist() {
    this.ctx.workspaceState.update(
      this.key,
      Object.fromEntries(this.map.entries())
    );
  }
}

function isSubPath(child: string, parent: string) {
  const rel = path.relative(parent, child);
  return !!rel && !rel.startsWith("..") && !path.isAbsolute(rel);
}
```

---

# 三、翻译决策小策略（什么时候重算、什么时候不动）

- **只换父目录**（`/src/foo.ts` → `/lib/foo.ts`）：
  `basename` 未变 → **直接 `cache.move`**（或 `movePrefix`），**不重新翻译**；UI 立刻显示原有别名。
- **换父目录 + 改名**（`/src/foo.ts` → `/lib/bar.ts`）：
  `basename` 改了 → **迁移缓存**后，再对**新名**调用一次 `TranslateNodeUseCase.exec()`：

  - 多数会命中**学习词典**或**规则**；
  - 都没命中才会调 **AI**；
  - 成功后覆盖新路径的缓存，并把新名**写入学习词典**。

- **剪切整个文件夹**：
  用 `movePrefix(oldDir, newDir)` 一次性迁移整棵子树；
  若同时 **重命名了文件夹名**，建议：

  - 文件夹节点**本身**重新决策一次（它的别名可能变化），
  - 子文件的别名通常**不受父目录名影响**，无需重算（性能更好）。

- **移动到工作区外**：
  调 `removeOrRemovePrefix` 删除缓存，避免**脏数据**；**学习词典**不动（不泄露路径）。
- **外部移动/重命名**：
  `onDidRenameFiles` 不一定触发；`FileSystemWatcher` 会发 **delete+create**。

  - `delete` → `removeOrRemovePrefix(old)`；
  - `create` → `translateNode.exec(new)`（多数命中**学习词典**，无需 AI）。

---

# 四、体验优化（可选）

- **“懒翻译”**：在 `getChildren()` 返回列表后，对**缓存未命中的可见节点**做一次**后台本地翻译**（词表/学习/规则），**不**调用 AI；UI 渐进出现中文。
- **合并重算**：对“改名的文件”批量收集，再一次性走 `translateBatch`（合并成一次 AI 请求、JSON 返回映射）。
- **去重**：很多项目会在不同目录出现同名文件（`index.ts`、`README.md`），批量请求前用 `Set` 去重，省钱提速。

---

# 五、这套处理为什么“稳”

- **路径缓存**与**学习词典**分层：前者跟路径走，后者跟“短名”走；**移动**优先迁移路径缓存，**改名**再落回学习词典 → **少请求、快命中**。
- **前缀迁移**保证**整树移动**不抖动；**外部变更**靠 `FileSystemWatcher` 兜底；**跨工作区**不留脏缓存。
- **最小重算**：只在**basename 改变**时重跑翻译；而这时**学习词典**通常已“学会”，仍旧不需要 API。

---

需要我把这些代码**按你仓库的具体文件路径**发起一个 PR 清单（改哪些文件、插哪几行）吗？这样你粘贴即可用。
