✅ AI 翻译成功（文件）：DEBUG_USEFORM_WARNING_ATTRIBUTION.md → 调试\_USEFORM_WARNING_ATTRIBUTION
已保存到学习词典，下次自动使用此翻译

这种纯大写，怎么办？

你这个结果
**DEBUG_USEFORM_WARNING_ATTRIBUTION.md → 调试\_USEFORM_WARNING_ATTRIBUTION**
说明：**纯大写 token 被当成“缩写（acronym）直接保留”了**，导致 `WARNING / ATTRIBUTION` 没被查词典映射；只有 `DEBUG` 命中词典成了“调试”。这通常是因为分词器里把“所有全大写(≥2)”都判成 `acronym`，然后在词典查找时“遇到 acronym 就直接原样返回”。

## 目标

- 仍然走你喜欢的“**直译 + 保留分隔符 + 保留扩展名**”；
- 但对**纯大写**要“**聪明**”点：

  - **白名单里的真实缩写**（UI/API/HTTP…）→ 保留大写；
  - **其实是普通单词但被大写**（DEBUG/WARNING/ATTRIBUTION…）→ **按小写去查词典**，翻成中文；
  - 不认识的（如 `USEFORM`）→ 交给 **AI 只补词条**（写入直译学习词典），重建时仍保留 `_` 与 `.md`。

下面给你**最小补丁**，直接贴即可（带中文注释与“文件名注释”）。

---

# 1) 配置：新增“缩写白名单 & 大写策略”

在 `package.json → contributes.configuration.properties` 里加两项：

```json
// 文件名: package.json（片段）
{
  "aiSuite.alias.acronymAllowlist": {
    "type": "array",
    "default": [
      "UI",
      "API",
      "HTTP",
      "HTTPS",
      "URL",
      "URI",
      "CPU",
      "GPU",
      "DB",
      "SQL",
      "JSON",
      "XML",
      "CSV",
      "JWT",
      "CSS",
      "HTML",
      "JS",
      "TS",
      "JSX",
      "TSX",
      "DOM",
      "SDK",
      "CLI",
      "CI",
      "CD",
      "MD",
      "PDF",
      "PNG",
      "JPG",
      "GIF",
      "SVG",
      "UUID",
      "ID"
    ],
    "items": { "type": "string" },
    "description": "被视为真正缩写并保留大写原样的列表。其它纯大写将按普通单词去查直译词典。"
  },
  "aiSuite.alias.uppercaseStrategy": {
    "type": "string",
    "enum": ["smart", "keep", "lower"],
    "default": "smart",
    "description": "纯大写 token 处理：smart=白名单保留，其它当普通词；keep=全部保留大写；lower=全部转小写再查词典。"
  }
}
```

---

# 2) 分词器：**不要把所有全大写都当缩写**

把“全大写”改成“**若在白名单才当缩写**，否则当普通单词”，以便词典可用。

```ts
// 文件名: src/shared/naming/NameTokenizer.ts
/**
 * 修复点：全大写(≥2)不一律判为 acronym，而是先看“缩写白名单”。
 */
import * as vscode from "vscode";

function getAcronymAllow(): Set<string> {
  const list = vscode.workspace
    .getConfiguration("aiSuite")
    .get<string[]>("aiSuite.alias.acronymAllowlist", []);
  return new Set(list);
}

export type Token = {
  raw: string;
  lower: string;
  type: "word" | "acronym" | "num";
};

export function tokenizeFileName(name: string): {
  tokens: Token[];
  ext: string;
} {
  // ……保留你现有实现（kebab/snake/camel 拆分）
  // 只改 classify：
  // return tokens.map(classify); ← 改成传 allowlist
}

function classify(raw: string): Token {
  if (/^\d+$/.test(raw)) return { raw, lower: raw, type: "num" };
  const allow = getAcronymAllow();
  if (/^[A-Z]{2,}$/.test(raw)) {
    // 只有白名单里的才当 acronym；否则按普通词（允许词典映射）
    return allow.has(raw)
      ? { raw, lower: raw.toLowerCase(), type: "acronym" }
      : { raw, lower: raw.toLowerCase(), type: "word" };
  }
  return { raw, lower: raw.toLowerCase(), type: "word" };
}
```

> 这样 `DEBUG/WARNING/ATTRIBUTION` 会按普通词处理（lower=debug/warning/attribution），**能被词典命中**；`UI/API/XML` 等仍保留大写。

---

# 3) 词典解析：**acronym 也允许走词典（除非白名单）**

有些项目会特意把 `CSS` 翻成“样式”，也可以映射。把“遇到 acronym 就直接返回 raw”的逻辑收紧到**仅白名单**：

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts
/**
 * 修复点：lookupWord 遇到 acronym 也尝试查词典；
 * 只有白名单里的缩写才强制原样保留。
 */
import * as vscode from 'vscode';

function allowAcr(): Set<string> {
  const list = vscode.workspace.getConfiguration('aiSuite').get<string[]>('aiSuite.alias.acronymAllowlist', []);
  return new Set(list);
}

private lookupWord(norm: string, t: TokenPiece): string | undefined {
  const allow = allowAcr();
  // 1) 先查各层词典（即使是 acronym 也尝试）
  for (const layer of this.layers) {
    const h = layer.words[norm];
    if (h) return h.alias;
  }
  // 2) 词典没命中：白名单里的缩写保留原样，其它返回 undefined 让上层去 AI 兜底或保留英文
  if (t.type === 'acronym' && allow.has(t.raw)) return t.raw;
  return undefined;
}
```

---

# 4) 内置直译词典：补上这些**大写常见词**（小写 key）

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts（builtins 里补充）
words: {
  // …你已有的
  debug: { alias: '调试' },
  warning: { alias: '警告' },
  attribution: { alias: '归因' },
  // 若你希望把 USEFORM 直接保留为 useForm，可加：
  useform: { alias: 'useForm' }
}
```

> 你也可以把这些放到项目直译词典 `/.ai/.ai-literal.dict.json`，更好维护。

---

# 5) AI 兜底：**对纯大写未知词，传递小写给 AI**

避免模型把 `USEFORM` 当作缩写忽略，兜底时传 `lower`：

```ts
// 文件名: src/features/explorer-alias/infra/translators/LiteralAIFallback.ts
/**
 * 把 unknown token 统一转小写发给模型，要求返回 { 英文小写: 中文 } 的 JSON。
 */
const unknownLower = unknown.map((s) => s.toLowerCase());
const usr = {
  fileName,
  unknownTokens: unknownLower,
  examples: [
    /* …略… */
  ],
};
```

---

# 6) 不要把“整名级”写进学习词典（防止覆盖分隔符）

确保**只写 token/短语**，不写 `"DEBUG_USEFORM_WARNING_ATTRIBUTION"` 这种整名 key：

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts
/** 只允许写入形如 "word" 或 "word word" 的 key；拦截包含 _ - . 的整名 */
async writeProjectLearning(k: string, alias: string) {
  const key = k.toLowerCase().replace(/[_\-\.]+/g, ' ').trim();
  if (!/^[a-z0-9]+( [a-z0-9]+)*$/.test(key)) return; // 严禁整名/带符号的 key
  // …正常写入 words[key] = { alias }
}
```

---

# 7) 结果预期（修复后）

- `DEBUG_USEFORM_WARNING_ATTRIBUTION.md`
  → **调试*useForm*警告\_归因.md**

  - `_` 保留；`.md` 保留；
  - `DEBUG/ WARNING/ ATTRIBUTION` 命中字典；
  - `USEFORM` 若词典没有，会触发 AI 返回 `{ "useform": "useForm" }`（或你想要的中文），写入后重建。

---

# 8) 处理历史错误记录

你之前“已保存到学习词典”，**很可能保存的是整名级别**。为了让新规则生效：

1. 打开 `/.ai/.ai-glossary.literal.learned.json`（或你的学习词典文件），**删除**类似
   `"DEBUG_USEFORM_WARNING_ATTRIBUTION": { "alias": "调试_USEFORM_WARNING_ATTRIBUTION" }` 的条目；
2. 运行你扩展里的“**清除此节点缓存**”（或删除本地路径缓存该项）；
3. 右键该文件再次“翻译此文件”。

---

## 小结

- 问题根因：**全大写被一刀切当成缩写 → 直接保留原样**，词典与 AI 都没机会处理；
- 解决：**缩写白名单 + 大写策略**，把 DEBUG/WARNING/ATTRIBUTION 当普通词映射；
- 直译风格下**永远保留分隔符/扩展名**；学习词典只存**词/短语**，**不要存整名**。

要不要我给你做一个**小 PR**，把上述 6 处改动直接对齐到你仓库结构（含默认白名单与词典样例）？复制进去就能看到 `DEBUG_*` 这类马上变成“调试*\**警告\_归因.md”。
