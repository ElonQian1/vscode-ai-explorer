大写也应该能通过字典吧？ 如果翻译错位了，还能用 ai 兜底纠正。

没错！**纯大写**完全可以“先走词典、再由 AI 兜底矫正”。要点是：

1. **字典键一律用小写**（读旧数据时兼容大写）；
2. **分词器别把所有全大写都当缩写**：只对白名单（UI/API/HTTP…）保留大写，其它转小写参与字典；
3. **直译重建始终保留原分隔符/扩展名**；
4. **对齐守卫**：若映射后“有 token 未覆盖/顺序错位”，触发 AI 只返回“缺词/短语的映射 JSON”，写回学习词典，再重建。

下面给你三处**最小补丁**（可直接粘贴）。这样无论 `DEBUG/ WARNING/ ATTRIBUTION` 这种大写词，都会优先命中字典；命不中再通过 AI 自动补词条。

---

# ① 分词器：大写 ≠ 必然缩写（白名单才算）

```ts
// 文件名: src/shared/naming/NameTokenizer.ts
// 作用：全大写(≥2)只有在白名单里才当 acronym，其他按普通词(lower)参与字典匹配。

import * as vscode from "vscode";

function getAcronymAllow(): Set<string> {
  const list = vscode.workspace
    .getConfiguration("aiSuite")
    .get<string[]>("aiSuite.alias.acronymAllowlist", [
      "UI",
      "API",
      "HTTP",
      "HTTPS",
      "URL",
      "ID",
      "HTML",
      "CSS",
      "JS",
      "TS",
      "DOM",
      "SDK",
      "CLI",
      "JWT",
      "XML",
      "JSON",
    ]);
  return new Set(list);
}

export type Token = {
  raw: string;
  lower: string;
  type: "word" | "acronym" | "num";
};

function classify(raw: string): Token {
  if (/^\d+$/.test(raw)) return { raw, lower: raw, type: "num" };
  const allow = getAcronymAllow();
  if (/^[A-Z]{2,}$/.test(raw)) {
    return allow.has(raw)
      ? { raw, lower: raw.toLowerCase(), type: "acronym" } // 真正缩写
      : { raw, lower: raw.toLowerCase(), type: "word" }; // 普通词：转小写参与字典
  }
  return { raw, lower: raw.toLowerCase(), type: "word" };
}
```

---

# ② 字典解析：键统一小写；读旧数据兼容大写；允许短语

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts
// 作用：lookup 时优先用 lower 查；若未命中再尝试 raw（兼容你旧词典是大写键的情况）。
//      短语匹配/单词匹配一律“lower 化”，写入学习词典时也只写小写键。

private lookupWord(norm: string, t: TokenPiece): string | undefined {
  // 1) 先用小写键查所有层
  for (const layer of this.layers) {
    const hit = layer.words[norm];
    if (hit) return hit.alias;
  }
  // 2) 兼容旧数据：如果词典里曾用大写键，尝试 raw
  const rawKey = t.raw;
  if (rawKey && /^[A-Z0-9_]+$/.test(rawKey)) {
    for (const layer of this.layers) {
      const hit = layer.words[rawKey] || layer.words[rawKey.toLowerCase()];
      if (hit) return hit.alias;
    }
  }
  // 3) 白名单缩写原样保留（在 tokenizer 已经区分）
  if (t.type === 'acronym' && getAcronymAllow().has(t.raw)) return t.raw;
  return undefined;
}

/** 写入学习直译词典：只允许 a-z0-9 和空格（短语），禁止写整名（含 -_. 的） */
async writeProjectLearning(k: string, alias: string) {
  const key = k.toLowerCase().replace(/[_\-\.]+/g, ' ').trim();
  if (!/^[a-z0-9]+( [a-z0-9]+)*$/.test(key)) return; // 禁止整名级条目，避免破坏分隔符重建
  // …保持你原来的 JSON 读写
}
```

> 建议在**内置词典或项目词典**里补几条：
> `debug→调试`, `warning→警告`, `attribution→归因`, `useform→useForm`（或你想要的中文），`xml→XML`。

---

# ③ 直译重建 + AI 对齐守卫（兜底纠正错位）

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralPreserveWithAIFallback.ts
// 作用：先按字典直译并“保留分隔符/扩展名”重建；若覆盖率不足或漏词，调用 AI 只补缺词映射，再重建。

import * as vscode from "vscode";
import { splitWithDelimiters } from "@shared/naming/SplitWithDelimiters";
import { LiteralDictResolver } from "@shared/naming/LiteralDictResolver";
import { LiteralAIFallback } from "../../infra/translators/LiteralAIFallback";

export class LiteralPreserveWithAIFallback {
  constructor(
    private dict: LiteralDictResolver,
    private ai: LiteralAIFallback
  ) {}

  async build(fileName: string): Promise<{ alias: string; usedAI: boolean }> {
    const { tokens, delims, ext } = splitWithDelimiters(fileName);
    const r1 = this.dict.resolve(tokens);

    // 覆盖度与对齐守卫：有未知词或映射数≠token数 → AI 兜底
    if (r1.unknown.length > 0 || r1.mapped.length !== tokens.length) {
      const unknownKeys = Array.from(
        new Set(r1.unknown.map((s) => s.toLowerCase()))
      );
      const tokenCtx = tokens.map((t, i) => ({
        raw: t.raw,
        lower: t.lower,
        isAllCaps: /^[A-Z]{2,}$/.test(t.raw),
        left: tokens[i - 1]?.raw,
        right: tokens[i + 1]?.raw,
      }));
      const items = await this.ai.suggestLiteralTokens({
        fileName,
        tokens: tokenCtx,
        unknownKeys,
      });

      // 过滤并写学习词典（只写词/短语的小写键）
      const minConf = vscode.workspace
        .getConfiguration("aiSuite")
        .get<number>("aiSuite.alias.minConfidence", 0.6);
      for (const it of items) {
        if (!it.alias || it.confidence < minConf) continue;
        await this.dict.writeProjectLearning(it.key, it.alias);
      }
      await this.dict.initialize(); // 刷新内存
      const r2 = this.dict.resolve(tokens); // 重新解析
      return {
        alias: rebuild(r2.mapped, delims, ext),
        usedAI: items.length > 0,
      };
    }

    // 直接重建（保留原分隔符/扩展名）
    return { alias: rebuild(r1.mapped, delims, ext), usedAI: false };
  }
}

function rebuild(mapped: string[], delims: string[], ext: string) {
  const keepExt = true;
  let s = "";
  for (let i = 0; i < mapped.length; i++) s += mapped[i] + (delims[i] || "");
  if (keepExt && ext) s += "." + ext;
  return s.replace(/[\\/:*?"<>|]/g, "·").slice(0, 120);
}
```

---

## 这套组合怎么工作（以你的例子）

- `DEBUG_USEFORM_WARNING_ATTRIBUTION.md`

  1. **tokenize**：`DEBUG | USEFORM | WARNING | ATTRIBUTION`

     - `DEBUG/WARNING/ATTRIBUTION` → 非白名单 → 当普通词，用 lower 去查字典 → 命中“调试/警告/归因”；
     - `USEFORM` → 命不中 → 进入未知集合。

  2. **AI 兜底**：给 AI 传 `unknownKeys=["useform"]` + 上下文；AI 返回 `{"items":[{"key":"useform","alias":"useForm","kind":"word","confidence":0.86}]}`。
  3. **写入学习词典（小写键）**，再重建：**调试*useForm*警告\_归因.md**（分隔符与后缀完整保留）。

> 如果你更喜欢 `useform → 使用表单`，直接在项目直译词典 `/.ai/.ai-literal.dict.json` 覆盖即可，AI 不再触发。

---

## 小结（回答你的两个点）

- **“大写也应该能通过字典吧？”**——可以，而且**应该**。关键是：

  - **分词器**不要一刀切把全大写当缩写；
  - **字典键统一小写**（读旧数据兼容大写）；
  - **短语优先**，再到单词；
  - **直译重建**保留分隔符/扩展名。

- **“翻译错位还能 AI 兜底纠正吗？”**——可以。用“**对齐守卫**”检测覆盖率/漏词 →**AI 只补词条 JSON**→ 写回学习词典 →**再次重建**。这样既“死板又快”，又有**高容错**。

要我把这三段补丁按你仓库的文件路径**做成逐行改动清单**（或者直接 PR）吗？复制/合并即可生效。
