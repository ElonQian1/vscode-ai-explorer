绝对是的，除了「纯数字」之外，还有一大堆**典型“没必要丢给 AI”的 token 场景**，会白白烧算力、污染学习词典或引入抖动。下面给你：

- 一份**高概率浪费算力清单**（按优先级/类型分组）
- 一组**可直接粘贴的守卫代码**（AIGuard）：在“AI 兜底”之前一刀切掉这些无效 token，并提供可配开关
- 如何接到你现有的 V2 直译管线（1 行改动）

---

# 哪些最浪费算力？（按类型分组）

1. **可程序化确定的东西**（绝不该调用 AI）

   - 纯数字：`19, 2025, 000123`（你已优化）
   - 语义化版本 / 版本号：`v1, v2, 1.2.3, rc1`
   - 日期/时间/时间戳：`2024-12-31, 20250101, 14_30, 1690000000`
   - 颜色/编码：`#fff, #1e90ff, rgb255_0_0`
   - 文件扩展/生成产物标记：`.min, .bundle, .map, .d.ts, .d.ts.map`

2. **标识符/指纹**（没有翻译意义）

   - 提交哈希/校验和/ID：`a1b2c3d, 3E7F9A2, sha256, md5, uuid`
   - Base64/长串：`[A-Za-z0-9+/=]{16,}`，或“无元音的超长串”
   - 仅符号或噪声：`__`, `---`, `___test___`

3. **固定保留英文/缩写白名单**（翻译只会更怪）

   - 技术缩写（白名单）：`UI, API, HTTP, HTTPS, URL, ID, DOM, SDK, CLI, JWT, CSS, HTML, JS, TS, JSX, TSX, JSON, XML, CSV, PDF, PNG, JPG, GIF, SVG,…`
   - Numeronym：`i18n, l10n, k8s, e2e`
   - 常见库/商标名（建议保留）：`React, Vue, Tailwind, Redux, Jest,…`（可放词典为“原样”）

4. **约定俗成的结构/噪声词**

   - 入口/占位：`index, main, default`（直译策略：要么固定映射，要么保留英文，**不打 AI**）
   - 停用词/介词：`the, a, an, of, for, to, in, on, by`（直译风里通常保留或以规则映射，**不打 AI**）
   - 语言/地区码：`en, zh, en-US, zh-CN, fr-FR`（直接规则化即可）

5. **模式类**

   - React Hooks：`useXxx`（多为专有 API 名，优先词典/保留英文，不丢 AI）
   - ID 复数：`IDs, UUIDs`（规则归一到 `ID/UUID`，无需 AI）
   - 短到没有语义的 token：单字母或 1 位：`a, b, c, x`（直接保留）

6. **应整体跳过的路径/文件**

   - 目录：`node_modules, .git, dist, build, coverage, .ai`
   - 生成/锁文件：`package-lock.json, pnpm-lock.yaml, yarn.lock, .map, .min.*`
   - 二进制/媒体：`*.png, *.jpg, *.gif, *.pdf, *.mp4, *.zip`（不会翻译名字内部 token）

> 以上所有场景，**不该把 token 丢给 AI**；若需要显示中文，**应使用规则/词典/程序化渲染**。

---

# 直接可用的“AI 前置守卫”模块（AIGuard）

> 功能：在「AI 兜底」之前过滤 unknownTokens，只留下**有语义价值且确实需要 AI 的**词/短语。
> 你只需在现有 `LiteralPreserveWithAIFallback.build(...)` 里调用一次 `AIGuard.filterUnknown(...)` 即可。

```ts
// 文件名: src/shared/naming/AIGuard.ts
/**
 * AIGuard：AI 前置守卫
 * - 过滤掉不应送 AI 的 token：数字/版本/日期/哈希/缩写白名单/停用词/噪声等
 * - 可配置开关，并记录过滤统计（便于观察省钱效果）
 */
import * as vscode from "vscode";

export type GuardStats = {
  total: number;
  kept: number;
  dropped: number;
  reasons: Record<string, number>; // 统计各原因
};

export class AIGuard {
  private allowAcr = new Set(
    vscode.workspace
      .getConfiguration("aiSuite")
      .get<string[]>("aiSuite.alias.acronymAllowlist", [
        "UI",
        "API",
        "HTTP",
        "HTTPS",
        "URL",
        "URI",
        "ID",
        "UUID",
        "CSS",
        "HTML",
        "JS",
        "TS",
        "JSX",
        "TSX",
        "JSON",
        "XML",
        "CSV",
        "PDF",
        "PNG",
        "JPG",
        "GIF",
        "SVG",
        "DOM",
        "SDK",
        "CLI",
        "JWT",
      ])
  );
  private stopwords = new Set(
    vscode.workspace
      .getConfiguration("aiSuite")
      .get<string[]>("aiSuite.alias.stopwords", [
        "the",
        "a",
        "an",
        "of",
        "for",
        "to",
        "in",
        "on",
        "by",
        "and",
        "or",
      ])
  );
  private keepVocab = new Set(
    vscode.workspace
      .getConfiguration("aiSuite")
      .get<string[]>("aiSuite.alias.keepEnglishVocab", [
        "react",
        "vue",
        "redux",
        "tailwind",
        "jest",
        "vitest",
        "webpack",
        "vite",
        "eslint",
        "prettier",
      ])
  );
  private cfg = vscode.workspace.getConfiguration("aiSuite");

  filterUnknown(rawUnknown: string[]): { keys: string[]; stats: GuardStats } {
    const stats: GuardStats = {
      total: rawUnknown.length,
      kept: 0,
      dropped: 0,
      reasons: {},
    };
    const uniq = Array.from(new Set(rawUnknown.map((t) => t.toLowerCase())));

    const keep: string[] = [];
    for (const k of uniq) {
      const reason = this.dropReason(k);
      if (reason) {
        stats.dropped++;
        stats.reasons[reason] = (stats.reasons[reason] || 0) + 1;
        continue;
      }
      keep.push(k);
      stats.kept++;
    }
    return { keys: keep, stats };
  }

  private dropReason(k: string): string | null {
    // 开关：可在 settings.json 控制
    const ignoreNumeric = this.cfg.get<boolean>(
      "aiSuite.alias.ai.ignoreNumericTokens",
      true
    );

    if (ignoreNumeric && /^\d+$/.test(k)) return "numeric";
    if (/^v?\d+(\.\d+){0,3}([\-._]?(alpha|beta|rc)\d*)?$/.test(k))
      return "version"; // 语义化版本
    if (/^\d{4}[-_/]?\d{1,2}([-_/]?\d{1,2})?$/.test(k) || /^\d{8}$/.test(k))
      return "date"; // 日期
    if (/^\d{9,}$/.test(k)) return "timestamp"; // 长数字时间戳
    if (/^[a-f0-9]{7,}$/.test(k)) return "hash"; // 简单哈希/ID（小写）
    if (/^[A-F0-9]{7,}$/.test(k)) return "hash";
    if (/^(sha|md5|sha1|sha256|sha512)$/.test(k)) return "hash-algo";
    if (/^i18n|l10n|k8s|e2e$/.test(k)) return "numeronym";
    if (/^[a-z]$/.test(k)) return "too-short";
    if (this.stopwords.has(k)) return "stopword";
    if (this.keepVocab.has(k)) return "keep-english"; // 这些词建议保留英文，不送 AI
    if (/^(en|zh|ja|fr|de|es|pt|ru|ko|it|nl|pl|tr)$/.test(k))
      return "lang-code";
    if (/^[a-z]{2}[-_][A-Za-z]{2}$/.test(k)) return "locale"; // en-US, zh_CN
    if (/^#[0-9a-f]{3}([0-9a-f]{3})?$/.test(k)) return "color";
    if (/^(rgb|rgba|hsl|hsla)[\w\-]*$/.test(k)) return "color-fn";
    if (/^min|map|bundle$/.test(k)) return "build-tag";
    if (/^[\-_\.]+$/.test(k)) return "punct";
    if (this.allowAcr.has(k.toUpperCase())) return "acronym-allow"; // 真缩写：保留英文

    // React Hook 模式：useXxx → 建议不送 AI（保留/词典）
    if (/^use[a-z0-9]/.test(k)) return "react-hook";

    // 超长/疑似噪声（>32 且非单词构成）
    if (k.length > 32 && !/^[a-z0-9]+$/.test(k)) return "gibberish";

    return null;
  }
}
```

---

# 在直译管线里接入（1 行改动）

在你 `LiteralPreserveWithAIFallback.build(...)` 里，生成 `unknownKeys` 后**先过一遍 AIGuard**：

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralPreserveWithAIFallback.ts（片段）
import { AIGuard } from "@shared/naming/AIGuard";

// ……省略前文
const guard = new AIGuard();
const { keys: filteredUnknown, stats } = guard.filterUnknown(r1.unknown);
// 可打印 stats 做审计：console.log('[AIGuard]', stats);

if (filteredUnknown.length > 0) {
  const items = await this.ai.suggestLiteralTokens({
    fileName,
    tokens: tokenCtx,
    unknownKeys: filteredUnknown,
  });
  // ……后续写学习词典 & 重建（你已有的逻辑）
} else {
  // 全部被规则/白名单/可程序化策略覆盖 → 不打 AI，直接重建
}
```

> 搭配你之前的**数字策略**、**白名单缩写**、**直译学习词典只写“词/短语”**，这一下就能把大多数“无效 AI 请求”切掉。

---

# 额外 4 个“省算力”实战建议

1. **批量一次合并请求**
   扫描整个工作区，先走“直译+词典 → 收集 unknown 的并集（经过 AIGuard 过滤）”，**合并成一次 AI 请求**拿回词条，再整体重建。这样第一次也只花 **1 次**。

2. **失败冷却 TTL**
   对“模型没给出有效 JSON/低置信度”的 key，打上 24h 冷却，不要在本次会话反复重试。

3. **形态归一再查词典**
   在送 AI 前把 `analyses→analysis, elements→element, running→run, parsed→parse` 做轻量归一，能大幅减少“伪 unknown”。

4. **在日志中量化**
   输出类似：

   - `AIGuard dropped: {numeric: 12, version: 5, hash: 9, acronym-allow: 7, ...}`
   - `AI call tokens: 23 → learned: 21 → cached-hit next run: 95%`
     这能直接看到“省了多少”。

---

## 结论

- 除了数字，**版本号/日期/哈希/缩写白名单/停用词/颜色/语言码/噪声/生成产物标记**等都应该**提前挡掉**。
- 用上面的 **AIGuard** 模块 + 你已有的 **数字策略**、**白名单缩写**、**只写词/短语的学习词典**，你就能把**AI 请求量**压到最低，同时保持“**死板直译 + AI 兜底**”该有的质量。

需要的话我可以把这几段代码**按你仓库现有路径**出一份“逐行改动清单”，你照着替换即可落地。
