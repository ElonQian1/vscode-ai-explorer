太好了，能看到文件列表就说明 **TreeDataProvider** 已经跑起来了。
在**还没接入 OpenAI**之前，你依然可以用「**词表 + 规则 + 缓存**」先把能命中的名称翻译出来（例如：`README`→`自述`，`src`→`源码`，`utils`→`工具`）。下面给你三步走，马上能用：

---

## 现在就能用的操作（无 OpenAI）

1. **命令面板执行翻译**
   按 `Ctrl/Cmd + Shift + P`，运行：

- `AI 资源管理器：翻译整个工作区`（`aiExplorer.translateAll`）
- 或在树里选中一个节点，运行 `AI 资源管理器：翻译所选节点`（`aiExplorer.translateNode`）

2. **切换显示模式**
   `AI 资源管理器：切换显示 中文别名/原名`（`aiExplorer.toggleShowAlias`）。
   主标题与副标题会互换，方便你对照。

3. **（可选）右键菜单更顺手**
   把以下菜单配置加进 `package.json`（无重启即可生效，F5 的宿主会自动热加载）：

```json
// package.json（片段：让 aiExplorer 视图里有右键项 & 视图标题工具栏）
{
  "contributes": {
    "menus": {
      "view/item/context": [
        {
          "when": "view == aiExplorer",
          "command": "aiExplorer.translateNode",
          "group": "navigation@100"
        },
        {
          "when": "view == aiExplorer && viewItem == file",
          "command": "aiExplorer.renameToAlias",
          "group": "navigation@101"
        },
        {
          "when": "view == aiExplorer && viewItem == folder",
          "command": "aiExplorer.renameToAlias",
          "group": "navigation@101"
        }
      ],
      "view/title": [
        {
          "when": "view == aiExplorer",
          "command": "aiExplorer.translateAll",
          "group": "navigation@100"
        },
        {
          "when": "view == aiExplorer",
          "command": "aiExplorer.toggleShowAlias",
          "group": "navigation@101"
        }
      ]
    }
  }
}
```

> 说明：我们在 `AIExplorerProvider` 里把 `TreeItem.contextValue` 设成了 `file`/`folder`，上面 `when: viewItem == file/folder` 就能精确命中节点类型。

---

## 确认你已经有「本地翻译链」的代码

你仓库里如果还没放这三块，请补上（**只要有它们，就能在没 OpenAI 的情况下翻译常见目录名**）：

1. **词表**（命中率高、置信度 1.0）

```ts
// src/features/explorer-alias/domain/policies/GlossaryPolicy.ts
// [module: explorer-alias] [tags: Glossary, Mapping]
/** 高频英文短名的固定中文映射（如 README/src/utils...） */
export class GlossaryPolicy {
  private map: Record<string, string> = {
    README: "自述",
    readme: "自述",
    src: "源码",
    dist: "构建产物",
    utils: "工具",
    hooks: "钩子",
    components: "组件",
    pages: "页面",
  };
  lookup(name: string) {
    const base = name.replace(/\.(md|txt|json|ts|tsx|js|jsx|mjs|cjs)$/i, "");
    const hit = this.map[base];
    return hit
      ? { alias: hit, source: "dict" as const, confidence: 1.0 }
      : undefined;
  }
}
```

2. **规则**（常见模式，置信度 0.8~0.95）

```ts
// src/features/explorer-alias/domain/policies/RuleEngine.ts
// [module: explorer-alias] [tags: Rules, Heuristics]
/** 简单命名规则（index/main/i18n、驼峰/短横线拆词等） */
export class RuleEngine {
  apply(name: string, kind: "file" | "folder") {
    if (/^index\.[^.]+$/i.test(name))
      return { alias: "索引", source: "rule", confidence: 0.9 };
    if (/^main\.[^.]+$/i.test(name))
      return { alias: "主程序", source: "rule", confidence: 0.9 };
    if (/^i18n$/i.test(name))
      return { alias: "多语言", source: "rule", confidence: 0.95 };
    // 继续补充你的惯用规则...
    return undefined;
  }
}
```

3. **用例：翻译单节点 & 批量**（先词表 → 再规则 → 最后回退原名并缓存）

```ts
// src/features/explorer-alias/app/TranslateNodeUseCase.ts
// [module: explorer-alias] [tags: UseCase, Translate]
export class TranslateNodeUseCase {
  constructor(private glossary: any, private rules: any, private cache: any) {}
  async exec(fsPath: string, name: string, kind: "file" | "folder") {
    const c = this.cache.get(fsPath);
    if (c) return c;
    const d = this.glossary.lookup(name);
    if (d) {
      this.cache.set(fsPath, d);
      return d;
    }
    const r = this.rules.apply(name, kind);
    if (r) {
      this.cache.set(fsPath, r);
      return r;
    }
    const fb = { alias: name, source: "unknown" as const, confidence: 0.5 };
    this.cache.set(fsPath, fb);
    return fb;
  }
}
```

> 这些代码与你之前集成的版本一致；如果你是照我给的骨架做的，直接运行命令就会看到别名生效（比如 `src` 会显示为 **源码**）。

---

## 想快速提高命中率？加一个项目私有词表

给配置里加一个可选的 `glossary.json`，你团队常见名词都能一秒命中、零成本：

```ts
// src/features/explorer-alias/domain/policies/GlossaryPolicy.ts（加入对项目词表的加载）
import * as vscode from "vscode";
export class GlossaryPolicy {
  private map: Record<string, string> = {
    /* 内置映射...*/
  };
  private loaded = false;
  async ensureLoadProjectGlossary() {
    if (this.loaded) return;
    const root = vscode.workspace.workspaceFolders?.[0]?.uri;
    if (!root) return;
    try {
      const file = vscode.Uri.joinPath(root, ".ai-glossary.json");
      const buf = await vscode.workspace.fs.readFile(file);
      Object.assign(this.map, JSON.parse(Buffer.from(buf).toString("utf8")));
    } catch {}
    this.loaded = true;
  }
  async lookup(name: string) {
    await this.ensureLoadProjectGlossary();
    // 余下同上……
  }
}
```

然后在仓库根目录放一个 `.ai-glossary.json`（示例）：

```json
{
  "middlewares": "中间件",
  "dto": "数据传输对象",
  "repositories": "仓储"
}
```

---

## 什么时候该接 OpenAI？怎么最小改动接上？

当你发现本地词表/规则覆盖率不够时，再加 **OpenAITranslator** 接到链路末端即可（不影响现有逻辑）。最小改动步骤：

1. `package.json` 增加设置与命令

```json
{
  "contributes": {
    "commands": [
      {
        "command": "aiSuite.setApiKey",
        "title": "AI Suite：设置 OpenAI API Key"
      }
    ],
    "configuration": {
      "properties": {
        "aiSuite.openai.baseUrl": {
          "type": "string",
          "default": "https://api.openai.com/v1"
        },
        "aiSuite.openai.model.mini": {
          "type": "string",
          "default": "gpt-4o-mini"
        },
        "aiSuite.openai.timeoutMs": { "type": "number", "default": 10000 }
      }
    }
  }
}
```

2. 在 `extension.ts` 注册一个设置 Key 的命令（保存到 SecretStorage）。

3. 新增 `OpenAITranslator.ts`，实现一个 `translateName(name): Promise<AliasResult>`（我之前给过完整实现；需要我把文件再贴一遍也可以）。

4. 在 `TranslateNodeUseCase.exec` 的“回退原名”之前插入 AI 分支：
   词表 → 规则 → **AI** → 回退原名。

这样，你**现在就能用（无 OpenAI）**，以后**无缝升级到 OpenAI**。

---

## 常见“为什么没变化”的排查

- 刚运行完“翻译整个工作区”，很多名称**还是原文**：这正常——本地词表/规则命中的才会改，**没命中的会回退原名**。先把 `.ai-glossary.json` 补起来能立刻提升命中率。
- 侧边栏名称没变？用 `AI 资源管理器：切换显示 中文别名/原名` 看一下；主/副标题会互换。
- 别名生成了，但右键没有“翻译所选节点/重命名”？把上面的 `menus` 片段加进 `package.json`。
- 缓存没落盘？设置里的 `aiSuite.cacheFile`（默认 `.ai-name-cache.json`）确保存在且可写。

---

需要的话，我可以**把 OpenAITranslator 的最小实现**（含超时、限流、退避）直接贴给你，你复制到 `infra/translators/OpenAITranslator.ts`，再在 `TranslateNodeUseCase` 串上就行。
