# 修复：短语匹配时丢失内部分隔符

## 问题描述

用户报告：翻译后的文件名丢失了部分分隔符

### 实际案例

```
原文件名：emergency-fix-loop-cards.js
预期翻译：紧急-修复-循环-卡片.js
实际翻译：紧急修复-循环卡片     ❌（丢失了3个分隔符和扩展名）
```

### 日志分析

```
[强制AI] emergency-fix-loop-cards.js - 提取到 4 个词
AI 写入学习词典:
  - emergency → 紧急
  - fix → 修复
  - emergency fix → 紧急修复（短语）
  - loop → 循环
  - cards → 卡片
  - loop cards → 循环卡片（短语）

最终结果：紧急修复-循环卡片  ❌
```

## 根本原因

### 问题1：短语匹配逻辑

在 `LiteralAliasBuilderV2.ts` 中，当短语匹配成功时：

```typescript
// ❌ 修复前的逻辑
if (phraseEntry && matchedCount > 0) {
    // 短语匹配成功
    mapped.push(phraseEntry.alias);  // ← 直接使用短语翻译 "紧急修复"
    // 短语使用最后一个 token 的分隔符
    mappedDelims.push(delims[i + matchedCount - 1]);  // ← 只保留最后一个分隔符
}
```

**问题分析：**

对于 `emergency-fix-loop-cards`：
- tokens: `[emergency, fix, loop, cards]`
- delims: `["-", "-", "-", ""]`

匹配过程：
1. `emergency fix` 匹配为短语 (matchedCount=2)
   - mapped: `["紧急修复"]`
   - mappedDelims: `[delims[1]="-"]`  
   - **丢失了 delims[0]="-"**  ❌

2. `loop cards` 匹配为短语 (matchedCount=2)
   - mapped: `["紧急修复", "循环卡片"]`
   - mappedDelims: `["-", delims[3]=""]`  
   - **丢失了 delims[2]="-"**  ❌

3. 重建：
   - `紧急修复` + `-` + `循环卡片` = `紧急修复-循环卡片`

### 问题2：AI 提示词误导

在 `LiteralAIFallback.ts` 中，示例输出使用了下划线：

```typescript
// ❌ 修复前的示例
示例输出：
{
  "element": "元素",
  "hierarchy": "层级",
  "element hierarchy": "元素_层级",  // ← 带下划线
  "simple": "简版"
}
```

**问题：**
- AI 可能被误导，在短语翻译中添加分隔符
- 但分隔符类型（`_`）与原文件（`-`）不一致
- 更重要的是，**系统应该自己处理分隔符**，不应依赖 AI

## 解决方案

### 修复1：短语匹配时逐词翻译（保留内部分隔符）

修改 `LiteralAliasBuilderV2.ts` 的短语匹配逻辑：

```typescript
// ✅ 修复后的逻辑
if (phraseEntry && matchedCount > 0) {
    // 短语匹配成功 - 但为了保留内部分隔符，我们逐词翻译
    const phraseTokens = tokens.slice(i, i + matchedCount);
    const phraseTokenStrings = phraseTokens.map(t => t.raw);
    
    // 尝试逐词翻译，用原始分隔符连接
    const wordTranslations: string[] = [];
    for (let j = 0; j < matchedCount; j++) {
        const token = tokens[i + j];
        const wordEntry = this.resolver.resolveWord(token.lower);
        
        if (wordEntry) {
            wordTranslations.push(wordEntry.alias);
        } else if (token.type === 'acronym') {
            wordTranslations.push(token.raw);
        } else {
            wordTranslations.push(token.raw);
        }
        
        // 添加到mapped（每个词单独一项）
        mapped.push(wordTranslations[j]);
        mappedDelims.push(delims[i + j] || '');  // ← 保留每个词的分隔符
    }
    
    debugParts.push(`[${phraseTokenStrings.join(' ')}→${wordTranslations.join('-')} (短语拆分)]`);
    translatedCount += matchedCount;
    i += matchedCount;
}
```

**修复效果：**

对于 `emergency-fix-loop-cards`：

1. `emergency fix` 匹配为短语 (matchedCount=2)
   - 逐词翻译：`emergency → 紧急`, `fix → 修复`
   - mapped: `["紧急", "修复"]`  ✅
   - mappedDelims: `["-", "-"]`  ✅（保留了两个分隔符）

2. `loop cards` 匹配为短语 (matchedCount=2)
   - 逐词翻译：`loop → 循环`, `cards → 卡片`
   - mapped: `["紧急", "修复", "循环", "卡片"]`  ✅
   - mappedDelims: `["-", "-", "-", ""]`  ✅（保留了所有分隔符）

3. 重建：
   - `紧急` + `-` + `修复` + `-` + `循环` + `-` + `卡片` + `` + `.js`
   - = `紧急-修复-循环-卡片.js`  ✅

### 修复2：更新 AI 提示词

修改 `LiteralAIFallback.ts` 的示例输出：

```typescript
// ✅ 修复后的提示词
规则：
...
7. ⚠️ 短语翻译时，只翻译单词本身，不要添加任何分隔符（系统会自动保留原文件的分隔符）

示例输出：
{
  "element": "元素",
  "hierarchy": "层级",
  "element hierarchy": "元素层级",  // ✅ 不带分隔符
  "simple": "简版"
}
```

**修复效果：**
- AI 不再被误导添加分隔符
- 系统统一处理分隔符保留逻辑

## 测试验证

### 测试用例1：连字符文件名

```
原文件名：emergency-fix-loop-cards.js

修复前：
  - 翻译结果：紧急修复-循环卡片  ❌
  - 丢失：2个连字符 + .js扩展名

修复后：
  - 翻译结果：紧急-修复-循环-卡片.js  ✅
  - 保留：所有3个连字符 + .js扩展名
```

### 测试用例2：下划线文件名

```
原文件名：contact_button_structure_analysis.cjs

修复前：
  - 翻译结果：接触按钮_结构分析  ❌
  - 丢失：2个下划线 + .cjs扩展名

修复后：
  - 翻译结果：接触_按钮_结构_分析.cjs  ✅
  - 保留：所有3个下划线 + .cjs扩展名
```

### 测试用例3：混合分隔符

```
原文件名：api_Handler-v2.ts

修复前：
  - 翻译结果：接口处理器v2  ❌
  - 丢失：下划线、连字符、扩展名

修复后：
  - 翻译结果：接口_处理器-v2.ts  ✅
  - 保留：下划线、连字符、扩展名
```

## 核心设计思想

### 原则1：分离关注点

- **AI 职责**：只负责词语翻译（单词或短语）
- **系统职责**：负责分隔符保留和重建

### 原则2：短语识别 ≠ 短语整体翻译

- **短语识别**：知道哪些词应该一起翻译（语义相关）
- **短语拆分翻译**：即使是短语，也逐词翻译并保留内部分隔符
- **好处**：既保留了短语的语义准确性，又保留了原文件名的结构

### 原则3：保留原始文件名结构

用户选择 `keepOriginalDelimiters=true` 的意图是：
- **保留所有分隔符**（不管是单词之间还是短语内部）
- **保留分隔符类型**（`-` 还是 `_`）
- **保留扩展名**（`.js`, `.ts`, `.cjs` 等）

## 代码变更

### 文件1：LiteralAliasBuilderV2.ts

```diff
- if (phraseEntry && matchedCount > 0) {
-     // 短语匹配成功
-     mapped.push(phraseEntry.alias);
-     mappedDelims.push(delims[i + matchedCount - 1] || '');
-     ...
- }
+ if (phraseEntry && matchedCount > 0) {
+     // 短语匹配成功 - 但为了保留内部分隔符，我们逐词翻译
+     const wordTranslations: string[] = [];
+     for (let j = 0; j < matchedCount; j++) {
+         const token = tokens[i + j];
+         const wordEntry = this.resolver.resolveWord(token.lower);
+         
+         if (wordEntry) {
+             wordTranslations.push(wordEntry.alias);
+         } else if (token.type === 'acronym') {
+             wordTranslations.push(token.raw);
+         } else {
+             wordTranslations.push(token.raw);
+         }
+         
+         mapped.push(wordTranslations[j]);
+         mappedDelims.push(delims[i + j] || '');  // ✅ 保留每个词的分隔符
+     }
+     ...
+ }
```

### 文件2：LiteralAIFallback.ts

```diff
 规则：
 ...
 6. 不要生成整句中文，只要单词映射
+7. ⚠️ 短语翻译时，只翻译单词本身，不要添加任何分隔符（系统会自动保留原文件的分隔符）
 
 示例输出：
 {
   "element": "元素",
   "hierarchy": "层级",
-  "element hierarchy": "元素_层级",
+  "element hierarchy": "元素层级",
   "simple": "简版"
 }
```

## 后续步骤

1. **重新加载 VS Code**
   - 按 `Ctrl+Shift+P`
   - 输入 `Reload Window`
   - 回车

2. **清除旧缓存**（可选）
   ```powershell
   Remove-Item -Path ".ai/.cache/translate-*" -Force
   ```

3. **重新翻译测试文件**
   - 右键文件 → "强制用 AI 翻译此文件"
   - 验证分隔符是否完整保留

4. **验证学习词典**
   - 查看 `.ai/.ai-glossary.literal.learned.json`
   - 确认单词和短语都已保存

## 总结

这次修复解决了短语匹配时丢失内部分隔符的问题：

1. **根本原因**：短语匹配后直接使用整体翻译，丢失了内部分隔符
2. **解决方案**：短语匹配后逐词翻译，保留每个词的分隔符
3. **核心思想**：短语识别 ≠ 短语整体翻译，系统负责分隔符保留
4. **预期效果**：完整保留所有分隔符和扩展名

---

**修复日期**：2025-10-15  
**影响范围**：所有使用直译模式 + 保留分隔符的翻译  
**向后兼容**：✅ 兼容旧的学习词典，只改变重建逻辑
