可以！把“直译风格”做成**词典优先 + 最长短语匹配 + 逐词兜底**，基本就能既“原汁原味”又“可控一致”。下面给你一套**可直接落地**的方案与代码（含中文注释 & 文件头注释），把它接到你现有的 `TranslateNodeUseCase` 上即可。

---

# 一、设计要点（直译风格如何“很好地利用字典”）

- **分层词典**（优先级从高到低）

  1. **项目固定直译词典**：`/.ai/.ai-literal.dict.json`（团队口径，强约束）
  2. **项目学习直译词典**：`/.ai/.ai-glossary.literal.learned.json`（AI 或人工新增）
  3. **全局直译词典**：`globalStorage/glossary.literal.json`（跨项目通用）
  4. **内置直译词典**：代码内置基础覆盖（analysis→ 分析、element→ 元素…）

- **最长短语优先**：用**Trie（前缀树）**做 _greedy longest match_

  - 先匹配 `element hierarchy` → “元素\_层级”，再单词级匹配，最后保留英文原词。
  - 兼容 `kebab/snake/camel/Pascal`，自动还原成小写 token。

- **形态归一**：简单还原**复数/动词变形**（`elements→element`、`analyses→analysis`、`analyzing→analyze`…），提升命中率。

- **缩写识别**：UI/API/ID…保持大写英文或映射到中文（由词典控制）。

- **可配置连接符与后缀**：默认 `_`，`.cjs → _脚本`、`.ts → _模块`、`.tsx → _组件`（可关）。

- **AI 辅助“长尾新增”**（可选开关）：AI 只在词典全未命中时介入，把返回的**逐词/短语直译**写入“项目学习直译词典”，以后**零请求**命中。

---

# 二、配置（`package.json` 追加）

```json
// 文件名: package.json（片段：contributes.configuration.properties 下追加）
{
  "aiSuite.alias.style": {
    "type": "string",
    "enum": ["natural", "literal"],
    "default": "literal",
    "description": "别名风格：natural=自然中文；literal=直译（逐词、原顺序、连接符拼接）"
  },
  "aiSuite.alias.literalJoiner": {
    "type": "string",
    "default": "_",
    "description": "直译风格下用于连接中文词元的连接符"
  },
  "aiSuite.alias.appendExtSuffix": {
    "type": "boolean",
    "default": true,
    "description": "是否按扩展名追加后缀（_脚本/_模块/_组件）"
  },
  "aiSuite.alias.literalDictPaths": {
    "type": "array",
    "default": [
      ".ai/.ai-literal.dict.json",
      ".ai/.ai-glossary.literal.learned.json"
    ],
    "items": { "type": "string" },
    "description": "直译词典文件相对路径（按顺序覆盖）"
  }
}
```

---

# 三、代码 ①：**词典解析与最长短语匹配**（可直接用）

```ts
// 文件名: src/shared/naming/DictionaryResolver.ts
/**
 * DictionaryResolver：直译风格的“词典优先 + 最长短语匹配”解析器
 * - 分层加载词典（项目固定 / 项目学习 / 全局 / 内置）
 * - 形态归一（复数/进行时/过去式 等的轻量化还原）
 * - Trie 最长匹配（先 phrase 再单词）
 * - 命中返回中文词元数组，未命中保留英文原词
 */
import * as vscode from "vscode";
import * as path from "path";

export type DictEntry = { alias: string };
type DictMap = Record<string, DictEntry>; // "element" -> { alias:"元素" }
type PhraseMap = Record<string, DictEntry>; // "element hierarchy" -> { alias:"元素_层级" }

type Token = { raw: string; lower: string; type: "word" | "acronym" | "num" };

export interface LoadResult {
  words: DictMap;
  phrases: PhraseMap;
}

export class DictionaryResolver {
  private layers: LoadResult[] = [];
  private trieRoot: TrieNode = new TrieNode();
  private builtins: LoadResult = {
    words: {
      analyze: { alias: "分析" },
      analysis: { alias: "分析" },
      element: { alias: "元素" },
      hierarchy: { alias: "层级" },
      simple: { alias: "简版" },
      example: { alias: "示例" },
      sample: { alias: "示例" },
      api: { alias: "API" },
      ui: { alias: "UI" },
    },
    phrases: {
      "element hierarchy": { alias: "元素_层级" },
    },
  };

  constructor(private ctx: vscode.ExtensionContext) {}

  /** 对外入口：传 token 序列，返回中文词元数组 */
  resolve(tokens: Token[]): { words: string[]; misses: string[] } {
    const normSeq = tokens.map((t) => normalizeForm(t.lower));
    const words: string[] = [];
    const misses: string[] = [];

    // 1) 先做短语最长匹配
    let i = 0;
    while (i < normSeq.length) {
      const hit = this.matchPhrase(normSeq, i);
      if (hit) {
        words.push(hit.zh);
        i = hit.next;
        continue;
      }
      // 2) 单词级匹配（分层词典）
      const zh = this.lookupWord(normSeq[i], tokens[i]);
      if (zh) {
        words.push(zh);
      } else {
        words.push(tokens[i].raw); // 未命中保留原词
        misses.push(tokens[i].raw);
      }
      i++;
    }
    return { words, misses };
  }

  /** 初始化/重载：读取配置的 literalDictPaths + 全局词典 + 内置 */
  async initialize() {
    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const rels = cfg.get<string[]>("aiSuite.alias.literalDictPaths", []);
    this.layers = [];

    // 项目层：按顺序加载
    const root = vscode.workspace.workspaceFolders?.[0]?.uri;
    if (root) {
      for (const rel of rels) {
        const file = vscode.Uri.joinPath(root, rel);
        const loaded = await this.tryLoadJson(file);
        if (loaded) this.layers.push(loaded);
      }
    }

    // 全局层
    const globalUri = vscode.Uri.joinPath(
      this.ctx.globalStorageUri,
      "glossary.literal.json"
    );
    const globalLoaded = await this.tryLoadJson(globalUri);
    if (globalLoaded) this.layers.push(globalLoaded);

    // 内置层（最低）
    this.layers.push(this.builtins);

    // 构建 Trie
    this.rebuildTrie();
  }

  /** 将（多层）短语词典合并为 Trie */
  private rebuildTrie() {
    this.trieRoot = new TrieNode();
    // 越靠前优先级越高
    for (const layer of this.layers) {
      for (const key of Object.keys(layer.phrases || {})) {
        const seq = key.split(/\s+/g).filter(Boolean);
        this.trieRoot.insert(seq, layer.phrases[key].alias);
      }
    }
  }

  /** 从高到低查单词映射 */
  private lookupWord(norm: string, tok: Token): string | undefined {
    // 缩写（UI/API/ID…）优先保留原样
    if (tok.type === "acronym") return tok.raw;

    for (const layer of this.layers) {
      const hit = layer.words[norm];
      if (hit) return hit.alias;
    }
    return undefined;
  }

  /** Trie 最长匹配：返回 { zh, next } 或 undefined */
  private matchPhrase(
    seq: string[],
    start: number
  ): { zh: string; next: number } | undefined {
    let node = this.trieRoot;
    let i = start;
    let lastHit: { zh: string; next: number } | undefined;

    while (i < seq.length) {
      const child = node.children.get(seq[i]);
      if (!child) break;
      node = child;
      i++;
      if (node.value) lastHit = { zh: node.value, next: i };
    }
    return lastHit;
  }

  /** 尝试读取 JSON 文件。支持两种格式：
   * 1) { "words": { "element": {"alias":"元素"} }, "phrases": { "element hierarchy": {"alias":"元素_层级"} } }
   * 2) { "element": {"alias":"元素"}, "element hierarchy": {"alias":"元素_层级"} } // 扁平形式
   */
  private async tryLoadJson(uri: vscode.Uri): Promise<LoadResult | undefined> {
    try {
      await vscode.workspace.fs.createDirectory(
        uri.with({ path: path.dirname(uri.path) })
      );
      const buf = await vscode.workspace.fs.readFile(uri);
      const txt = Buffer.from(buf).toString("utf8").trim();
      if (!txt) return;
      const raw = JSON.parse(txt);
      const words: DictMap = {};
      const phrases: PhraseMap = {};
      if (raw.words || raw.phrases) {
        Object.assign(words, raw.words || {});
        Object.assign(phrases, raw.phrases || {});
      } else {
        // 扁平：用空格数量判定短语
        for (const k of Object.keys(raw)) {
          if (k.includes(" ")) phrases[k] = raw[k];
          else words[k] = raw[k];
        }
      }
      // 归一 key
      const normWords: DictMap = {};
      for (const k of Object.keys(words)) normWords[k.toLowerCase()] = words[k];
      const normPhrases: PhraseMap = {};
      for (const k of Object.keys(phrases))
        normPhrases[k.toLowerCase()] = phrases[k];
      return { words: normWords, phrases: normPhrases };
    } catch {
      return;
    }
  }
}

/** 轻量形态还原（80% 常见场景够用） */
function normalizeForm(w: string): string {
  const irregular: Record<string, string> = { analyses: "analysis" };
  if (irregular[w]) return irregular[w];
  if (w.endsWith("ies") && w.length > 3) return w.slice(0, -3) + "y";
  if (w.endsWith("ing") && w.length > 4) return w.slice(0, -3);
  if (w.endsWith("ed") && w.length > 3) return w.slice(0, -2);
  if (w.endsWith("es") && /s|x|z|ch|sh$/.test(w.slice(0, -2)))
    return w.slice(0, -2);
  if (w.endsWith("s") && w.length > 2) return w.slice(0, -1);
  return w;
}

class TrieNode {
  children = new Map<string, TrieNode>();
  value?: string;
  insert(seq: string[], zh: string) {
    let n: TrieNode = this;
    for (const s of seq) {
      const key = s.toLowerCase();
      if (!n.children.has(key)) n.children.set(key, new TrieNode());
      n = n.children.get(key)!;
    }
    // 保留第一个插入（高优层优先），不被低优层覆盖
    if (!n.value) n.value = zh;
  }
}
```

---

# 四、代码 ②：**Pro 版直译构建器**（连接词典 + 后缀 + 覆盖率）

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralAliasBuilderPro.ts
/**
 * LiteralAliasBuilderPro：直译风格生成器（词典优先 + 短语匹配 + 逐词兜底）
 * - 使用 DictionaryResolver 解析 tokens 为中文词元
 * - 按配置连接符拼接（默认 "_"）
 * - 可选追加扩展名后缀（_脚本/_模块/_组件）
 * - 计算覆盖率（多少 token 被映射），可用于报警或回退策略
 */
import * as vscode from "vscode";
import { tokenizeFileName } from "@shared/naming/NameTokenizer";
import { DictionaryResolver } from "@shared/naming/DictionaryResolver";

const ExtSuffix: Record<string, string> = {
  tsx: "组件",
  jsx: "组件",
  ts: "模块",
  js: "脚本",
  mjs: "脚本",
  cjs: "脚本",
};

export class LiteralAliasBuilderPro {
  constructor(private dict: DictionaryResolver) {}

  async build(
    name: string
  ): Promise<{ alias: string; coverage: number; debug: string }> {
    const { tokens, ext } = tokenizeFileName(name);
    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const joiner = cfg.get<string>("aiSuite.alias.literalJoiner", "_");
    const appendSuffix = cfg.get<boolean>(
      "aiSuite.alias.appendExtSuffix",
      true
    );

    const { words, misses } = this.dict.resolve(tokens);
    const core = words.join(joiner);
    const suffix =
      appendSuffix && ExtSuffix[ext] ? joiner + ExtSuffix[ext] : "";
    const alias = sanitize(core + suffix);

    const coverage = tokens.length
      ? (tokens.length - misses.length) / tokens.length
      : 1;
    const debug = `literalPro tokens=${tokens
      .map((t) => t.raw)
      .join("|")} words=${words.join("|")} misses=${misses.join(
      "|"
    )} ext=${ext}`;

    return { alias, coverage, debug };
  }
}

function sanitize(s: string) {
  return (s || "").replace(/[\\/:*?"<>|]/g, "·").slice(0, 64);
}
```

---

# 五、用例接线（直译风格分支替换为 Pro 版）

```ts
// 文件名: src/features/explorer-alias/app/TranslateNodeUseCase.ts
/**
 * 在直译风格下，使用 LiteralAliasBuilderPro（词典优先）
 */
import * as vscode from "vscode";
import { DictionaryResolver } from "@shared/naming/DictionaryResolver";
import { LiteralAliasBuilderPro } from "../domain/policies/LiteralAliasBuilderPro";
import { ProjectGlossaryStore } from "../infra/cache/ProjectGlossaryStore";
import { AITranslatorRouter } from "../infra/translators/AITranslatorRouter";

type AliasResult = {
  alias: string;
  source: "dict" | "rule" | "ai" | "unknown";
  confidence: number;
};

export class TranslateNodeUseCase {
  private dict: DictionaryResolver;
  private literalPro: LiteralAliasBuilderPro;

  constructor(
    private glossary: { lookup(n: string): AliasResult | undefined },
    private learned: ProjectGlossaryStore,
    private cache: {
      get(p: string): AliasResult | undefined;
      set(p: string, r: AliasResult): void;
    },
    private ai?: AITranslatorRouter
  ) {
    this.dict = new DictionaryResolver(
      (vscode as any).extensions?.getExtension?.id
        ? (vscode as any).extensions.getExtension.id
        : ({} as any)
    );
    // ↑ 如果拿不到 ctx，这里在外层构造时传入 ExtensionContext
    // 实际用法：new DictionaryResolver(context)
    this.literalPro = new LiteralAliasBuilderPro(this.dict);
    // 初始化词典
    this.dict.initialize();
  }

  async exec(
    fsPath: string,
    name: string,
    kind: "file" | "folder"
  ): Promise<AliasResult> {
    const c = this.cache.get(fsPath);
    if (c) return c;

    const style = vscode.workspace
      .getConfiguration("aiSuite")
      .get<"natural" | "literal">("aiSuite.alias.style", "literal");

    // 1) 词表（你原有的固定/项目/全局，自然风格）
    const d = this.glossary.lookup(name);
    if (d) {
      this.cache.set(fsPath, d);
      return d;
    }

    // 2) 学习词典（自然风格；直译学习词典由 literalPro 写入）
    const l = await this.learned.get(name);
    if (l) {
      const r: AliasResult = { alias: l.alias, source: "ai", confidence: 0.9 };
      this.cache.set(fsPath, r);
      return r;
    }

    // 3) 直译风格分支（优先）
    if (style === "literal" && kind === "file") {
      const { alias, coverage } = await this.literalPro.build(name);
      // 覆盖率太低（比如全是生僻词）→ 可选：触发 AI 增量学习一次
      if (coverage < 0.5 && this.ai) {
        try {
          const map = await this.ai.translateAliasBatch([name]);
          const aiAlias = (map[name] || "").trim();
          if (aiAlias) {
            // 将 AI 返回的直译结果持久化到“直译学习词典”
            await this.persistLiteralLearning(name, aiAlias);
            const r: AliasResult = {
              alias: aiAlias,
              source: "ai",
              confidence: 0.88,
            };
            this.cache.set(fsPath, r);
            return r;
          }
        } catch {}
      }
      const r: AliasResult = { alias, source: "rule", confidence: 0.9 };
      this.cache.set(fsPath, r);
      return r;
    }

    // 4) 非直译风格（或文件夹）→ 走你原来的自然规则 / IndexAware / AI 兜底…
    // ……（保持你已有实现）
    const fb: AliasResult = { alias: name, source: "unknown", confidence: 0.5 };
    this.cache.set(fsPath, fb);
    return fb;
  }

  /** 把 AI 学到的直译写入“项目学习直译词典” */
  private async persistLiteralLearning(name: string, alias: string) {
    const root = vscode.workspace.workspaceFolders?.[0]?.uri;
    if (!root) return;
    const rel = ".ai/.ai-glossary.literal.learned.json";
    const uri = vscode.Uri.joinPath(root, rel);
    try {
      let obj: any = {};
      try {
        const buf = await vscode.workspace.fs.readFile(uri);
        obj = JSON.parse(Buffer.from(buf).toString("utf8") || "{}");
      } catch {}
      if (!obj.words) obj.words = {};
      const key = stripExtLower(name);
      obj.words[key] = { alias };
      await vscode.workspace.fs.createDirectory(
        vscode.Uri.joinPath(root, ".ai")
      );
      await vscode.workspace.fs.writeFile(
        uri,
        Buffer.from(JSON.stringify(obj, null, 2), "utf8")
      );
    } catch {}
  }
}

function stripExtLower(n: string) {
  const i = n.lastIndexOf(".");
  return (i > 0 ? n.slice(0, i) : n).toLowerCase();
}
```

> **注意**：上面构造 `DictionaryResolver` 时需要 `ExtensionContext`。如果你在此处不方便拿到，就在外层（例如 `registerExplorerAlias` 里）创建并注入。

---

# 六、项目直译词典样例（放到仓库）

```json
// 文件名: .ai/.ai-literal.dict.json
{
  "words": {
    "analyze": { "alias": "分析" },
    "analysis": { "alias": "分析" },
    "element": { "alias": "元素" },
    "hierarchy": { "alias": "层级" },
    "simple": { "alias": "简版" },
    "status": { "alias": "状态" },
    "section": { "alias": "区块" },
    "contact": { "alias": "联系人" },
    "api": { "alias": "API" },
    "ui": { "alias": "UI" }
  },
  "phrases": {
    "element hierarchy": { "alias": "元素_层级" },
    "analysis status": { "alias": "分析_状态" },
    "status section": { "alias": "状态_区块" }
  }
}
```

> 以后你/AI 学到的新词，写到 `/.ai/.ai-glossary.literal.learned.json`，**始终置于 `.ai-literal.dict.json` 之后**，这样你可以随时“提级/覆盖”。

---

# 七、你关心的两个文件，直译风格产出

- `analyze_element_hierarchy.cjs` → **分析*元素*层级\_脚本**

  - 因为短语命中 `element hierarchy`，也会得到 **分析*元素*层级\_脚本**（一致）

- `analyze_hierarchy_simple.cjs` → **分析*层级*简版\_脚本**

> 如果你更喜欢**无后缀**：把 `aiSuite.alias.appendExtSuffix` 关掉即可。

---

# 八、使用与自测

1. 在设置里把 `aiSuite.alias.style` 设为 **literal**，`literalJoiner` 设为 **\_**。
2. 在仓库根新建 `/.ai/.ai-literal.dict.json`（用上面的样例）。
3. 重载窗口或在激活时 `await dict.initialize()`。
4. 右键你的两个 `.cjs` 文件 → “翻译此文件”。

   - 预期立即得到 **分析*元素*层级\_脚本**、**分析*层级*简版\_脚本**；
   - 不会调用 AI（日志面板不出现 POST）；
   - 若遇到完全未收录的新词，会保留英文，并把覆盖率显示在 debug（你可选择触发 AI 学习一次）。

---

## 总结

- 直译要想“稳 + 好用”，关键是**词典分层 + 最长短语匹配 + 形态归一**。
- 上面的 `DictionaryResolver` + `LiteralAliasBuilderPro` 就是为此服务：**字典命中优先**、**多词短语先于单词**、**未命中不丢词**。
- 需要时再**用 AI 做长尾增补**，并自动写回“学习直译词典”，之后**零请求**命中。

如果你愿意，我可以**按你的仓库结构**给出“精确到文件与行号的补丁清单”，你复制粘贴就能跑。
