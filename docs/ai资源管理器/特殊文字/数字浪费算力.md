[DictionaryResolver] 已写入学习词典: 19 → 十九
extensionHostProcess.js:207
[DictionaryResolver] 已写入学习词典: 57 → 五十七

这种就不应该浪费算力了。

完全同意，“19 → 十九”“57 → 五十七”这类**纯数字**不该走 AI、也不该写进学习词典。优化目标：

- **不发送数字到 AI**（省钱省时）；
- **不把数字写入学习词典**（避免污染）；
- **按配置决定数字如何展示**（保留阿拉伯数字 / 转中文数字 / 罗马数字等）。

下面给你一套「最小增量补丁」，直接粘贴即可把管线修好（含中文注释&文件头注释）。

---

## 总体改动点（3 件事）

1. **在直译 builder 里过滤数字**：`unknownKeys` 里剔除纯数字 token，AI 不再看到它们。
2. **学习词典写入“守卫”**：禁止把纯数字或包含 `-_.` 的整名写入。
3. **数值策略（可选）**：新增配置 `numberMode`：

   - `keep`：保持 `19`；
   - `cn`：转成 `十九`；
   - `roman`（可选）：`4 → IV`；
     统一在重建前做，不用 AI。

---

## 1) 配置开关（package.json）

```json
// 文件名: package.json（片段，contributes.configuration.properties 下追加）
{
  "aiSuite.alias.numberMode": {
    "type": "string",
    "enum": ["keep", "cn", "roman"],
    "default": "keep",
    "description": "数字显示策略：keep=保持阿拉伯数字；cn=中文数字；roman=罗马数字（仅小范围演示）。"
  },
  "aiSuite.alias.ai.ignoreNumericTokens": {
    "type": "boolean",
    "default": true,
    "description": "AI 兜底时忽略纯数字 token（节省费用与时延）。"
  },
  "aiSuite.alias.learning.blockNumericKeys": {
    "type": "boolean",
    "default": true,
    "description": "学习词典写入时，禁止纯数字键（如 '19'）。"
  }
}
```

---

## 2) 数值策略工具（新增文件）

```ts
// 文件名: src/shared/naming/NumeralPolicy.ts
/**
 * 数值策略：根据配置把“纯数字 token”转换为目标表示：
 * - keep: 保持阿拉伯数字
 * - cn:   转中文数字（支持到万/亿/兆，够日常文件名）
 * - roman: 简单罗马数字（1-3999）
 * 注意：这里只处理“纯数字字符串”，带字母的如 v2/sha256 不改，由上层决定。
 */
import * as vscode from "vscode";

export function renderNumericToken(numStr: string): string {
  const mode = vscode.workspace
    .getConfiguration("aiSuite")
    .get<"keep" | "cn" | "roman">("aiSuite.alias.numberMode", "keep");
  if (mode === "keep") return numStr;
  const n = Number(numStr);
  if (!Number.isFinite(n) || n < 0) return numStr;

  if (mode === "cn") return toChineseNumber(n);
  if (mode === "roman") return toRoman(n) || numStr;
  return numStr;
}

// —— 中文数字（简体）——
const CN_DIG = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
const CN_UNIT = ["", "十", "百", "千"];
const CN_BIG = ["", "万", "亿", "兆"]; // 可继续扩展 京 垓…

function toChineseNumber(n: number): string {
  if (n === 0) return "零";
  let s = "";
  let bigIdx = 0;
  while (n > 0) {
    const part = n % 10000;
    if (part !== 0) {
      const block = fourDigitsToCn(part);
      s =
        block +
        CN_BIG[bigIdx] +
        (s ? (s.startsWith("零") ? s.slice(1) : s) : "");
    } else if (!s.startsWith("零")) {
      s = "零" + s;
    }
    n = Math.floor(n / 10000);
    bigIdx++;
  }
  // 处理“一十X”→“十X”
  s = s.replace(/^一十/, "十");
  // 去尾部多余“零”
  s = s.replace(/零+$/, "");
  // 合并多零
  s = s.replace(/零零+/g, "零");
  return s;
}

function fourDigitsToCn(n: number): string {
  const d = [
    Math.floor(n / 1000) % 10,
    Math.floor(n / 100) % 10,
    Math.floor(n / 10) % 10,
    n % 10,
  ];
  let s = "";
  for (let i = 0; i < 4; i++) {
    if (d[i] === 0) {
      if (!s.endsWith("零") && s !== "") s += "零";
    } else {
      s += CN_DIG[d[i]] + CN_UNIT[3 - i];
    }
  }
  s = s.replace(/零+$/, "").replace(/零零+/g, "零");
  return s;
}

// —— 罗马数字（1~3999）——
const ROMAN_TABLE: Array<[number, string]> = [
  [1000, "M"],
  [900, "CM"],
  [500, "D"],
  [400, "CD"],
  [100, "C"],
  [90, "XC"],
  [50, "L"],
  [40, "XL"],
  [10, "X"],
  [9, "IX"],
  [5, "V"],
  [4, "IV"],
  [1, "I"],
];

function toRoman(n: number): string | undefined {
  if (n <= 0 || n >= 4000) return;
  let s = "";
  for (const [v, sym] of ROMAN_TABLE) {
    while (n >= v) {
      s += sym;
      n -= v;
    }
  }
  return s;
}

/** 简单判断“纯数字” */
export function isPureNumericToken(s: string): boolean {
  return /^\d+$/.test(s);
}
```

---

## 3) 直译 builder：**不把数字丢给 AI**，并在重建时渲染数字

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralPreserveWithAIFallback.ts
/**
 * 关键改动：
 * - unknownKeys 生成时，过滤掉“纯数字 token”（由配置控制，默认忽略）
 * - 重建前对数字 token 按 NumeralPolicy 渲染（keep/cn/roman）
 */
import * as vscode from "vscode";
import { splitWithDelimiters } from "@shared/naming/SplitWithDelimiters";
import { LiteralDictResolver } from "@shared/naming/LiteralDictResolver";
import { LiteralAIFallback } from "../../infra/translators/LiteralAIFallback";
import {
  renderNumericToken,
  isPureNumericToken,
} from "@shared/naming/NumeralPolicy";

export class LiteralPreserveWithAIFallback {
  constructor(
    private dict: LiteralDictResolver,
    private ai: LiteralAIFallback
  ) {}

  async build(
    fileName: string
  ): Promise<{ alias: string; usedAI: boolean; misses: string[] }> {
    const { tokens, delims, ext } = splitWithDelimiters(fileName);
    // 先用字典解析
    const r1 = this.dict.resolve(tokens);

    // —— 数字渲染（在 mapped 阶段替换纯数字映射）——
    const mappedWithNums = r1.mapped.map((w, idx) => {
      // 若该 token 原本就是数字，且当前映射依旧是原数字，则按策略渲染
      if (isPureNumericToken(tokens[idx].raw)) {
        // 如果字典把它映射成中文了也尊重字典；否则按策略渲染
        return w === tokens[idx].raw ? renderNumericToken(tokens[idx].raw) : w;
      }
      return w;
    });

    // 若无未知词，直接重建
    if (r1.unknown.length === 0) {
      return {
        alias: rebuild(mappedWithNums, delims, ext),
        usedAI: false,
        misses: [],
      };
    }

    // —— 过滤数字，不让 AI 处理（避免浪费）——
    const ignoreNumeric = vscode.workspace
      .getConfiguration("aiSuite")
      .get<boolean>("aiSuite.alias.ai.ignoreNumericTokens", true);
    const unknownKeysRaw = r1.unknown;
    const unknownKeys = Array.from(
      new Set(
        unknownKeysRaw
          .filter((k) => !(ignoreNumeric && isPureNumericToken(k)))
          .map((s) => s.toLowerCase())
      )
    );

    if (unknownKeys.length > 0) {
      const tokenCtx = tokens.map((t, i) => ({
        raw: t.raw,
        lower: t.lower,
        isAllCaps: /^[A-Z]{2,}$/.test(t.raw),
        left: tokens[i - 1]?.raw,
        right: tokens[i + 1]?.raw,
      }));
      const items = await this.ai.suggestLiteralTokens({
        fileName,
        tokens: tokenCtx,
        unknownKeys,
      });

      const minConf = vscode.workspace
        .getConfiguration("aiSuite")
        .get<number>("aiSuite.alias.minConfidence", 0.6);
      for (const it of items) {
        if (!it.alias || it.confidence < minConf) continue;
        await this.dict.writeProjectLearning(it.key, it.alias); // 只写词/短语，小写键；内部已阻断纯数字
      }
      await this.dict.initialize();
      const r2 = this.dict.resolve(tokens);

      // 再做一次数字渲染，确保最终一致
      const mappedFinal = r2.mapped.map((w, idx) => {
        if (isPureNumericToken(tokens[idx].raw)) {
          return w === tokens[idx].raw
            ? renderNumericToken(tokens[idx].raw)
            : w;
        }
        return w;
      });

      return {
        alias: rebuild(mappedFinal, delims, ext),
        usedAI: items.length > 0,
        misses: r2.unknown,
      };
    }

    // 如果过滤后已没有可交给 AI 的未知词，直接重建（数字已渲染）
    return {
      alias: rebuild(mappedWithNums, delims, ext),
      usedAI: false,
      misses: r1.unknown,
    };
  }
}

function rebuild(mapped: string[], delims: string[], ext: string) {
  let s = "";
  for (let i = 0; i < mapped.length; i++) s += mapped[i] + (delims[i] || "");
  if (ext) s += "." + ext;
  return s.replace(/[\\/:*?"<>|]/g, "·").slice(0, 120);
}
```

---

## 4) 学习词典写入“守卫”：**禁止数字键**

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts
/**
 * 关键改动：writeProjectLearning 拒绝纯数字键；只接受 a-z0-9 与空格（短语）
 */
async writeProjectLearning(k: string, alias: string) {
  const blockNumeric = vscode.workspace.getConfiguration('aiSuite').get<boolean>('aiSuite.alias.learning.blockNumericKeys', true);
  const key = k.toLowerCase().replace(/[_\-\.]+/g, ' ').trim();

  if (!/^[a-z0-9]+( [a-z0-9]+)*$/.test(key)) return;       // 禁止整名/带符号键
  if (blockNumeric && /^\d+$/.test(key)) return;           // 禁止纯数字
  // ……下面保持你原来的 JSON 读写逻辑
}
```

---

## 5) 结果与行为（修复后）

- `file-19-logs.txt`

  - `19` 不会再请求 AI，也不会写入学习词典；
  - `numberMode=keep` → **…-19-…**；`cn` → **…-十九-…**；`roman` → **…-XIX-…**（示范）。

- 日志不再出现：
  `已写入学习词典: 19 → 十九 / 57 → 五十七`
- 批量时，AI 请求数**明显下降**；学习词典更“干净”（只有词/短语的业务词条）。

---

## 额外建议（可选，但很香）

- **混合字母+数字的规则**：`v2 / sha256 / http2` 这类建议**默认保持**，不要送 AI；需要时在词典里只定“字母部分”的映射（如 `sha → SHA`），数字自然保留。
- **最小调用**：批量翻译时把**全局未知词并集**一次丢给 AI，拿回统一词条后批量重建（你现在的设计已接近）。
- **审计日志**：记录“**AI 返回但被数字守卫过滤**”的条目计数，便于你确认“省钱效果”。

---

如果你愿意，我可以把这些补丁按你仓库的目录结构，列成“逐行替换清单”（包含行号），你照着改就能把「数字不走 AI & 不写学习词典」这一块彻底稳住。
