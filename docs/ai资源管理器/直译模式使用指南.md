# "死板又快"直译模式 - 使用指南

## 🎯 核心理念

**死板**：保留原文件名的所有特征
- 保留分隔符类型（`_` `-` `.` 驼峰）
- 保留扩展名
- 逐词翻译，不重组语序

**又快**：智能降级策略
- 词典命中 → 秒出
- 未知词 → AI 兜底（只翻译缺失词）
- 学习增强 → 下次直接命中

---

## 📦 功能特性

### 1. 保留分隔符
```
analyze_element_hierarchy.cjs  →  分析_元素_层级.cjs
simple-example-test.js         →  简版-示例-测试.js
UserAPI.handler.ts             →  用户API.处理器.ts
get.user.info.py               →  获取.用户.信息.py
```

### 2. 短语匹配优先
```
element hierarchy  →  元素_层级  (整体匹配)
而不是            →  元素 层级   (逐词匹配)
```

### 3. 形态归一化
```
elements    →  element  (复数还原)
analyzing   →  analyze  (动名词还原)
analyzed    →  analyze  (过去式还原)
hierarchies →  hierarchy
```

### 4. AI 兜底（只补缺词）
```
原文件名: get.user.info.py
第一次：  get.用户.info.py  (未知词: get, info)
↓ AI 兜底
AI 返回:  { "get": "获取", "info": "信息" }
↓ 写回词典
第二次：  获取.用户.信息.py  (100% 覆盖)
```

---

## 🚀 快速开始

### 1. 启用直译模式

```json
// settings.json
{
  "aiExplorer.alias.style": "literal"
}
```

### 2. 配置词典路径（可选）

```json
{
  "aiExplorer.alias.literalDictPaths": [
    ".ai/.ai-literal.dict.json",           // 项目固定词典
    ".ai/.ai-glossary.literal.learned.json" // AI 学习词典
  ]
}
```

### 3. 创建项目词典（可选）

创建文件：`.ai/.ai-literal.dict.json`

```json
{
  "words": {
    "analyze": { "alias": "分析", "confidence": 1.0 },
    "element": { "alias": "元素", "confidence": 1.0 },
    "hierarchy": { "alias": "层级", "confidence": 1.0 }
  },
  "phrases": {
    "element hierarchy": { "alias": "元素_层级", "confidence": 1.0 }
  }
}
```

---

## 💡 工作流程

### 标准流程（无未知词）

```mermaid
文件名 → 分词保留分隔符 → 词典匹配 → 重建别名 → 完成
```

### AI 兜底流程（有未知词）

```mermaid
文件名 
→ 分词保留分隔符 
→ 词典匹配 
→ 发现未知词 
→ AI 翻译缺失词 
→ 写入学习词典 
→ 重新翻译 
→ 完成
```

---

## 📊 效果对比

### 传统全文翻译
- ❌ 每次都调用 AI
- ❌ 成本高、延迟大
- ❌ 翻译不一致

### 死板又快模式
- ✅ 词典命中秒出
- ✅ AI 只补缺词
- ✅ 学习增强，越用越快
- ✅ 翻译一致性 100%

### 性能对比

| 场景 | 传统模式 | 死板又快模式 |
|-----|---------|------------|
| 首次翻译 10 个文件 | 10 次 AI 调用 | 1 次 AI 调用（批量补缺词） |
| 第二次翻译 | 10 次 AI 调用 | 0 次 AI 调用（全命中词典） |
| 延迟 | 5-10 秒 | < 100ms |
| 成本 | 高 | 极低 |

---

## 🔧 高级配置

### 1. 自定义连接符（目前未使用）

```json
{
  "aiExplorer.alias.literalJoiner": "_"
}
```

> **注意**：V2 版本保留原始分隔符，此配置暂不生效

### 2. 扩展名处理

```json
{
  "aiExplorer.alias.appendExtSuffix": true  // 保留扩展名
}
```

### 3. 批量优化

系统自动收集所有未知词，一次性发送给 AI，降低调用次数。

---

## 📝 词典维护

### 学习词典路径

```
.ai/.ai-glossary.literal.learned.json
```

### 词典格式

```json
{
  "words": {
    "token1": { "alias": "中文1", "confidence": 1.0 },
    "token2": { "alias": "中文2", "confidence": 1.0 }
  },
  "phrases": {
    "token1 token2": { "alias": "中文1_中文2", "confidence": 1.0 }
  }
}
```

### 手动添加词汇

1. 编辑 `.ai/.ai-literal.dict.json`（项目级固定词典）
2. 添加常用词汇和短语
3. 重新加载 VS Code 窗口

---

## 🎯 最佳实践

### 1. 项目初始化
创建项目固定词典，添加领域特定词汇：

```json
{
  "words": {
    "auth": { "alias": "认证" },
    "middleware": { "alias": "中间件" },
    "controller": { "alias": "控制器" }
  },
  "phrases": {
    "auth middleware": { "alias": "认证_中间件" }
  }
}
```

### 2. 批量翻译
- 首次翻译一批文件时，AI 会学习所有未知词
- 后续翻译同类文件时，全部命中词典，秒出

### 3. 团队协作
- 将 `.ai/.ai-literal.dict.json` 提交到 Git
- 团队共享领域词汇
- 学习词典（`.learned.json`）可加入 `.gitignore`

---

## 🔍 调试模式

### 查看翻译详情

检查日志输出：

```
直译V2模式: analyze_element_hierarchy.cjs 
→ 分析_元素_层级.cjs 
(literal-v2:analyze→分析|[element hierarchy→元素_层级] ext=cjs coverage=100%)
```

### 统计信息

```
翻译完成 - 总计: 100
缓存: 20
词典: 30
直译: 40
AI补缺词: 10  ← 只有 10 个文件触发 AI
命中率: 90%
```

---

## ❓ 常见问题

### Q1: 为什么还是调用了 AI？
A: 词典中没有某些词，触发 AI 兜底。查看日志中的"未知词"列表。

### Q2: 如何禁用 AI 兜底？
A: 目前不支持。建议完善项目词典，减少未知词。

### Q3: 学习词典会越来越大吗？
A: 是的，但这正是"越用越快"的核心。可定期清理不常用的词。

### Q4: 短语匹配优先级？
A: 最长匹配优先。例如 `element hierarchy` 优先匹配 `元素_层级`，而不是 `元素 层级`。

---

## 📈 性能优化建议

### 1. 项目初始化阶段
- 手动创建核心词典（100-200 个常用词）
- 批量翻译一次，生成学习词典

### 2. 日常使用
- 95%+ 的翻译直接命中词典
- 偶尔新词触发 AI 兜底
- 学习词典自动更新

### 3. 团队协作
- 定期同步项目固定词典
- 共享领域知识
- 减少重复学习

---

## 🎉 总结

**死板又快**直译模式通过：
- ✅ **保留原始结构**（分隔符 + 扩展名）
- ✅ **词典优先**（秒出，零成本）
- ✅ **AI 精准兜底**（只补缺词，成本最低）
- ✅ **学习增强**（越用越快）

实现了**高性能、低成本、一致性**的文件名翻译！
