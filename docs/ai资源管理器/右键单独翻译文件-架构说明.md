# 右键单独翻译文件 - 架构设计与实现

## 🎯 功能目标

实现在 AI 资源管理器和 VS Code 原生资源管理器中右键点击文件，只翻译该单个文件（不递归目录）。

## 📐 架构设计

### 1. 三层架构

```
┌─────────────────────────────────────────────────────────┐
│                    UI Layer (视图层)                      │
│  - package.json (菜单配置)                                │
│  - AIExplorerProvider.translateThisFile()                │
│  - 处理参数解析(节点/Uri/活动编辑器)                       │
└─────────────────┬───────────────────────────────────────┘
                  │
                  │ 调用
                  ↓
┌─────────────────────────────────────────────────────────┐
│              Application Layer (应用层)                   │
│  - EnhancedTranslateBatchUseCase.translateSingle()       │
│  - TranslateBatchUseCase.translateSingleFile()           │
│  - 执行翻译逻辑，管理缓存                                  │
└─────────────────┬───────────────────────────────────────┘
                  │
                  │ 依赖
                  ↓
┌─────────────────────────────────────────────────────────┐
│              Infrastructure Layer (基础层)                │
│  - MultiProviderAIClient (AI 调用)                       │
│  - KVCache (缓存管理)                                     │
│  - DictionaryManager (词典管理)                           │
│  - PromptProfiles (提示词配置)                            │
└─────────────────────────────────────────────────────────┘
```

### 2. 数据流

```
用户右键点击文件
    ↓
VS Code 触发命令 (aiExplorer.translateThisFile)
    ↓
AIExplorerProvider.translateThisFile(arg)
    ↓
解析参数 → 文件 Uri
    ↓
调用 EnhancedTranslateBatchUseCase.translateSingle(fileName)
    ↓
执行翻译链路:
  1. 检查缓存 (Cache Hit → 返回)
  2. 查询词典 (Dictionary Hit → 返回)
  3. 应用规则 (Rule Match → 返回)
  4. 调用 AI (MultiProviderAIClient)
  5. 保存结果到缓存
    ↓
更新树视图 (updateAlias + refresh)
    ↓
显示结果提示
```

### 3. 参数解析逻辑

`translateThisFile` 需要兼容多种来源的参数：

```typescript
// 1. 来自 AI Explorer 视图的节点
{ node: FileNode, uri: vscode.Uri, ... }

// 2. 来自原生资源管理器的 Uri
vscode.Uri (直接传入)

// 3. 来自命令面板 (无参数)
undefined → 使用活动编辑器文件

// 4. 其他可能的格式
{ resourceUri: vscode.Uri }
{ path: string }
```

## 🔧 实现步骤

### Step 1: package.json 配置

```json
{
  "contributes": {
    "commands": [
      {
        "command": "aiExplorer.translateThisFile",
        "title": "AI 资源管理器：翻译此文件（仅此文件）",
        "icon": "$(symbol-text)"
      }
    ],
    "menus": {
      "view/item/context": [
        {
          "when": "view == aiExplorer && (viewItem == file || viewItem == fileHasAlias)",
          "command": "aiExplorer.translateThisFile",
          "group": "navigation@15"
        }
      ],
      "explorer/context": [
        {
          "when": "resourceScheme == file",
          "command": "aiExplorer.translateThisFile",
          "group": "navigation@915"
        }
      ]
    }
  }
}
```

### Step 2: AIExplorerProvider 实现

```typescript
async translateThisFile(input?: any): Promise<void> {
    // 1. 参数解析
    const uri = await this.resolveToFileUri(input);
    if (!uri) {
        vscode.window.showWarningMessage("请选择一个文件执行翻译");
        return;
    }

    // 2. 验证是文件（非目录）
    const stat = await vscode.workspace.fs.stat(uri).catch(() => undefined);
    if (!stat || stat.type !== vscode.FileType.File) {
        vscode.window.showWarningMessage("当前选择的不是文件");
        return;
    }

    // 3. 获取文件信息
    const fsPath = uri.fsPath;
    const fileName = path.basename(fsPath);

    // 4. 执行翻译（调用 UseCase）
    try {
        const result = await this.translateUseCase!.translateSingle(fileName, {
            forceRefresh: false,
            enableLearning: true
        });

        // 5. 更新树视图
        const node = this.findNodeByPath(fsPath);
        if (node) {
            this.updateAlias(node, result.translated);
        }

        // 6. 显示结果
        const sourceMap: Record<string, string> = {
            'dictionary': '词典',
            'rule': '规则',
            'ai': 'AI',
            'cache': '缓存',
            'fallback': '回退'
        };
        
        vscode.window.showInformationMessage(
            `已翻译：${fileName} → ${result.translated}（来源：${sourceMap[result.source || 'unknown'] || result.source}）`
        );

    } catch (error) {
        this.logger.error('翻译失败', error);
        vscode.window.showErrorMessage(
            `翻译失败: ${error instanceof Error ? error.message : '未知错误'}`
        );
    }
}

// 参数解析辅助方法
private async resolveToFileUri(input?: any): Promise<vscode.Uri | undefined> {
    if (!input) {
        // 无参数 → 使用活动编辑器
        return vscode.window.activeTextEditor?.document?.uri;
    }
    if (input instanceof vscode.Uri) return input;
    if (typeof input === "string") return vscode.Uri.file(input);
    if (input.resourceUri instanceof vscode.Uri) return input.resourceUri;
    if (input.uri instanceof vscode.Uri) return input.uri;
    if (input.node && input.node.path) return vscode.Uri.file(input.node.path);
    if (input.path && typeof input.path === "string") return vscode.Uri.file(input.path);
    return undefined;
}
```

### Step 3: ExplorerAliasModule 注册命令

```typescript
private registerCommands(context: vscode.ExtensionContext): void {
    // ... 其他命令 ...

    // 单文件翻译命令
    this.registerCommand(context, 'aiExplorer.translateThisFile', async (item) => {
        await this.treeProvider?.translateThisFile(item);
    });
}
```

## 🔍 与批量翻译的区别

| 特性 | 单文件翻译 | 批量翻译 |
|------|-----------|---------|
| **触发方式** | 右键单个文件 | 工具栏/命令面板 |
| **处理范围** | 仅当前文件 | 递归目录 |
| **性能影响** | 最小 | 可能较大 |
| **结果反馈** | 即时提示（含来源） | 进度条+统计 |
| **缓存策略** | 优先使用缓存 | 批量查询+批量写入 |
| **AI 调用** | 单次请求 | 批处理（3-10个/批） |

## 🎨 用户体验设计

### 1. 菜单显示条件

```typescript
// AI Explorer 视图中
when: "view == aiExplorer && (viewItem == file || viewItem == fileHasAlias)"

// 原生资源管理器中
when: "resourceScheme == file"
```

### 2. 结果提示格式

```
✅ 成功案例
已翻译：package.json → 包配置文件（来源：词典）
已翻译：UserService.ts → 用户服务（来源：AI）

⚠️ 警告案例
此文件已有别名，无需重复翻译
当前选择的不是文件

❌ 错误案例
翻译失败: AI 服务不可用
翻译失败: 网络超时
```

### 3. 图标选择

```json
{
  "icon": "$(symbol-text)"  // 文本符号，表示翻译
}
```

## 🧪 测试场景

### 场景 1: AI Explorer 视图右键

1. 在 AI Explorer 中展开文件夹
2. 右键点击文件 `index.ts`
3. 选择 "翻译此文件（仅此文件）"
4. 验证：
   - 仅该文件被翻译
   - 树视图更新显示别名
   - 提示框显示翻译结果和来源

### 场景 2: 原生资源管理器右键

1. 在 VS Code 左侧资源管理器中
2. 右键点击文件
3. 选择 "AI 资源管理器：翻译此文件（仅此文件）"
4. 验证：
   - 翻译成功
   - AI Explorer 视图同步更新（如果已展开）

### 场景 3: 命令面板调用

1. 打开文件 `config.json`
2. `Ctrl+Shift+P` 打开命令面板
3. 输入 "翻译此文件"
4. 验证：
   - 当前编辑器文件被翻译

### 场景 4: 缓存命中

1. 翻译过的文件再次右键翻译
2. 验证：
   - 瞬间返回（无 AI 调用）
   - 提示显示 "来源：缓存"

### 场景 5: 词典命中

1. 右键翻译 `README.md`
2. 验证：
   - 使用词典预定义翻译
   - 提示显示 "来源：词典"

## 📊 性能优化

### 1. 缓存优先策略

```typescript
async translateSingle(fileName: string): Promise<TranslationResult> {
    // 1. 检查缓存 (< 1ms)
    const cached = await this.getCachedTranslation(fileName);
    if (cached) return cached;

    // 2. 查询词典 (< 5ms)
    const dictResult = this.dictionary.translate(fileName);
    if (dictResult) return { ...dictResult, source: 'dictionary' };

    // 3. 应用规则 (< 10ms)
    const ruleResult = this.applyRules(fileName);
    if (ruleResult) return { ...ruleResult, source: 'rule' };

    // 4. 调用 AI (100-2000ms)
    return await this.callAI(fileName);
}
```

### 2. 并发控制

- 单文件翻译：无需并发控制
- 批量翻译：使用批处理（batchSize: 3-10）

### 3. 缓存策略

```typescript
// 缓存键格式
const cacheKey = `enhanced-translation:${fileName}`;

// 缓存有效期
const CACHE_TTL = 7 * 24 * 60 * 60 * 1000; // 7天

// 缓存数据结构
{
    original: "index.ts",
    translated: "入口文件",
    source: "ai",
    confidence: 0.95,
    timestamp: 1697234567890
}
```

## 🔒 错误处理

```typescript
try {
    const result = await this.translateSingle(fileName);
    // 成功处理...
} catch (error) {
    if (error instanceof AIServiceError) {
        vscode.window.showErrorMessage('AI 服务不可用，请检查配置');
    } else if (error instanceof NetworkError) {
        vscode.window.showErrorMessage('网络连接失败，请稍后重试');
    } else {
        vscode.window.showErrorMessage(`翻译失败: ${error.message}`);
    }
    this.logger.error('翻译失败', error);
}
```

## 📝 日志记录

```typescript
// 成功日志
this.logger.info(`翻译成功: ${fileName} -> ${result.translated} (来源: ${result.source})`);

// 缓存命中日志
this.logger.debug(`缓存命中: ${fileName} -> ${cachedResult.translated}`);

// 错误日志
this.logger.error(`翻译失败: ${fileName}`, error);

// 性能日志
this.logger.perf(`翻译耗时: ${fileName} - ${duration}ms`);
```

## 🚀 后续优化方向

1. **右键菜单增强**
   - 添加 "强制重新翻译" 选项（忽略缓存）
   - 添加 "添加到词典" 选项（保存自定义翻译）

2. **翻译质量提升**
   - 支持上下文感知（根据文件所在目录）
   - 支持文件类型特定规则

3. **用户体验优化**
   - 翻译进度指示（对于大文件）
   - 翻译历史记录查看
   - 快捷键支持

4. **智能推荐**
   - 检测到英文文件时自动提示翻译
   - 批量翻译后显示统计报告

## 📚 相关文档

- [翻译模块设计](./第3步.md)
- [AI 提供商配置](./ai-providers.md)
- [缓存策略说明](./cache-strategy.md)
- [词典管理指南](./dictionary-management.md)
