D:\rust\active-projects\小红书\employeeGUI\analyze_element_hierarchy.cjs
D:\rust\active-projects\小红书\employeeGUI\analyze_hierarchy_simple.cjs
ai 翻译成：
层级分析脚本
层级分析（简版）脚本
这样好吗？

我怎么感觉直译比较好：
分析*元素*层级
分析*层级*例子

这是代码的什么问题？

你看到这两个结果：

- `analyze_element_hierarchy.cjs` → **层级分析脚本**（丢了“元素”）
- `analyze_hierarchy_simple.cjs` → **层级分析（简版）脚本**

不是“错”，而是**当前风格是“自然中文”**（可读性优先：重组语序 + 加后缀“脚本”），再加上你的词典/规则里对 `element` 可能没映射，导致被压缩掉了。
而你想要的是**“直译风格”**（逐词保留 + 原顺序 + `_` 连接），比如：

- `analyze_element_hierarchy.cjs` → **分析*元素*层级**（可选是否加“\_脚本”）
- `analyze_hierarchy_simple.cjs` → **分析*层级*简版**（你给的“例子”是 _example_ 的意思，`simple` 更贴近“简版/简单”）

这不是“AI 不知道干嘛”，而是**翻译风格没对齐**。解决思路：

1. 给翻译管线加一个**风格开关**：`natural`（自然中文，默认） / `literal`（直译）。
2. 规则/AI 两条路都遵守这个风格：

   - 规则命中时按风格产出；
   - 未命中走 AI 时，**提示词**要求“仅按指定风格输出”。

3. 加一个**覆盖度守卫（coverage guard）**：AI 返回的别名若**漏掉源 tokens**（比如漏了“element”），自动退回“直译风格”。

下面给你“可直接粘贴”的最小补丁：配置项 + 直译构建器 + 覆盖度守卫 + 接线点（保持中文注释、带文件名）。

---

## 一、package.json：加风格/后缀配置

```json
// 文件名: package.json（片段，放在 contributes.configuration.properties 下）
{
  "aiSuite.alias.style": {
    "type": "string",
    "enum": ["natural", "literal"],
    "default": "natural",
    "description": "别名风格：natural=自然中文重组；literal=直译（逐词、原顺序、连接符拼接）"
  },
  "aiSuite.alias.appendExtSuffix": {
    "type": "boolean",
    "default": true,
    "description": "是否根据扩展名追加后缀（如 .cjs => 脚本, .ts => 模块, .tsx => 组件）"
  },
  "aiSuite.alias.literalJoiner": {
    "type": "string",
    "default": "_",
    "description": "直译风格下的连接符，例如 _ 或 ·"
  }
}
```

---

## 二、直译构建器：逐词保留 + 原顺序 + 可选后缀

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralAliasBuilder.ts
/**
 * 直译风格构建器：逐词保留、原顺序拼接，未知词不丢弃。
 * - analyze -> 分析, element -> 元素, hierarchy -> 层级, simple -> 简版
 * - 连接符由配置控制（默认 "_"）
 * - 可选扩展名后缀（脚本/模块/组件）
 */
import { tokenizeFileName, stripExt } from "@shared/naming/NameTokenizer";
import * as vscode from "vscode";

const MapZH: Record<string, string> = {
  analyze: "分析",
  analysis: "分析",
  element: "元素",
  hierarchy: "层级",
  simple: "简版",
  basic: "基础",
  example: "示例",
  sample: "示例",
  // 你可继续扩充…
};

const ExtSuffix: Record<string, string> = {
  tsx: "组件",
  jsx: "组件",
  ts: "模块",
  js: "脚本",
  mjs: "脚本",
  cjs: "脚本",
};

export function buildLiteralAlias(name: string): {
  alias: string;
  debug: string;
} {
  const { tokens, ext } = tokenizeFileName(name);
  const cfg = vscode.workspace.getConfiguration("aiSuite");
  const joiner = cfg.get<string>("aiSuite.alias.literalJoiner", "_");
  const appendSuffix = cfg.get<boolean>("aiSuite.alias.appendExtSuffix", true);

  const words = tokens.map((t) => MapZH[t.lower] || t.raw); // 未映射保留原词
  const core = words.join(joiner);
  const suffix = appendSuffix && ExtSuffix[ext] ? joiner + ExtSuffix[ext] : "";
  const alias = sanitize(core + suffix);
  return { alias, debug: `literal:${words.join("|")} ext=${ext}` };
}

function sanitize(s: string) {
  return (s || "").replace(/[\\/:*?"<>|]/g, "·").slice(0, 64);
}
```

---

## 三、覆盖度守卫：防止 AI 漏词（如漏掉 element）

```ts
// 文件名: src/features/explorer-alias/domain/policies/CoverageGuard.ts
/**
 * 覆盖度守卫：检测别名是否覆盖了源 tokens（模糊比对）。
 * - 若丢词过多（默认 >0），建议回退到“直译风格”以保证不丢信息。
 */
import { tokenizeFileName } from "@shared/naming/NameTokenizer";

export function isCoverageSufficient(
  sourceName: string,
  aliasZh: string,
  allowMiss = 0
): boolean {
  const { tokens } = tokenizeFileName(sourceName);
  let miss = 0;
  for (const t of tokens) {
    const en = t.lower;
    if (StopWords.has(en)) continue;
    const zh = Dict[en];
    // 模糊规则：若有中文映射则看中文是否出现；否则看英文是否被保留（直译可能保留）
    const ok = zh
      ? aliasZh.includes(zh)
      : aliasZh.toLowerCase().includes(t.raw.toLowerCase());
    if (!ok) miss++;
  }
  return miss <= allowMiss;
}

const Dict: Record<string, string> = {
  analyze: "分析",
  analysis: "分析",
  element: "元素",
  hierarchy: "层级",
  simple: "简版",
  basic: "基础",
  example: "示例",
  sample: "示例",
};

const StopWords = new Set(["the", "a", "an"]); // 可扩展
```

---

## 四、用例接线：按风格产出 + AI 兜底 + 覆盖度守卫

```ts
// 文件名: src/features/explorer-alias/app/TranslateNodeUseCase.ts
/**
 * 顺序：词表 → 学习词典 → 入口规则(IndexAware，可选) → 自然规则(SmartRule)或直译 → AI兜底 → 覆盖度守卫 → 回退
 * - 根据配置 aiSuite.alias.style 选择 natural/literal
 * - AI 返回若漏词，自动退回“直译风格”
 */
import * as vscode from "vscode";
import { ProjectGlossaryStore } from "../infra/cache/ProjectGlossaryStore";
import { AITranslatorRouter } from "../infra/translators/AITranslatorRouter";
import { SmartRuleEngine } from "../domain/policies/SmartRuleEngine";
import { IndexAwareRule } from "../domain/policies/IndexAwareRule";
import { buildLiteralAlias } from "../domain/policies/LiteralAliasBuilder";
import { isCoverageSufficient } from "../domain/policies/CoverageGuard";

type AliasResult = {
  alias: string;
  source: "dict" | "rule" | "ai" | "unknown";
  confidence: number;
};

export class TranslateNodeUseCase {
  private smart = new SmartRuleEngine();
  private indexAware: IndexAwareRule;

  constructor(
    private glossary: { lookup(n: string): AliasResult | undefined },
    private learned: ProjectGlossaryStore,
    private cache: {
      get(p: string): AliasResult | undefined;
      set(p: string, r: AliasResult): void;
    },
    private ai?: AITranslatorRouter
  ) {
    this.indexAware = new IndexAwareRule({
      cache: this.cache as any,
      glossary: this.glossary as any,
      smartRule: this.smart,
    });
  }

  async exec(
    fsPath: string,
    name: string,
    kind: "file" | "folder"
  ): Promise<AliasResult> {
    const c = this.cache.get(fsPath);
    if (c) return c;

    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const style = cfg.get<"natural" | "literal">(
      "aiSuite.alias.style",
      "natural"
    );

    // 1) 词表
    const d = this.glossary.lookup(name);
    if (d) {
      this.cache.set(fsPath, d);
      return d;
    }

    // 2) 学习词典
    const l = await this.learned.get(name);
    if (l) {
      const r: AliasResult = { alias: l.alias, source: "ai", confidence: 0.9 };
      this.cache.set(fsPath, r);
      return r;
    }

    // 3) 入口规则（index/main/default）
    const idx = this.indexAware.translate(fsPath, name, kind);
    if (idx) {
      this.cache.set(fsPath, idx);
      return idx;
    }

    // 4) 本地规则或直译
    if (style === "natural") {
      const r = this.smart.translate(name);
      if (r) {
        this.cache.set(fsPath, r);
        return r;
      }
    } else {
      const r = buildLiteralAlias(name);
      const res: AliasResult = {
        alias: r.alias,
        source: "rule",
        confidence: 0.9,
      };
      this.cache.set(fsPath, res);
      return res;
    }

    // 5) AI 兜底（保持风格一致）
    if (this.ai) {
      try {
        const map = await this.ai.translateAliasBatch([
          stylePromptName(name, style),
        ]);
        // 兜底约定：如果我们传入 "name|style=literal"，就按原名取值
        const alias = sanitize(
          map[name] || map[stylePromptName(name, style)] || ""
        );
        if (alias) {
          // 覆盖度守卫：AI 若漏词（如漏了 element），退回直译
          const ok = isCoverageSufficient(name, alias, /*allowMiss*/ 0);
          const finalAlias = ok ? alias : buildLiteralAlias(name).alias;

          const r: AliasResult = {
            alias: finalAlias,
            source: "ai",
            confidence: ok ? 0.9 : 0.85,
          };
          this.cache.set(fsPath, r);
          await this.learned.set(name, {
            alias: finalAlias,
            source: "ai",
            at: new Date().toISOString(),
            model: "auto",
            profile: "alias@1",
          });
          return r;
        }
      } catch {}
    }

    // 6) 回退：按风格回退
    const fb: AliasResult =
      style === "literal"
        ? {
            alias: buildLiteralAlias(name).alias,
            source: "rule",
            confidence: 0.8,
          }
        : { alias: name, source: "unknown", confidence: 0.5 };
    this.cache.set(fsPath, fb);
    return fb;
  }
}

function sanitize(s: string) {
  return (s || "").replace(/[\\/:*?"<>|]/g, "·").slice(0, 64);
}
function stylePromptName(name: string, style: "natural" | "literal") {
  return name; /* 也可传带 style 的提示 key */
}
```

---

## 五、（可选）AI 提示词：约束风格 & 覆盖全部 token

把你给模型的 system prompt 改成更严格（关键句子）：

```
你是文件名本地化助手。只输出 JSON 对象，不要解释。
键是原英文短名（不带路径），值是中文别名。
【风格=natural】请生成自然中文，必要时重组语序；但不得遗漏任何关键信息。
【风格=literal】严格逐词直译，保持原顺序，用配置的连接符拼接；未知词保留英文原词；不得遗漏任何词。
别名不超过16个汉字；不要输出换行或多余文本。
```

> 这样做 + “覆盖度守卫”，就能最大限度避免“漏词”；一旦漏词，**立即回退到直译**，绝不丢信息。

---

## 这两条给你的具体结论

- 你现在看到“**层级分析脚本**”少了“元素”，**不是 bug**，是“自然中文风格 + 词典未覆盖 `element`”导致的压缩。
- 想要**逐词直译**（`分析_元素_层级`）：切换 `aiSuite.alias.style = "literal"`，或右键“强制直译”（你可以再加一个只走 `LiteralAliasBuilder` 的命令）。
- `simple` 直译应是“**简版/简单**”，不是“例子”（那是 _example/sample_）。如果你就是想统一叫“示例”，在项目词表里把 `simple→示例` 覆盖也行。

---

### 你的两个文件，按两种风格最终会是：

- **自然中文（默认）**

  - `analyze_element_hierarchy.cjs` → **元素层级分析脚本**（推荐；补了“元素”）
  - `analyze_hierarchy_simple.cjs` → **层级分析（简版）脚本**

- **直译**（`aiSuite.alias.style = "literal"`）

  - `analyze_element_hierarchy.cjs` → **分析*元素*层级\_脚本**（若 `appendExtSuffix=true`）
  - `analyze_hierarchy_simple.cjs` → **分析*层级*简版\_脚本**

需要的话，我可以把上面的三个文件直接对齐到你仓库，并给你一个“**命令：切换风格/强制直译**”的小补丁，粘贴即用。
