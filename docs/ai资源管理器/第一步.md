下面给你一套“现在就能开工”的**模块优先级 + 模块化架构**落地方案。按这个走，后面再加新功能也不会乱。

---

# 先做哪个模块？

**顺序建议（单插件内）：**

1. **Core 地基（必做，第 0 步）**
   统一的 OpenAI 客户端、限流/并发、缓存、日志、配置/密钥、DI 容器。——**一劳永逸**，A/B 两个功能都用它。

2. **Feature A ｜ AI 资源管理器（中文别名）MVP**

   - 先做**无 AI**版本：镜像树 + 忽略规则 + 缓存 + 词表/规则
   - 再接 **OpenAI**：批量翻译（限流/并发/重试）
   - 最后加**安全重命名（dry-run → 执行 → 回滚）**

3. **Feature B ｜ UML 世界画布（Webview）MVP**

   - 先做**本地 AST→IR→ 布局 → 渲染**（无 AI）
   - 再加 **AI 中文标注/摘要**（对 IR 结构做中文解释，不上传源码正文）

> 这样安排的好处：**见效快**（A 功能立刻可用），且把**复杂的 Webview/图布局**放到稳定地基之后做；同时 Core 一次接好，后面新增任意模块都能复用。

---

# 具体架构（同一个插件内，强模块化）

```
src/
  extension.ts                ← 轻入口（按需激活 + 路由）
  core/                       ← 共享地基（OpenAI/限流/缓存/日志/DI/配置）
    ai/OpenAIClient.ts
    ai/PromptProfiles.ts
    runtime/{TokenBucketLimiter, BackoffRetry}.ts
    cache/KVCache.ts
    logging/Logger.ts
    di/Container.ts
  features/
    explorer-alias/           ← 模块A（TreeView）
      domain/ports.ts         ← 接口：Translator/Cache/Rule/Glossary…
      app/usecases/*.ts       ← 用例：TranslateNode/Batch/Rename/CacheSync…
      infra/translators/*.ts  ← 实现：CompositeTranslator/RuleBased/OpenAIAdapter
      ui/AIExplorerProvider.ts← 只做展示与命令绑定
      module.json & README.md ← 元数据与搜索标签
    uml-canvas/               ← 模块B（Webview）
      domain/ir/*.ts          ← CodeGraph IR（类/接口/关系）
      app/usecases/*.ts       ← BuildGraph/Layout/AnnotateByAI
      infra/ast/*.ts          ← ts/ts-morph 解析
      infra/layout/*.ts       ← elkjs/dagre 布局
      panel/UmlCanvasPanel.ts ← 创建Webview & IPC
      webview/*               ← React+Canvas/Pixi，d3-zoom
      module.json & README.md
  shared/                     ← 轻工具/共通类型（无业务）
docs/
  MODULES.md                  ← 模块索引（给人/AI找入口）
.vscode/
  settings.json / launch.json / tasks.json
```

**分层要点：**

- **UI 只调用 UseCase**；UseCase 只依赖 **Ports 接口**；具体实现放 **infra**。
- **Core** 中的 OpenAI/限流/缓存是**唯一**对接点；各模块通过 **Adapter** 使用它（避免串改）。
- 每个模块自带 `module.json + README.md` + 文件头“模块标签”，方便**AI/人**精准定位。

---

# 从哪几步开始（一条龙清单）

## S0 ｜ Core 地基（1 天）

- `OpenAIClient`：fetch + 并发队列 + 令牌桶限流 + 超时 + 429/5xx 退避
- `TokenBucketLimiter`、`BackoffRetry`、`KVCache`、`Logger`
- `Container`（DI 容器）：读取配置和 SecretStorage，产出单例
- 命令 `aiSuite.setApiKey`（写 SecretStorage）

> 提示：先把 **PromptProfiles** 两类写好：`aliasProfile`（返回单行中文短名），`umlProfile`（对 IR 结构返回 JSON）。

## S1 ｜ Feature A 基线（1–2 天）

- **MVP 无 AI**：

  - 目录镜像（懒加载 + 忽略规则）
  - 缓存 + 词表/规则（命中 60–80%）
  - TreeItem：主/副标题切换（中文/原名）

- 批量翻译（接 Core.OpenAI）：并发/限流/退避/可取消
- 安全重命名：**dry-run → 冲突检测 → 执行 → 回滚**
- 文档化：`module.json`、`README.md`

## S2 ｜ Feature B 基线（2–4 天）

- Webview 基础（React + Canvas/Pixi + d3-zoom）
- AST→IR（先支持 JS/TS）：类/方法/属性/继承/实现/依赖
- 布局（elkjs/dagre）+ 基本渲染 + 搜索定位
- 右键菜单“在世界画布查看”
- 接 Core.OpenAI 做**中文标注**（仅 IR 摘要，非源码）+ 缓存
- 导出 PNG/SVG、Minimap、分层折叠（视时间迭代）

---

# 让 AI“搜得到对的模块”的关键做法

1. **多根工作区**：`.code-workspace` 把 `features/explorer-alias` 与 `features/uml-canvas` 设为**独立根**，日常在对应根里工作；全局搜索默认被“根”隔离。
2. **模块元数据**：每个模块 `module.json` 写 `moduleId/entry/searchTags`；`README.md` 顶部放“搜索标签/变更入口”。
3. **文件头标签**：每个文件第一行加入**路径注释 + 模块标签 + 搜索标签**（你习惯的样式）。
4. **路径别名**：TS `paths`：`@feat/explorer/*`、`@feat/uml/*`、`@core/*`，避免 `../../..` 让 AI 迷路。
5. **ESLint 边界**：禁止跨模块深层引用；必须走 `@core` 或 `@shared`。
6. **PR/Commit 规范**：消息前缀 `[explorer-alias] ...` / `[uml-canvas] ...`，AI 与人一眼识别范围。
7. **文档索引**：`docs/MODULES.md` 列“模块 → 关键词 → 入口 → 常改文件”。

---

# 关键接口/骨架（可直接粘贴）

```ts
// src/features/explorer-alias/domain/ports.ts
// [module: explorer-alias] [tags: Ports, Translator, Cache, Rules]
export type AliasSource = "dict" | "rule" | "ai" | "manual" | "unknown";
export interface AliasResult {
  alias: string;
  source: AliasSource;
  confidence: number;
}

export interface Translator {
  translateName(
    name: string,
    hints?: { kind?: "file" | "folder" }
  ): Promise<AliasResult>;
}
export interface CacheStore {
  get(path: string): AliasResult | undefined;
  set(path: string, v: AliasResult): void;
  move(oldPath: string, newPath: string): void;
  flush(): Promise<void>;
}
export interface Glossary {
  lookup(name: string): AliasResult | undefined;
}
export interface RuleEngine {
  apply(name: string): AliasResult | undefined;
}
```

```ts
// src/core/ai/OpenAIClient.ts
// [module: core] [tags: OpenAI, RateLimit, Retry, Timeout]
export class OpenAIClient {
  constructor(
    private opt: {
      baseUrl: string;
      timeoutMs: number;
      getApiKey: () => Promise<string>;
    },
    private logger: { info(s: string): void; warn(s: string): void },
    private limiter: { acquire(): Promise<void> },
    private maxConcurrency: number
  ) {}
  private active = 0;
  private q: Array<() => void> = [];
  async chat(model: string, messages: any) {
    return this.enqueue(async () => {
      await this.limiter.acquire();
      const ctl = new AbortController();
      const to = setTimeout(() => ctl.abort(), this.opt.timeoutMs);
      try {
        const res = await fetch(
          `${this.opt.baseUrl.replace(/\/+$/, "")}/chat/completions`,
          {
            method: "POST",
            signal: ctl.signal,
            headers: {
              Authorization: `Bearer ${await this.opt.getApiKey()}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ model, messages, temperature: 0.2 }),
          }
        );
        clearTimeout(to);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${await res.text()}`);
        return await res.json();
      } catch (e: any) {
        this.logger.warn(`[openai] ${e?.message ?? e}`);
        throw e;
      }
    });
  }
  private enqueue<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      const exec = async () => {
        this.active++;
        try {
          resolve(await task());
        } catch (e) {
          reject(e);
        } finally {
          this.active--;
          this.pump();
        }
      };
      this.q.push(exec);
      this.pump();
    });
  }
  private pump() {
    while (this.active < this.maxConcurrency && this.q.length)
      this.q.shift()!();
  }
}
```

```json
// src/features/uml-canvas/module.json
{
  "moduleId": "uml-canvas",
  "name": "UML 世界画布",
  "entry": ["panel/UmlCanvasPanel.ts", "app/usecases/buildGraph.ts"],
  "searchTags": ["UML", "Webview", "AST", "IR", "Layout", "Canvas"]
}
```

---

# “做得更好”的 12 条细化建议

1. **单一对接点**：所有 AI 调用只走 `core/ai/OpenAIClient`；模块里用 Adapter 包一层 Prompt。
2. **严格输出约束**：别名返回**单行文本**；UML 注解返回**JSON**（schema 校验，不合法就丢弃）。
3. **数据最小化**：UML 只上传 IR 摘要（符号名/关系），不上传源码正文。
4. **缓存键设计**：`<moduleId>:<sig or path>:<profile>:<model>`；cache 命中率直线上升。
5. **限流与可取消**：批量任务要支持 `CancellationToken`，UI 操作流畅。
6. **大仓库策略**：先翻译**可见节点**与**热门目录**；后台批量可暂停。
7. **重命名安全**：干跑 → 冲突/危险字符检查 → 分支执行 → 回滚日志。
8. **AST 先行**：UML 的结构来自本地 AST，AI 只“润色中文”，保证可控与正确性。
9. **模块边界**：UI 不写业务；UseCase 不关心具体 API；Infra 不走 UI。
10. **多根工作区 + ESLint 边界**：让 AI/人“搜不到”不相关大模块。
11. **文档即导航**：每个模块 README 顶部写“入口/常改清单/禁区”；`docs/MODULES.md` 总索引。
12. **提交与 PR 纪律**：前缀 + 标签 + 影响范围；CI 对跨模块深引用直接报错。

---

需要的话，我可以直接把**起步模板仓**（包含以上目录、配置与骨架代码）一次性给你，拷进去开写就行。
