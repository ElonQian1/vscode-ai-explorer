可以的！你可以为**单个文件**加一个专用命令（右键菜单 & 工具栏），只触发这一个文件的翻译，不递归目录。下面给你**可直接复制**的改动：`package.json` 菜单声明 → `index.ts` 注册命令 → `AIExplorerProvider.ts` 实现逻辑（同时兼容你在 VS Code 原生“资源管理器”里的右键）。

---

## 1) package.json：增加命令 + 菜单（AI Explorer 视图 & VS Code 原生资源管理器）

```json
// package.json（新增片段）
{
  "contributes": {
    "commands": [
      {
        "command": "aiExplorer.translateThisFile",
        "title": "AI 资源管理器：翻译此文件（仅此文件）"
      }
    ],
    "menus": {
      "view/item/context": [
        {
          "when": "view == aiExplorer && (viewItem == file || viewItem == fileHasAlias)",
          "command": "aiExplorer.translateThisFile",
          "group": "navigation@15"
        }
      ],
      "explorer/context": [
        {
          "when": "resourceScheme == file",
          "command": "aiExplorer.translateThisFile",
          "group": "navigation@915"
        }
      ]
    }
  },
  "activationEvents": [
    "onCommand:aiExplorer.translateThisFile",
    "onView:aiExplorer"
  ]
}
```

> 说明：
>
> - `view/item/context` 让**你的 AI Explorer 视图**中的文件节点出现“翻译此文件”。
> - `explorer/context` 让**VS Code 原生资源管理器**右键也有这个命令（会把 `Uri` 传给命令）。

---

## 2) 功能注册：index.ts 调用 Provider 的单文件翻译函数

```ts
// src/features/explorer-alias/index.ts
// [文件名: src/features/explorer-alias/index.ts]
/**
 * 注册“翻译此文件”命令（仅处理单个文件，不递归）
 */
import * as vscode from "vscode";
import { AIExplorerProvider } from "./ui/AIExplorerProvider";
// ……（略）你的依赖装配

export function registerExplorerAlias(context: vscode.ExtensionContext) {
  // ……（略）你的依赖：cache/glossary/rules/learned/providers 等
  const provider = new AIExplorerProvider({
    cache,
    translateNode,
    translateBatch,
    showAlias,
  });

  // 视图
  context.subscriptions.push(
    vscode.window.createTreeView("aiExplorer", {
      treeDataProvider: provider,
      showCollapseAll: true,
    })
  );

  // 其它命令（略）……
  context.subscriptions.push(
    vscode.commands.registerCommand(
      "aiExplorer.translateThisFile",
      async (arg?: any) => {
        // 兼容两种来源：AI Explorer 的节点 & 原生资源管理器传入的 Uri
        await provider.translateThisFile(arg);
      }
    )
  );

  return provider;
}
```

---

## 3) Provider：实现“仅此文件”翻译（自动识别传入参数类型）

```ts
// src/features/explorer-alias/ui/AIExplorerProvider.ts
// [文件名: src/features/explorer-alias/ui/AIExplorerProvider.ts]
/**
 * 在 Provider 里新增 translateThisFile()：
 * - 兼容 AI Explorer 节点 / 原生命令传入的 Uri / 活动编辑器文件
 * - 只翻译单个文件（词表→学习词典→规则→AI→缓存）
 * - 翻译成功后刷新树并 toast 提示
 */
import * as vscode from "vscode";
import * as path from "path";
// ……（略）已有 import

type AINode = { uri: vscode.Uri; kind: "file" | "folder" };

export class AIExplorerProvider implements vscode.TreeDataProvider<AINode> {
  // ……（略）已有代码

  // === 新增：仅此文件翻译 ===
  async translateThisFile(
    input?:
      | AINode
      | vscode.Uri
      | { resourceUri?: vscode.Uri }
      | { path?: string }
  ) {
    const uri = await this.resolveToFileUri(input);
    if (!uri) {
      vscode.window.showWarningMessage("请选择一个文件执行“翻译此文件”。");
      return;
    }
    // 只处理“文件”
    const stat = await vscode.workspace.fs.stat(uri).catch(() => undefined);
    if (!stat || stat.type !== vscode.FileType.File) {
      vscode.window.showWarningMessage(
        "当前选择的不是文件，无法执行“仅此文件”翻译。"
      );
      return;
    }

    const fsPath = uri.fsPath;
    const name = path.basename(fsPath);

    // 用例：只跑这个文件（不递归）
    const res = await this.deps.translateNode.exec(fsPath, name, "file");

    // 落盘（可选）并刷新
    await this.deps.cache.flushToDiskIfPossible?.();
    this.softRefresh();

    // 结果提示
    const srcMap: Record<string, string> = {
      dict: "词表",
      rule: "规则",
      ai: "AI",
      manual: "手动",
      unknown: "回退",
    };
    vscode.window.showInformationMessage(
      `已翻译：${name} → ${res.alias}（来源：${
        srcMap[res.source] ?? res.source
      }）`
    );
  }

  /** 解析来自不同入口的参数为文件 Uri */
  private async resolveToFileUri(input?: any): Promise<vscode.Uri | undefined> {
    if (!input) {
      // 没参数：用活动编辑器
      return vscode.window.activeTextEditor?.document?.uri;
    }
    if (input instanceof vscode.Uri) return input;
    if (typeof input === "string") return vscode.Uri.file(input);
    if (input.resourceUri instanceof vscode.Uri) return input.resourceUri;
    if (input.uri instanceof vscode.Uri) return input.uri;
    if (input.path && typeof input.path === "string")
      return vscode.Uri.file(input.path);
    // AI Explorer 的 AINode
    if (
      input &&
      input.uri instanceof vscode.Uri &&
      typeof input.kind === "string"
    )
      return input.uri;
    return undefined;
  }

  // ……（略）你已有的 getTreeItem/getChildren/translateNode/translateAll/renameToAlias 等
}
```

> 说明：
>
> - 这里**不递归**，只对文件调用一次 `TranslateNodeUseCase.exec()`；
> - 如果你已经接了 OpenAI/混元，那么链路会在“词表/学习词典/规则未命中”时自动走 AI，并把结果写入**路径缓存**与**学习词典**；
> - 弹窗里会告诉你“来源是词表/规则/AI/回退”，方便确认 AI 是否真的在工作。

---

## 4)（可选）让原生资源管理器右键也“看得见”你的命令

上面的 `explorer/context` 已经声明了菜单；**无需任何额外代码**，VS Code 会把所选文件的 `Uri` 作为参数传给命令。我们在 `translateThisFile()` 里已经处理了这种情况。

---

## 5) 常见问题排查

- 右键没出现命令？

  - 检查 `view == aiExplorer` 是否与你的视图 id 一致；
  - `TreeItem.contextValue` 是否设置为 `file`/`fileHasAlias`；
  - 改了 `package.json` 记得重启扩展开发宿主窗口（F5 起来的那个）。

- 执行后还是原名？

  - 可能词表/学习词典命中，或 AI 未正确配置（Key/baseUrl）。
  - 看“输出 → AI Suite”日志，或先跑我给你的“诊断/单次自测”命令确认连通性。

- 我想一键翻译“当前编辑器对应的文件”？

  - 直接从命令面板运行 **“AI 资源管理器：翻译此文件（仅此文件）”**，不选中也会拿**活动编辑器**的文件执行。

---

这样改完，你就能：

- 在 **AI Explorer 视图**里对某个文件右键 → “翻译此文件（仅此文件）”；
- 在 **VS Code 原生资源管理器**右键文件 → 同样有这个命令；
- 命令内部只针对该文件跑一遍“词表 → 学习词典 → 规则 →（可选）AI”，并刷新视图与缓存。
