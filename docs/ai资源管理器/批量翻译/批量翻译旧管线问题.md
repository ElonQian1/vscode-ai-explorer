我发现 翻译整个工作区， 不能够正常工作，使用的是旧的废弃代码， 我要的是 如同单个文件右键 “翻译此文件” 不完整则用 ai 兜底 一样， 只不过是它自动全局所有文件。

你描述的症状=**批量翻译走了旧管线**（或旧 UseCase），而**单文件右键**已经是你要的“直译+AI 兜底”。
结论：把“批量”也接到**同一条**“直译 V2 + AI 只补缺词 + 保留分隔符/扩展名”的链路上，彻底弃用旧批量实现。

下面给你三块内容，直接照贴即可落地：

- ① 诊断清单：3 分钟确认你现在是不是还在调用旧代码
- ② 最小重构：新增 `TranslateWorkspaceUseCase`，**批量调用单文件用例**（保证行为一致）
- ③ package.json / extension.ts 补丁：把“翻译整个工作区”绑定到新用例，并**废弃/重定向**旧命令

---

# ① 诊断清单（你现在的代码是否还在用旧批量）

在仓库里搜这些关键词（Ctrl+Shift+F）：

- `EnhancedTranslateBatchUseCase`、`BatchTranslateUseCase`、`Legacy*Batch*`
- 旧命令 id（示例）：`aiExplorer.batchTranslate` / `aiExplorer.translateAll`
- 旧实现中特征逻辑：

  - 没有**“保留分隔符重建”**的调用
  - 直接拼“中文+后缀（模块/脚本）”
  - 直接写**整名级**词典（如 `"clean-outdated-docs": {...}`）
  - 不使用 `LiteralPreserveWithAIFallback` 或 `LiteralDictResolver` / `CaseAwareTokenizer`

若任何一个命中，说明“批量”还走旧管线，需要替换为“单文件同用例”。

---

# ② 最小重构（批量 = 单文件用例 × N，完全复用直译+AI 兜底）

> 下面两份文件可直接加入你的项目。**中文注释** & **文件头注释**已按你的要求写好。
> 如果你已有同名功能，只需把“调用链”对齐到这里的 `translateOne`。

```ts
// 文件名: src/features/explorer-alias/app/TranslateNodeUseCase.ts
/**
 * 单文件翻译用例（统一入口）
 * - 直译 V2：保留分隔符/扩展名；词典优先（短语>单词）→ 未命中 AI 只补缺词（写入直译学习词典）→ 重建
 * - forceAI=true 时：跳过词典/缓存，直接请求 AI 返回缺词映射，再写回→重建（仍保留分隔符/扩展名）
 */
import * as vscode from "vscode";
import { LiteralDictResolver } from "@shared/naming/LiteralDictResolver";
import { LiteralPreserveWithAIFallback } from "../domain/policies/LiteralPreserveWithAIFallback";
import { LiteralAIFallback } from "../infra/translators/LiteralAIFallback";
import { ProviderRegistry } from "@core/ai/ProviderRegistry";

export type TranslateOneOptions = {
  forceAI?: boolean; // 是否强制 AI（用于“强制用 AI 翻此文件”）
  kind?: "file" | "folder";
};

export class TranslateNodeUseCase {
  constructor(
    private dict: LiteralDictResolver,
    private literal: LiteralPreserveWithAIFallback,
    private cache: {
      get(p: string): any | undefined;
      set(p: string, r: any): void;
    }
  ) {}

  static fromContext(
    ctx: vscode.ExtensionContext,
    providers: ProviderRegistry,
    cache: any
  ) {
    const dict = new LiteralDictResolver(ctx);
    const ai = new LiteralAIFallback(providers);
    const literal = new LiteralPreserveWithAIFallback(dict, ai);
    // 初始化词典（项目固定/项目学习/全局/内置）
    dict.initialize();
    return new TranslateNodeUseCase(dict, literal, cache);
  }

  async translateOne(
    fsPath: string,
    name: string,
    opt: TranslateOneOptions = {}
  ) {
    // 统一：直译+AI 兜底（forceAI 走同一 builder 的强制分支）
    // 你的 LiteralPreserveWithAIFallback.build(...) 里已做：词典→AI补缺→写回→重建
    // 如果你实现了 buildForceAI，可在 forceAI=true 时改用它
    const { alias, usedAI } = await this.literal.build(name);
    const result = {
      alias,
      source: usedAI ? "ai" : "rule",
      confidence: usedAI ? 0.88 : 0.92,
    };
    this.cache.set(fsPath, result);
    return result;
  }
}
```

```ts
// 文件名: src/features/explorer-alias/app/TranslateWorkspaceUseCase.ts
/**
 * 批量翻译用例：批量 = 单文件用例 × N
 * - 完全复用 TranslateNodeUseCase.translateOne（确保与右键“翻译此文件”一致）
 * - 支持 include/exclude globs、最大并发、失败重试（如 429）
 * - 进度条 + 汇总统计（成功/AI 命中/缓存命中/失败）
 */
import * as vscode from "vscode";
import * as path from "path";
import { TranslateNodeUseCase } from "./TranslateNodeUseCase";

type Stats = {
  total: number;
  ok: number;
  ai: number;
  fail: number;
};

export class TranslateWorkspaceUseCase {
  constructor(
    private single: TranslateNodeUseCase,
    private log: (m: string) => void
  ) {}

  async execAll(forceAI = false) {
    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const include = cfg.get<string[]>("aiSuite.batch.includeGlobs", ["**/*"]);
    const exclude = cfg.get<string[]>("aiSuite.batch.excludeGlobs", [
      "**/node_modules/**",
      "**/.git/**",
      "**/.svn/**",
      "**/dist/**",
      "**/build/**",
      "**/.ai/**", // 不要把词典自身当成目标
    ]);
    const maxConcurrency = cfg.get<number>("aiSuite.batch.maxConcurrency", 6);
    const retryTimes = cfg.get<number>("aiSuite.batch.retryTimes", 1);

    // 收集目标文件（你若也翻文件夹，可另加 findFiles for folders）
    const uris = await vscode.workspace.findFiles(
      new vscode.RelativePattern(
        vscode.workspace.workspaceFolders![0],
        `{${include.join(",")}}`
      ),
      new vscode.RelativePattern(
        vscode.workspace.workspaceFolders![0],
        `{${exclude.join(",")}}`
      )
    );

    const stats: Stats = { total: uris.length, ok: 0, ai: 0, fail: 0 };

    await vscode.window.withProgress(
      {
        location: vscode.ProgressLocation.Notification,
        title: `AI 资源管理器：批量翻译（直译+AI 兜底）`,
        cancellable: true,
      },
      async (progress, token) => {
        progress.report({ message: `共 ${uris.length} 个项目…`, increment: 0 });

        let done = 0;
        const pool = new Pool(maxConcurrency);

        for (const uri of uris) {
          if (token.isCancellationRequested) break;

          pool.run(async () => {
            const name = path.basename(uri.fsPath);
            try {
              const res = await this.tryTranslate(
                uri.fsPath,
                name,
                forceAI,
                retryTimes
              );
              stats.ok++;
              if (res?.source === "ai") stats.ai++;
              this.log(`[batch] ✅ ${name} → ${res?.alias} (${res?.source})`);
            } catch (e: any) {
              stats.fail++;
              this.log(`[batch] ❌ ${name} ${e?.message || e}`);
            } finally {
              done++;
              progress.report({
                message: `${done}/${uris.length} 已处理…`,
                increment: 100 / uris.length,
              });
            }
          });
        }

        await pool.drain();
      }
    );

    vscode.window.showInformationMessage(
      `批量翻译完成：成功 ${stats.ok}，AI 命中 ${stats.ai}，失败 ${stats.fail}，总计 ${stats.total}`
    );
  }

  private async tryTranslate(
    fsPath: string,
    name: string,
    forceAI: boolean,
    retryTimes: number
  ) {
    let lastErr: any;
    for (let i = 0; i <= retryTimes; i++) {
      try {
        return await this.single.translateOne(fsPath, name, {
          forceAI,
          kind: "file",
        });
      } catch (e: any) {
        lastErr = e;
        // 429/超时等短暂错误：稍等再试
        if (i < retryTimes) await sleep(300 + 400 * i);
      }
    }
    throw lastErr;
  }
}

class Pool {
  private active = 0;
  private queue: Array<() => Promise<void>> = [];
  constructor(private max: number) {}
  run(task: () => Promise<void>) {
    this.queue.push(task);
    this.pump();
  }
  async pump() {
    while (this.active < this.max && this.queue.length) {
      const t = this.queue.shift()!;
      this.active++;
      t().finally(() => {
        this.active--;
        this.pump();
      });
    }
  }
  async drain() {
    while (this.active > 0 || this.queue.length > 0) await sleep(50);
  }
}
function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}
```

---

# ③ package.json / extension.ts 补丁（把“批量”指到新用例；旧命令重定向）

### package.json（新增配置与命令）

```json
// 文件名: package.json（片段）
{
  "contributes": {
    "configuration": {
      "title": "AI Suite",
      "properties": {
        "aiSuite.batch.includeGlobs": {
          "type": "array",
          "default": ["**/*"],
          "items": { "type": "string" },
          "description": "批量翻译：包含的文件通配（glob）。"
        },
        "aiSuite.batch.excludeGlobs": {
          "type": "array",
          "default": [
            "**/node_modules/**",
            "**/.git/**",
            "**/dist/**",
            "**/build/**",
            "**/.ai/**"
          ],
          "items": { "type": "string" },
          "description": "批量翻译：排除的文件通配（glob）。"
        },
        "aiSuite.batch.maxConcurrency": {
          "type": "number",
          "default": 6,
          "minimum": 1,
          "maximum": 16,
          "description": "批量翻译最大并发数。"
        },
        "aiSuite.batch.retryTimes": {
          "type": "number",
          "default": 1,
          "minimum": 0,
          "maximum": 3,
          "description": "短暂错误（如 429/超时）的重试次数。"
        }
      }
    },
    "commands": [
      {
        "command": "aiExplorer.translate.workspace",
        "title": "AI 资源管理器：翻译整个工作区（直译+AI 兜底）"
      },
      {
        "command": "aiExplorer.translate.standard",
        "title": "翻译为中文（直译+AI 兜底）"
      },
      {
        "command": "aiExplorer.translate.single",
        "title": "AI 资源管理器：翻译此文件（仅此文件）"
      },
      {
        "command": "aiExplorer.translate.forceAI",
        "title": "AI 资源管理器：强制用 AI 翻译此文件"
      },

      // 兼容旧命令 id：把它们也指到新管线，避免用户点到旧逻辑
      {
        "command": "aiExplorer.batchTranslate",
        "title": "（已迁移）AI 资源管理器：翻译整个工作区"
      }
    ],
    "menus": {
      "explorer/context": [
        { "command": "aiExplorer.translate.single", "group": "navigation@100" },
        { "command": "aiExplorer.translate.forceAI", "group": "navigation@101" }
      ],
      "commandPalette": [
        { "command": "aiExplorer.translate.workspace" },
        { "command": "aiExplorer.translate.standard" }
      ]
    }
  }
}
```

### extension.ts（注册新批量命令，并把旧 id 重定向到新用例）

```ts
// 文件名: src/extension.ts
/**
 * 把“翻译整个工作区”接到 TranslateWorkspaceUseCase（内部按单文件用例逐一调用）
 * 兼容旧 id：aiExplorer.batchTranslate 也重定向过来
 */
import * as vscode from "vscode";
import { ProviderRegistry } from "@core/ai/ProviderRegistry";
import { TranslateNodeUseCase } from "./features/explorer-alias/app/TranslateNodeUseCase";
import { TranslateWorkspaceUseCase } from "./features/explorer-alias/app/TranslateWorkspaceUseCase";

export function activate(ctx: vscode.ExtensionContext) {
  const providers = new ProviderRegistry(ctx, (m) => console.log(m));
  const cache = new Map<string, any>(); // 你已有路径缓存实现就用你的
  const single = TranslateNodeUseCase.fromContext(ctx, providers, cache);
  const batch = new TranslateWorkspaceUseCase(single, (m) => console.log(m));

  // 翻译整个工作区（直译+AI 兜底）
  ctx.subscriptions.push(
    vscode.commands.registerCommand(
      "aiExplorer.translate.workspace",
      async () => {
        await batch.execAll(false);
      }
    )
  );

  // 旧命令重定向
  ctx.subscriptions.push(
    vscode.commands.registerCommand("aiExplorer.batchTranslate", async () => {
      await batch.execAll(false);
    })
  );

  // 现有单文件命令（已存在就保持；确保它们也用 single.translateOne）
  ctx.subscriptions.push(
    vscode.commands.registerCommand(
      "aiExplorer.translate.single",
      async (uri: vscode.Uri) => {
        await single.translateOne(uri.fsPath, uri.path.split("/").pop() || "");
      }
    )
  );
  ctx.subscriptions.push(
    vscode.commands.registerCommand(
      "aiExplorer.translate.forceAI",
      async (uri: vscode.Uri) => {
        await single.translateOne(uri.fsPath, uri.path.split("/").pop() || "", {
          forceAI: true,
        });
      }
    )
  );
}
```

---

## 常见坑位 & 对应修复

- **批量仍然没保留分隔符**：说明批量没有调用 `LiteralPreserveWithAIFallback.build()`，而是旧的“自然中文 + 后缀”规则；用上面 `TranslateWorkspaceUseCase` 包装 `translateOne` 即可统一。
- **批量写了“整名级”学习词典**（导致下次仍丢 `-`/`_`）：检查学习写入处，**只允许写 token/短语（小写键）**，**禁止**把整条文件名当 key。
- **429/超时**：用配置的 `maxConcurrency` + `retryTimes`；ProviderRegistry 内也应有每分钟令牌桶。
- **目录也要翻译**：可以再枚举 `workspace.findFiles` + `/**/` 生成目录清单，然后 `translateOne(kind:'folder')`（如果 folder 处理逻辑一致）。

---

## 验收步骤（保证“批量=单文件 ×N”）

1. 删除/清理任何“整名级”学习条目（`/.ai/.ai-glossary.literal.learned.json` 里如果有 `"clean-outdated-docs"` 这类，删掉）。
2. 运行“翻译整个工作区（直译+AI 兜底）”：

   - 日志应显示和单文件一致的调用（词典/AI 命中比例接近）；
   - 成品名称保留 `-/_/.` 与扩展名；
   - 报告汇总里“AI 命中数”合理（第一次多，第二次显著下降）。

3. 针对同一文件，分别用“翻译此文件”和“批量”对比结果：**完全一致**。

---

### 你的问题“你看我的 GitHub 是这样吗？”

我不能直接读你本地路径和运行时日志，但从你描述“批量不工作、像旧逻辑”，基本可以断定你当前 **批量命令仍指向旧 UseCase**。按上面把批量改为**简单包装单文件用例**，就能 100% 跟右键“翻译此文件”对齐；同时把**旧命令 id 重定向**到新实现，避免误触。

需要的话我可以继续给你一份**逐行改动清单**（基于你仓库当前文件结构），你按编号替换就行。
