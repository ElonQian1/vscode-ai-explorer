当然可以把“不同项目”的翻译记录（别名）**分层缓存**，既保证**每个项目互不污染**，又能**跨项目复用通用术语**。下面给你一套可直接落地的做法 + 代码骨架（含中文注释 & 文件头注释）。

---

# 总体思路（分三层，命中顺序）

1. **项目固定词表（可选，进 Git）**

   - 文件：`<repo>/.ai-glossary.json`（手工维护/提级用）
   - 优先级最高，适合团队约定术语（稳定不变）

2. **项目学习词典（自动沉淀，进 Git 或不进均可）**

   - 文件：`<repo>/.ai/.ai-glossary.learned.json`（建议放 `.ai/` 目录）
   - AI 结果写入这里，下次同名**不再请求 API**

3. **全局用户词典（跨项目复用，不进 Git）**

   - 位置：`context.globalStorageUri/glossary.json`（VS Code 为扩展分配的用户目录）
   - 适合“到处都通用”的名字：`utils→工具`,`components→组件` …

> **展示/决策优先级**：项目固定词表 → 项目学习词典 → 全局用户词典 → 规则引擎 →（可选）AI → 回退原名。

---

# 路径级缓存（Path Cache）与“键”设计

- **目的**：给每个具体文件/文件夹保存它当前的别名，刷新视图超快。

- **存放**：`workspaceState` + 可选落盘 `<repo>/.ai/.ai-name-cache.json`

- **键**：`<workspaceFolderId>/<relativePath>`

  - `workspaceFolderId` = 对工作区根路径做哈希（或 Git remote URL 哈希），避免同名仓互串
  - `relativePath` = 相对该根目录的路径（跨设备稳定，避免绝对盘符差异）

- **失效条件**：

  - **重命名/移动**：在 `onDidRenameFiles` 里做 `move/movePrefix` 迁移；
  - **提示词或模型变更**：缓存里记录 `profileVersion/model/provider`，不匹配时只针对**当前节点**重算；
  - **清理命令**：提供“清理当前项目缓存”命令，仅清理本项目的 path cache，不动词典。

---

# 多根工作区 & 团队协作

- **多根**：每个 `workspaceFolder` 各自一套 `.ai/…` 文件和 `workspaceFolderId`；
- **团队共享**：建议把 **项目固定词表**（`/.ai-glossary.json`）和**项目学习词典**（`/.ai/.ai-glossary.learned.json`）都进 Git；
- **私密**：全局用户词典存 `globalStorageUri`，**不入库**。

---

# JSON Schema（建议）

```json
// .ai/.ai-glossary.learned.json（项目学习词典）
{
  "$schema": "https://example.com/ai/glossary.schema.json",
  "version": 1,
  "locale": "zh-CN",
  "terms": {
    "readme": {
      "alias": "自述",
      "source": "ai",
      "at": "2025-10-14T03:00:00Z",
      "model": "gpt-4o-mini",
      "profile": "alias@1"
    },
    "components": {
      "alias": "组件",
      "source": "ai",
      "at": "2025-10-14T03:00:00Z",
      "model": "hunyuan-lite",
      "profile": "alias@1"
    }
  }
}
```

---

# 代码骨架（直接粘贴即可用）

## 1) 全局用户词典（跨项目）

```ts
// src/core/glossary/GlobalGlossaryStore.ts
// [module: core] [tags: glossary, global, storage]
import * as vscode from "vscode";

type Term = {
  alias: string;
  source: "user" | "ai";
  at: string;
  model?: string;
  profile?: string;
};
export class GlobalGlossaryStore {
  private map = new Map<string, Term>();
  private loaded = false;
  private fileName = "glossary.json"; // 存在 globalStorageUri 下

  constructor(private ctx: vscode.ExtensionContext) {}

  private norm(name: string) {
    return name.replace(/\.[^.]+$/, "").toLowerCase();
  }

  private async ensureLoad() {
    if (this.loaded) return;
    const uri = vscode.Uri.joinPath(this.ctx.globalStorageUri, this.fileName);
    try {
      await vscode.workspace.fs.createDirectory(this.ctx.globalStorageUri);
      const buf = await vscode.workspace.fs.readFile(uri);
      const json = JSON.parse(Buffer.from(buf).toString("utf8")) as Record<
        string,
        Term
      >;
      for (const [k, v] of Object.entries(json)) this.map.set(k, v);
    } catch {
      /* 文件可能不存在 */
    }
    this.loaded = true;
  }

  async get(name: string): Promise<Term | undefined> {
    await this.ensureLoad();
    return this.map.get(this.norm(name));
  }

  async set(name: string, term: Term) {
    await this.ensureLoad();
    this.map.set(this.norm(name), term);
    const uri = vscode.Uri.joinPath(this.ctx.globalStorageUri, this.fileName);
    const json = Object.fromEntries(this.map);
    await vscode.workspace.fs.writeFile(
      uri,
      Buffer.from(JSON.stringify(json, null, 2), "utf8")
    );
  }
}
```

## 2) 项目学习词典（进仓库 `.ai/`）

```ts
// src/features/explorer-alias/infra/cache/ProjectGlossaryStore.ts
// [module: explorer-alias] [tags: glossary, project, learned]
import * as vscode from "vscode";
import * as path from "path";
type Term = {
  alias: string;
  source: "ai" | "user";
  at: string;
  model?: string;
  profile?: string;
};

export class ProjectGlossaryStore {
  private map = new Map<string, Term>();
  private loaded = false;

  constructor(private fileRel = ".ai/.ai-glossary.learned.json") {}

  private norm(name: string) {
    return name.replace(/\.[^.]+$/, "").toLowerCase();
  }

  private projectRoot() {
    return vscode.workspace.workspaceFolders?.[0]?.uri;
  }

  private async ensureLoad() {
    if (this.loaded) return;
    const root = this.projectRoot();
    if (!root) return;
    const uri = vscode.Uri.joinPath(root, this.fileRel);
    try {
      const buf = await vscode.workspace.fs.readFile(uri);
      const json = JSON.parse(Buffer.from(buf).toString("utf8")) as
        | { terms?: Record<string, Term> }
        | Record<string, Term>;
      const terms = (json as any).terms ?? json;
      for (const [k, v] of Object.entries(terms)) this.map.set(k, v as Term);
    } catch {
      /* 文件可能不存在 */
    }
    this.loaded = true;
  }

  async get(name: string) {
    await this.ensureLoad();
    return this.map.get(this.norm(name));
  }

  async set(name: string, term: Term) {
    await this.ensureLoad();
    this.map.set(this.norm(name), term);
    const root = this.projectRoot();
    if (!root) return;
    const uri = vscode.Uri.joinPath(root, this.fileRel);
    // 确保目录存在
    const dir = vscode.Uri.joinPath(root, path.dirname(this.fileRel));
    await vscode.workspace.fs.createDirectory(dir);
    const json = {
      version: 1,
      locale: "zh-CN",
      terms: Object.fromEntries(this.map),
    };
    await vscode.workspace.fs.writeFile(
      uri,
      Buffer.from(JSON.stringify(json, null, 2), "utf8")
    );
  }
}
```

## 3) 路径级缓存（相对路径 + 项目标识）

```ts
// src/features/explorer-alias/infra/cache/ProjectPathCache.ts
// [module: explorer-alias] [tags: cache, path, workspaceState]
import * as vscode from "vscode";
import * as path from "path";
import { createHash } from "crypto";

export type AliasRecord = {
  alias: string;
  source: "dict" | "rule" | "ai" | "user" | "unknown";
  confidence: number;
  provider?: "openai" | "hunyuan";
  model?: string;
  profile?: string;
  at?: string;
};

export class ProjectPathCache {
  private key = "aiSuite.explorerAlias.cache.v2";
  private map = new Map<string, AliasRecord>();

  constructor(private ctx: vscode.ExtensionContext) {
    const obj = this.ctx.workspaceState.get<Record<string, AliasRecord>>(
      this.key,
      {}
    );
    for (const [k, v] of Object.entries(obj)) this.map.set(k, v);
  }

  private folderId(folder: vscode.WorkspaceFolder) {
    // 稳定 ID：对根路径做 sha1（你也可以用 Git remote URL）
    return createHash("sha1")
      .update(folder.uri.fsPath)
      .digest("hex")
      .slice(0, 8);
  }

  private keyOf(fsPath: string) {
    const folder = vscode.workspace.getWorkspaceFolder(vscode.Uri.file(fsPath));
    if (!folder) return undefined;
    const rel = path.relative(folder.uri.fsPath, fsPath);
    return `${this.folderId(folder)}/${rel.replace(/\\/g, "/")}`;
    // 例： ab12cd34/src/utils/index.ts
  }

  get(fsPath: string) {
    const k = this.keyOf(fsPath);
    return k ? this.map.get(k) : undefined;
  }

  set(fsPath: string, rec: AliasRecord) {
    const k = this.keyOf(fsPath);
    if (!k) return;
    this.map.set(k, rec);
    this.persist();
  }

  move(oldPath: string, newPath: string) {
    const ok = this.keyOf(oldPath),
      nk = this.keyOf(newPath);
    if (ok && nk && this.map.has(ok)) {
      this.map.set(nk, this.map.get(ok)!);
      this.map.delete(ok);
      this.persist();
    }
  }

  movePrefix(oldDir: string, newDir: string) {
    const folder = vscode.workspace.getWorkspaceFolder(vscode.Uri.file(newDir));
    if (!folder) return;
    const fid = this.folderId(folder);
    const oldK = this.keyOf(oldDir);
    if (!oldK) return;
    const oldRel = oldK.split("/").slice(1).join("/");
    const updates: Array<{ from: string; to: string; v: AliasRecord }> = [];
    for (const [k, v] of this.map.entries()) {
      const rel = k.split("/").slice(1).join("/");
      if (rel.startsWith(oldRel)) {
        const newRel = rel.replace(
          oldRel,
          path.relative(folder.uri.fsPath, newDir).replace(/\\/g, "/")
        );
        updates.push({ from: k, to: `${fid}/${newRel}`, v });
      }
    }
    for (const u of updates) this.map.delete(u.from);
    for (const u of updates) this.map.set(u.to, u.v);
    if (updates.length) this.persist();
  }

  removeOrRemovePrefix(fsPath: string) {
    const k = this.keyOf(fsPath);
    if (!k) return;
    const rel = k.split("/").slice(1).join("/");
    let touched = false;
    for (const x of Array.from(this.map.keys())) {
      const xr = x.split("/").slice(1).join("/");
      if (xr === rel || xr.startsWith(rel + "/")) {
        this.map.delete(x);
        touched = true;
      }
    }
    if (touched) this.persist();
  }

  private persist() {
    this.ctx.workspaceState.update(
      this.key,
      Object.fromEntries(this.map.entries())
    );
  }
}
```

## 4) 用例里按“分层词典 + 路径缓存”查找顺序

```ts
// src/features/explorer-alias/app/TranslateNodeUseCase.ts
// [module: explorer-alias] [tags: usecase, order, cache]
import { ProjectPathCache, AliasRecord } from "../infra/cache/ProjectPathCache";
import { ProjectGlossaryStore } from "../infra/cache/ProjectGlossaryStore";
import { GlobalGlossaryStore } from "@core/glossary/GlobalGlossaryStore";

export class TranslateNodeUseCase {
  constructor(
    private dictFixed: { lookup(n: string): AliasRecord | undefined }, // 项目固定词表（或代码内置）
    private projLearned: ProjectGlossaryStore,
    private globalDict: GlobalGlossaryStore,
    private rules: {
      apply(n: string, k: "file" | "folder"): AliasRecord | undefined;
    },
    private cache: ProjectPathCache,
    private ai?: {
      translateAliasBatch(names: string[]): Promise<Record<string, string>>;
    },
    private profileVersion = "alias@1"
  ) {}

  async exec(
    fsPath: string,
    name: string,
    kind: "file" | "folder"
  ): Promise<AliasRecord> {
    // 1) 路径缓存
    const c = this.cache.get(fsPath);
    if (c) return c;

    // 2) 项目固定词表（或代码内置）
    const f = this.dictFixed.lookup(name);
    if (f) {
      this.cache.set(fsPath, f);
      return f;
    }

    // 3) 项目学习词典
    const pl = await this.projLearned.get(name);
    if (pl) {
      const r: AliasRecord = {
        alias: pl.alias,
        source: "ai",
        confidence: 0.9,
        model: pl.model,
        profile: this.profileVersion,
        at: pl.at,
      };
      this.cache.set(fsPath, r);
      return r;
    }

    // 4) 全局用户词典
    const gl = await this.globalDict.get(name);
    if (gl) {
      const r: AliasRecord = {
        alias: gl.alias,
        source: gl.source,
        confidence: 0.85,
        model: gl.model,
        profile: gl.profile,
        at: gl.at,
      };
      this.cache.set(fsPath, r);
      return r;
    }

    // 5) 规则
    const rr = this.rules.apply(name, kind);
    if (rr) {
      this.cache.set(fsPath, rr);
      return rr;
    }

    // 6) AI（可选）
    if (this.ai) {
      try {
        const map = await this.ai.translateAliasBatch([name]);
        const alias = (map[name] || "").trim();
        if (alias) {
          const now = new Date().toISOString();
          await this.projLearned.set(name, {
            alias,
            source: "ai",
            at: now,
            model: "auto",
            profile: this.profileVersion,
          });
          const ar: AliasRecord = {
            alias,
            source: "ai",
            confidence: 0.9,
            model: "auto",
            profile: this.profileVersion,
            at: now,
          };
          this.cache.set(fsPath, ar);
          return ar;
        }
      } catch {
        /* 忽略网络错误 */
      }
    }

    // 7) 回退
    const fb: AliasRecord = { alias: name, source: "unknown", confidence: 0.5 };
    this.cache.set(fsPath, fb);
    return fb;
  }
}
```

---

# 使用建议（实践细节）

- **命名与目录**：统一把项目文件放在 `/.ai/` 下（`learned.json`、`name-cache.json`），减少仓根杂乱；
- **PR 提升流程**：提供命令“将学习词条提级到项目固定词表”，把 `.ai/.ai-glossary.learned.json` 中确认过的条目写入 `/.ai-glossary.json`；
- **版本与兼容**：`profileVersion`（如 `alias@1`）一旦改变，可对**未命中的节点**逐步重算，不需要全量失效；
- **多语言**：若未来支持日/韩等，可把键扩展为 `norm(name)+':'+locale`；
- **性能**：写磁盘做**节流**（debounce 300–800ms），大仓库避免频繁 IO。

---

这样设计后：

- **项目 A/B 各自独立**：用自己的 `workspaceFolderId` + 相对路径键，互不影响；
- **通用短名复用**：全局用户词典自动命中，少打 API；
- **团队共享可控**：项目学习/固定词表都能进 Git；
- **移动/重命名稳**：`move/movePrefix` 迁移键，几乎不需要重算。

要我把这些类按你仓库的实际路径发一份“**补丁清单（改哪些文件、插哪几行）**”吗？
