没问题！你这个目标可以拆成 3 个独立但可拼装的模块：

1. **API Key & Provider 切换**（OpenAI / 腾讯混元都走“OpenAI 兼容协议”）
2. **字典模块**（内置词表 + 学习型词典）
3. **翻译模块**（链路：词表 → 学习词典 → 规则 → AI → 回写）

下面给你**一步到位的落地步骤 + 可直接粘贴的代码**（都含中文注释，且每个文件首行都有文件路径注释）。按顺序落下去，你就能立刻在现有的 Feature A 上：

- 支持**设置/切换** OpenAI 与腾讯混元的 API Key；
- 自动把 AI 的结果**写入学习型词典**（避免重复请求）；
- 翻译时先命中词表/学习词典，**最大化缓存命中率**。

---

# 0. package.json：补充配置与命令（一次到位）

```json
// package.json（片段：配置 & 命令）
{
  "contributes": {
    "commands": [
      {
        "command": "aiSuite.setOpenAIKey",
        "title": "AI Suite：设置 OpenAI API Key"
      },
      {
        "command": "aiSuite.setHunyuanKey",
        "title": "AI Suite：设置腾讯混元 API Key"
      },
      {
        "command": "aiSuite.chooseProvider",
        "title": "AI Suite：选择主用模型提供方"
      }
    ],
    "configuration": {
      "title": "AI Suite",
      "properties": {
        "aiSuite.provider.primary": {
          "type": "string",
          "enum": ["openai", "hunyuan"],
          "default": "openai",
          "description": "主用模型提供方"
        },
        "aiSuite.provider.fallback": {
          "type": "string",
          "enum": ["none", "openai", "hunyuan"],
          "default": "hunyuan",
          "description": "主用失败时的回退提供方"
        },

        "aiSuite.openai.baseUrl": {
          "type": "string",
          "default": "https://api.openai.com/v1"
        },
        "aiSuite.openai.model": { "type": "string", "default": "gpt-4o-mini" },
        "aiSuite.openai.timeoutMs": { "type": "number", "default": 10000 },

        "aiSuite.hunyuan.baseUrl": {
          "type": "string",
          "default": "https://api.hunyuan.cloud.tencent.com/v1"
        },
        "aiSuite.hunyuan.model": {
          "type": "string",
          "default": "hunyuan-lite"
        },
        "aiSuite.hunyuan.timeoutMs": { "type": "number", "default": 10000 },

        "aiSuite.maxConcurrency": {
          "type": "number",
          "default": 3,
          "minimum": 1,
          "maximum": 10
        },
        "aiSuite.maxRPM": {
          "type": "number",
          "default": 60,
          "minimum": 10,
          "maximum": 600
        },

        "aiSuite.cacheFile": {
          "type": "string",
          "default": ".ai-name-cache.json"
        }
      }
    }
  }
}
```

> 如果你使用了 `@core/*` 这类别名，请确保构建脚本用 `tsc-alias` 重写：
> `"build": "tsc -p . && tsc-alias -p tsconfig.json"`

---

# 1. extension.ts：注册设置 Key / 切换 Provider 的命令

```ts
// src/extension.ts
// src/extension.ts
/**
 * 插件入口：新增 3 个命令（设置 Key、选择 Provider），其余保持你现有代码不变。
 */
import * as vscode from "vscode";
import { registerExplorerAlias } from "./features/explorer-alias";

export async function activate(context: vscode.ExtensionContext) {
  // 设置 OpenAI Key
  context.subscriptions.push(
    vscode.commands.registerCommand("aiSuite.setOpenAIKey", async () => {
      const v = await vscode.window.showInputBox({
        title: "输入 OpenAI API Key",
        password: true,
        ignoreFocusOut: true,
      });
      if (v) {
        await context.secrets.store("aiSuite.key.openai", v);
        vscode.window.showInformationMessage("OpenAI Key 已保存");
      }
    })
  );

  // 设置腾讯混元 Key
  context.subscriptions.push(
    vscode.commands.registerCommand("aiSuite.setHunyuanKey", async () => {
      const v = await vscode.window.showInputBox({
        title: "输入腾讯混元 API Key",
        password: true,
        ignoreFocusOut: true,
      });
      if (v) {
        await context.secrets.store("aiSuite.key.hunyuan", v);
        vscode.window.showInformationMessage("混元 Key 已保存");
      }
    })
  );

  // 选择主用 Provider
  context.subscriptions.push(
    vscode.commands.registerCommand("aiSuite.chooseProvider", async () => {
      const pick = await vscode.window.showQuickPick(
        [
          { label: "OpenAI", value: "openai" },
          { label: "腾讯混元", value: "hunyuan" },
        ],
        { title: "选择主用模型提供方" }
      );
      if (pick) {
        await vscode.workspace
          .getConfiguration("aiSuite")
          .update(
            "aiSuite.provider.primary",
            pick.value,
            vscode.ConfigurationTarget.Global
          );
        vscode.window.showInformationMessage(`已选择主用提供方：${pick.label}`);
      }
    })
  );

  // 你已有的 Feature A 视图注册
  const provider = registerExplorerAlias(context);

  // 文件系统监听（保持你的实现）
  const watcher = vscode.workspace.createFileSystemWatcher("**/*");
  watcher.onDidCreate(() => provider.refresh());
  watcher.onDidDelete(() => provider.refresh());
  watcher.onDidChange(() => provider.softRefresh());
  context.subscriptions.push(watcher);
}

export function deactivate() {}
```

---

# 2. Core：OpenAI 兼容客户端 + 限流器 + Provider 路由

```ts
// src/core/runtime/TokenBucketLimiter.ts
// src/core/runtime/TokenBucketLimiter.ts
/** 令牌桶：控制每分钟请求上限 (maxRPM)，避免 429 */
export class TokenBucketLimiter {
  private tokens: number;
  private last = Date.now();
  constructor(private maxRPM: number) {
    this.tokens = maxRPM;
    setInterval(() => this.refill(), 1000);
  }
  private refill() {
    const now = Date.now();
    const dt = (now - this.last) / 1000;
    this.last = now;
    this.tokens = Math.min(this.maxRPM, this.tokens + (this.maxRPM / 60) * dt);
  }
  async acquire() {
    while (this.tokens < 1) await new Promise((r) => setTimeout(r, 150));
    this.tokens -= 1;
  }
}
```

```ts
// src/core/ai/OpenAICompatibleClient.ts
// src/core/ai/OpenAICompatibleClient.ts
/** OpenAI 兼容客户端：baseUrl + apiKey 可切换（OpenAI/腾讯混元都可用） */
import { TokenBucketLimiter } from "../runtime/TokenBucketLimiter";

export class OpenAICompatibleClient {
  private active = 0;
  private q: Array<() => void> = [];
  constructor(
    private opt: {
      baseUrl: string;
      timeoutMs: number;
      getApiKey: () => Promise<string>;
      maxConcurrency: number;
      limiter: TokenBucketLimiter;
    },
    private logger: { warn(m: string): void }
  ) {}
  async chat(model: string, messages: any, temperature = 0.2) {
    return this.enqueue(async () => {
      await this.opt.limiter.acquire();
      const ctl = new AbortController();
      const t = setTimeout(() => ctl.abort(), this.opt.timeoutMs);
      try {
        const res = await fetch(
          `${this.opt.baseUrl.replace(/\/+$/, "")}/chat/completions`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${await this.opt.getApiKey()}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ model, messages, temperature }),
            signal: ctl.signal,
          }
        );
        clearTimeout(t);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${await res.text()}`);
        return await res.json();
      } catch (e: any) {
        this.logger.warn(`[openai-compatible] ${e?.message ?? e}`);
        throw e;
      }
    });
  }
  private enqueue<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      const exec = async () => {
        this.active++;
        try {
          resolve(await task());
        } catch (e) {
          reject(e);
        } finally {
          this.active--;
          this.pump();
        }
      };
      this.q.push(exec);
      this.pump();
    });
  }
  private pump() {
    while (this.active < this.opt.maxConcurrency && this.q.length)
      this.q.shift()!();
  }
}
```

```ts
// src/core/ai/ProviderRegistry.ts
// src/core/ai/ProviderRegistry.ts
/**
 * ProviderRegistry：从配置 + SecretStorage 组装 openai/hunyuan 客户端，
 * 并提供主用/回退两个通道的调用。
 */
import * as vscode from "vscode";
import { OpenAICompatibleClient } from "./OpenAICompatibleClient";
import { TokenBucketLimiter } from "../runtime/TokenBucketLimiter";

export class ProviderRegistry {
  constructor(
    private ctx: vscode.ExtensionContext,
    private logger: { warn(m: string): void }
  ) {}

  private client(provider: "openai" | "hunyuan"): OpenAICompatibleClient {
    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const baseUrl = cfg.get<string>(`aiSuite.${provider}.baseUrl`)!;
    const timeoutMs = cfg.get<number>(`aiSuite.${provider}.timeoutMs`, 10000);
    const maxConcurrency = cfg.get<number>("aiSuite.maxConcurrency", 3);
    const maxRPM = cfg.get<number>("aiSuite.maxRPM", 60);
    const keyName =
      provider === "openai" ? "aiSuite.key.openai" : "aiSuite.key.hunyuan";
    const limiter = new TokenBucketLimiter(maxRPM);
    return new OpenAICompatibleClient(
      {
        baseUrl,
        timeoutMs,
        maxConcurrency,
        limiter,
        getApiKey: () => this.ctx.secrets.get(keyName).then((k) => k || ""),
      },
      this.logger
    );
  }

  async chatWithProfile(
    content: string[],
    profile: "alias", // 你可以后续扩展更多 profile
    prefer: "primary" | "fallback" = "primary"
  ): Promise<any> {
    const cfg = vscode.workspace.getConfiguration("aiSuite");
    const primary = cfg.get<"openai" | "hunyuan">(
      "aiSuite.provider.primary",
      "openai"
    );
    const fallback = cfg.get<"none" | "openai" | "hunyuan">(
      "aiSuite.provider.fallback",
      "hunyuan"
    );

    const run = async (p: "openai" | "hunyuan") => {
      const model = cfg.get<string>(`aiSuite.${p}.model`)!;
      const client = this.client(p);
      const messages =
        profile === "alias"
          ? [
              {
                role: "system",
                content:
                  "你是文件名本地化助手。只输出 JSON，不要解释。键是原名，值是中文短别名（≤16汉字）。",
              },
              { role: "user", content: JSON.stringify(content) },
            ]
          : [{ role: "user", content: content.join("\n") }];
      return client.chat(model, messages, 0.2);
    };

    try {
      return await run(primary);
    } catch (e) {
      if (fallback === "none") throw e;
      return run(fallback as "openai" | "hunyuan");
    }
  }
}
```

---

# 3. 字典模块：内置词表 + 学习型词典（自动写入）

```ts
// src/features/explorer-alias/domain/policies/GlossaryPolicy.ts
// src/features/explorer-alias/domain/policies/GlossaryPolicy.ts
/** 内置词表（命中率高、置信度 1.0） */
import { AliasResult } from "../ports";
export class GlossaryPolicy {
  private map: Record<string, string> = {
    README: "自述",
    readme: "自述",
    src: "源码",
    dist: "构建产物",
    utils: "工具",
    components: "组件",
    pages: "页面",
    hooks: "钩子",
    assets: "资源",
    public: "公开资源",
    tests: "测试",
    config: "配置",
  };
  lookup(name: string): AliasResult | undefined {
    const base = name.replace(/\.(md|txt|json|ya?ml|tsx?|jsx?)$/i, "");
    const hit = this.map[base];
    return hit ? { alias: hit, source: "dict", confidence: 1.0 } : undefined;
  }
}
```

```ts
// src/features/explorer-alias/infra/cache/LearnedGlossaryStore.ts
// src/features/explorer-alias/infra/cache/LearnedGlossaryStore.ts
/** 学习型词典：把 AI 的结果持久化到项目根，避免重复请求 */
import * as vscode from "vscode";

export class LearnedGlossaryStore {
  private map = new Map<string, string>();
  private loaded = false;
  constructor(private fileName = ".ai-glossary.learned.json") {}
  private norm(name: string) {
    return name.replace(/\.[^.]+$/, "").toLowerCase();
  }

  async load() {
    if (this.loaded) return;
    const root = vscode.workspace.workspaceFolders?.[0]?.uri;
    if (!root) return;
    const uri = vscode.Uri.joinPath(root, this.fileName);
    try {
      const buf = await vscode.workspace.fs.readFile(uri);
      const json = JSON.parse(Buffer.from(buf).toString("utf8")) as Record<
        string,
        string
      >;
      for (const [k, v] of Object.entries(json)) this.map.set(k, v);
    } catch {
      /* 文件可能不存在 */
    }
    this.loaded = true;
  }
  async get(name: string) {
    await this.load();
    return this.map.get(this.norm(name));
  }
  async set(name: string, alias: string) {
    await this.load();
    this.map.set(this.norm(name), alias);
    await this.save();
  }
  private async save() {
    const root = vscode.workspace.workspaceFolders?.[0]?.uri;
    if (!root) return;
    const uri = vscode.Uri.joinPath(root, this.fileName);
    const json = JSON.stringify(Object.fromEntries(this.map), null, 2);
    await vscode.workspace.fs.writeFile(uri, Buffer.from(json, "utf8"));
  }
}
```

---

# 4. 翻译模块：路由到 OpenAI/混元 + 批量去重 + JSON 输出

```ts
// src/features/explorer-alias/infra/translators/AITranslatorRouter.ts
// src/features/explorer-alias/infra/translators/AITranslatorRouter.ts
/** 把多个短名打包为一次请求，返回 JSON 映射；底层路由到 OpenAI/混元 */
import { ProviderRegistry } from "@core/ai/ProviderRegistry";

export class AITranslatorRouter {
  constructor(private providers: ProviderRegistry) {}
  async translateAliasBatch(names: string[]): Promise<Record<string, string>> {
    const uniq = Array.from(new Set(names));
    if (!uniq.length) return {};
    const data = await this.providers.chatWithProfile(uniq, "alias", "primary");
    const raw = (data?.choices?.[0]?.message?.content ?? "").trim();
    try {
      return JSON.parse(raw || "{}");
    } catch {
      return {};
    }
  }
}
```

---

# 5. 用例串联：词表 → 学习词典 → 规则 → AI → 回写

> 你已有的 `RuleEngine` 可继续复用；这里重点展示用例如何**写回学习词典**并**最小化 API 请求**。

```ts
// src/features/explorer-alias/app/TranslateNodeUseCase.ts
// src/features/explorer-alias/app/TranslateNodeUseCase.ts
/** 翻译链路：词表 → 学习词典 → 规则 → AI → 回写（缓存 & 学习词典） */
import { AliasResult } from "../domain/ports";
import { LearnedGlossaryStore } from "../infra/cache/LearnedGlossaryStore";
import { AITranslatorRouter } from "../infra/translators/AITranslatorRouter";

export class TranslateNodeUseCase {
  constructor(
    private glossary: { lookup(n: string): AliasResult | undefined },
    private learned: LearnedGlossaryStore,
    private rules: {
      apply(n: string, k: "file" | "folder"): AliasResult | undefined;
    },
    private cache: {
      get(p: string): AliasResult | undefined;
      set(p: string, r: AliasResult): void;
    },
    private ai?: AITranslatorRouter
  ) {}

  async exec(
    fsPath: string,
    name: string,
    kind: "file" | "folder"
  ): Promise<AliasResult> {
    const c = this.cache.get(fsPath);
    if (c) return c;

    const d = this.glossary.lookup(name);
    if (d) {
      this.cache.set(fsPath, d);
      return d;
    }

    const l = await this.learned.get(name);
    if (l) {
      const r = { alias: l, source: "ai" as const, confidence: 0.9 };
      this.cache.set(fsPath, r);
      return r;
    }

    const r = this.rules.apply(name, kind);
    if (r) {
      this.cache.set(fsPath, r);
      return r;
    }

    if (this.ai) {
      try {
        const map = await this.ai.translateAliasBatch([name]);
        const alias = sanitize(map[name] ?? "");
        if (alias && alias !== name) {
          const ar = { alias, source: "ai" as const, confidence: 0.9 };
          this.cache.set(fsPath, ar);
          await this.learned.set(name, alias); // 记入学习词典
          return ar;
        }
      } catch {
        /* 忽略网络错误，走回退 */
      }
    }

    const fb = { alias: name, source: "unknown" as const, confidence: 0.5 };
    this.cache.set(fsPath, fb);
    return fb;
  }
}
function sanitize(s: string) {
  return (s || "")
    .split(/\r?\n/)[0]
    .replace(/[\\/:*?"<>|]/g, "·")
    .trim()
    .slice(0, 32);
}
```

---

# 6. 在 Feature A 入口里**接线**（创建路由 & 注入）

```ts
// src/features/explorer-alias/index.ts
// src/features/explorer-alias/index.ts
/**
 * 入口：把 ProviderRegistry / AITranslatorRouter / LearnedGlossary 注入用例
 */
import * as vscode from "vscode";
import { AIExplorerProvider } from "./ui/AIExplorerProvider";
import { NameCacheStore } from "./infra/cache/NameCacheStore";
import { GlossaryPolicy } from "./domain/policies/GlossaryPolicy";
import { RuleEngine } from "./domain/policies/RuleEngine";
import { TranslateNodeUseCase } from "./app/TranslateNodeUseCase";
import { TranslateBatchUseCase } from "./app/TranslateBatchUseCase";
import { LearnedGlossaryStore } from "./infra/cache/LearnedGlossaryStore";
import { ProviderRegistry } from "@core/ai/ProviderRegistry";
import { AITranslatorRouter } from "./infra/translators/AITranslatorRouter";

export function registerExplorerAlias(context: vscode.ExtensionContext) {
  const config = vscode.workspace.getConfiguration("aiSuite");
  const showAlias = config.get<boolean>("aiSuite.showAlias", true);
  const cacheFile = config.get<string>(
    "aiSuite.cacheFile",
    ".ai-name-cache.json"
  );
  const maxConcurrency = Math.max(
    1,
    Math.min(10, config.get<number>("aiSuite.maxConcurrency", 3))
  );

  const cache = new NameCacheStore(context, cacheFile);
  const glossary = new GlossaryPolicy();
  const rules = new RuleEngine();
  const learned = new LearnedGlossaryStore();

  // Provider 路由（可缺：如果用户没设置 Key，也能只用词表/规则）
  const registry = new ProviderRegistry(context, {
    warn: (m) => console.warn(m),
  });
  const aiRouter = new AITranslatorRouter(registry);

  const translateNode = new TranslateNodeUseCase(
    glossary,
    learned,
    rules,
    cache,
    aiRouter
  );
  const translateBatch = new TranslateBatchUseCase(
    translateNode,
    cache,
    maxConcurrency
  );

  const provider = new AIExplorerProvider({
    cache,
    translateNode,
    translateBatch,
    showAlias,
  });

  const tree = vscode.window.createTreeView("aiExplorer", {
    treeDataProvider: provider,
    showCollapseAll: true,
  });
  context.subscriptions.push(tree);

  context.subscriptions.push(
    vscode.commands.registerCommand("aiExplorer.refresh", () =>
      provider.refresh()
    ),
    vscode.commands.registerCommand("aiExplorer.toggleShowAlias", () =>
      provider.toggleShowAlias()
    ),
    vscode.commands.registerCommand("aiExplorer.translateNode", (item?: any) =>
      provider.translateNode(item)
    ),
    vscode.commands.registerCommand("aiExplorer.translateAll", () =>
      provider.translateAllInWorkspace()
    ),
    vscode.commands.registerCommand("aiExplorer.renameToAlias", (item?: any) =>
      provider.renameToAlias(item)
    )
  );
  return provider;
}
```

---

# 7. 使用方法（从现在开始）

1. 在扩展宿主里运行：

   - 打开命令面板搜索 **“AI Suite：设置 OpenAI API Key”** 或 **“AI Suite：设置腾讯混元 API Key”**（二选一或都设置）。
   - 执行 **“AI Suite：选择主用模型提供方”**（OpenAI 或 腾讯混元）。

2. 在 **AI 资源管理器** 视图：

   - 执行 **“翻译整个工作区”** 或右键**“翻译所选节点”**。
   - 首轮会调用 API；之后**相同短名**会命中 `.ai-glossary.learned.json`，**不再请求**。

3. 你也可以把常用术语提升到**内置词表**或项目私有 `.ai-glossary.json`（优先级更高，置信度 1.0）。

---

# 8. 小优化 & 排错提示

- **没有 Key 也能跑**：只会命中“词表/学习词典/规则”，未命中时回退原名（不会报错）。
- **批量去重**：`AITranslatorRouter` 已经将短名 `Set` 去重并**一次请求**拿回 JSON——更省钱更快。
- **缓存层次**：

  - 路径缓存：`NameCacheStore`（对具体路径生效，命中最快）；
  - 学习词典：`LearnedGlossaryStore`（对“同名”生效，跨目录复用）；
  - 内置词表：`GlossaryPolicy`（最高优先级，团队约定术语）。

- **视图没变化？**别忘了在视图中执行“切换显示 中文别名/原名”；中文会显示为主标签。
- **429/限速**：`maxConcurrency` 与 `maxRPM` 能有效避免。
- **别名安全**：`sanitize()` 已限制非法字符与长度；真正重命名真实文件前仍建议**干跑 + 确认**。

---

如果你把以上文件拷到你的仓库（路径保持一致），**现在这套就能：换 Key / 换 Provider / 自动学词典 / 减少重复请求**。
需要我再把 **“批量 JSON Schema 校验”** 或 **“一键把学习词条提升为固定词表”** 的命令也补上吗？
