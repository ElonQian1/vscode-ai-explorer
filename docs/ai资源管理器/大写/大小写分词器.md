但是有些是 小写+大写， 应该如何最佳的匹配规则？
没错，“小写+大写”混排（camelCase / PascalCase / iOS / HTMLParser / fileIDs…）要想**直译稳定 + 可维护**，关键是**分词边界**要“够聪明”。下面给你一套**最佳匹配规则**（可直接落地到你现在的 V2 直译管线），再送一份**分词器代码**，专门解决这些边界。

---

# 最佳匹配规则（按顺序判定）

1. **先分隔符再驼峰**
   先按 `- _ .` 切段（保留分隔符），再对每个“词段”做驼峰拆分。这样重建时能**100%保留原分隔符**。

2. **驼峰三类边界**

   - `aB / 9A`：小写/数字 → 大写（例：`useForm`→`use|Form`）
   - `ABc`：连续大写后接“大写+小写”（例：`HTMLParser`→`HTML|Parser`）
   - `aAB`：小写后接 ≥2 个大写（例：`iOS`→`i|OS`）

3. **字母 ↔ 数字边界**
   `Ab12`→`Ab|12`，`v2X`→`v2|X`（例：`JSON2CSV`→`JSON|2|CSV`）。

4. **缩写（acronym）= 白名单**
   只有**白名单**（如 `UI, API, HTTP, URL, DOM, ID, UUID, JSON, XML…`）才当“缩写”，**原样保留**；其它全大写 **当普通词**，转小写参与词典（`DEBUG`→`debug`）。

5. **“数字缩写”特例**
   常见 numeronym 直接当词：`i18n, l10n, k8s, e2e`（映射到“国际化/本地化/K8s/端到端”）。

6. **复数/时态轻归一**（做匹配，不改原文）
   `analyses→analysis, elements→element, parsed→parse, running→run`……用于**词典命中**，不影响重建。

7. **短语优先、单词次之**
   `use form` 作为**短语**优先命中（→`useForm` 或 `使用表单`），命不中再分别命中 `use` / `form`。

8. **整名级别禁用（直译模式）**
   在直译模式下不允许 `clean-outdated-docs` 整体词典命中，**必须走 token/短语级**，才能保留 `- _ .`。

9. **重建策略**
   逐 token 替换后，用**分词时记录的分隔符**重建；**驼峰内部默认无连接符**（可选配置 `camelBoundaryJoiner`，默认 `""`，也可设为 `"_"`）。

10. **AI 兜底**
    仅对**未命中**的 token/短语触发一次合并请求，要求返回**小写键 → 中文（或保留英文）**的 JSON；写回“直译学习词典”，再次重建。

---

# 直接可用的分词器（增强版）

> 放到你项目里，替换/并列现有 `NameTokenizer`，**完全兼容**你现在的“保留分隔符 + 直译 V2”管线。

```ts
// 文件名: src/shared/naming/CaseAwareTokenizer.ts
/**
 * 小写+大写混排分词器（保留分隔符）
 * 规则：
 * 1) 先按 - _ . 切段（保留分隔符）
 * 2) 再做驼峰边界拆分：aB、ABc、aAB
 * 3) 字母↔数字边界
 * 4) 全大写仅在“白名单缩写”内判为 acronym，否则当普通词（lower）
 * 5) 识别 numeronym（i18n/l10n/k8s/e2e）
 */
import * as vscode from "vscode";

export type Token = {
  raw: string;
  lower: string;
  type: "word" | "acronym" | "num";
};

export function splitWithDelimiters(name: string): {
  tokens: Token[];
  delims: string[];
  ext: string;
} {
  const i = name.lastIndexOf(".");
  const base = i > 0 ? name.slice(0, i) : name;
  const ext = i > 0 ? name.slice(i + 1).toLowerCase() : "";

  // 1) 先切分隔符，保留它们
  const parts: Array<{ t?: string; d?: string }> = [];
  base.replace(/([A-Za-z0-9]+)|([^A-Za-z0-9]+)/g, (_, t, d) => {
    if (t) parts.push({ t });
    if (d) parts.push({ d });
    return "";
  });

  const tokens: Token[] = [];
  const delims: string[] = [];

  for (let p = 0; p < parts.length; ) {
    const seg = parts[p];
    if (seg.t) {
      // 2) 对“词段”做驼峰/数字边界拆分
      const chunks = splitCamelAndDigits(seg.t);
      for (let c = 0; c < chunks.length; c++) {
        tokens.push(classify(chunks[c]));
        // 分隔符跟在“段末”
        if (c === chunks.length - 1) {
          const next = parts[p + 1];
          if (next?.d) {
            delims.push(next.d);
            p += 2;
          } else {
            delims.push("");
            p += 1;
          }
        } else {
          delims.push(""); // 驼峰内部无显式分隔符
        }
      }
    } else {
      // 连续分隔符（极少）→ 跳过
      p += 1;
    }
  }
  return { tokens, delims, ext };
}

function splitCamelAndDigits(s: string): string[] {
  // 驼峰三条 + 字母/数字互拆
  return s
    .replace(/(?<=[a-z0-9])(?=[A-Z])/g, " ") // aB / 9A
    .replace(/(?<=[A-Z])(?=[A-Z][a-z])/g, " ") // ABc
    .replace(/(?<=[a-zA-Z])(?=\d)/g, " ") // A9
    .replace(/(?<=\d)(?=[a-zA-Z])/g, " ") // 9A
    .split(/\s+/)
    .filter(Boolean);
}

function classify(raw: string): Token {
  // numeronym 直通过
  const low = raw.toLowerCase();
  if (/^(i18n|l10n|k8s|e2e)$/.test(low))
    return { raw, lower: low, type: "word" };

  if (/^\d+$/.test(raw)) return { raw, lower: raw, type: "num" };

  // 全大写：仅白名单才当 acronym
  if (/^[A-Z]{2,}$/.test(raw)) {
    const allow = getAcronymAllow();
    return allow.has(raw)
      ? { raw, lower: low, type: "acronym" } // 缩写：UI/API/HTTP/URL…
      : { raw, lower: low, type: "word" }; // 普通词：DEBUG/WARNING…
  }

  return { raw, lower: low, type: "word" };
}

function getAcronymAllow(): Set<string> {
  const list = vscode.workspace
    .getConfiguration("aiSuite")
    .get<string[]>("aiSuite.alias.acronymAllowlist", [
      "UI",
      "API",
      "HTTP",
      "HTTPS",
      "URL",
      "URI",
      "DOM",
      "ID",
      "UUID",
      "CPU",
      "GPU",
      "DB",
      "SQL",
      "ORM",
      "TCP",
      "UDP",
      "TLS",
      "SSL",
      "SDK",
      "CLI",
      "CI",
      "CD",
      "JWT",
      "CSS",
      "HTML",
      "JS",
      "TS",
      "JSX",
      "TSX",
      "JSON",
      "XML",
      "CSV",
      "PNG",
      "JPG",
      "GIF",
      "SVG",
      "PDF",
      "MD",
      "IOS",
    ]);
  return new Set(list);
}
```

> 这个分词器会给出：
>
> - `useForm` → `use | Form`（内部无显式分隔符，重建时默认不加）
> - `HTMLParser` → `HTML | Parser`（`HTML` 保留缩写）
> - `iOSVersion` → `i | OS | Version`（`OS` 保留缩写，`i` 当普通词）
> - `JSON2CSV` → `JSON | 2 | CSV`
> - `fileIDs` → `file | IDs`（`IDs`→`id` 由**词典归一**或**AI 兜底**处理）

---

## 词典与重建的配合（你现在的 V2 直译管线直接适配）

- **词典键一律小写**，短语用空格：

  - `use form → useForm` 或 `使用表单`
  - `is valid → 是否有效`（如你想让 `isURLValid` 直出“`是否URL有效`”）
  - `warning → 警告`, `attribution → 归因`, `debug → 调试`

- **短语优先**（Trie 最长匹配）→ **单词**；命不中 → **AI 只补词条**（小写键）。
- **重建**：使用分词返回的 `delims[]` 原样拼回；**驼峰内部默认无连接符**。如果你想把驼峰也统一加下划线，可加配置：

  - `aiSuite.alias.camelBoundaryJoiner`（默认 `""`，设为 `"_"` 可生成 `use_form` 风格）。

---

## 一组示例（按“死板直译 + 保留分隔符/扩展名”）

| 原名                  | 直译效果（建议词典）                                                   |
| --------------------- | ---------------------------------------------------------------------- |
| `useForm.tsx`         | `使用表单.tsx`（`use form→使用表单` 短语）或 `useForm.tsx`（保留英文） |
| `fetchHTTPData.ts`    | `获取HTTP数据.ts`（`HTTP` 保留缩写）                                   |
| `isURLValid.js`       | `是否URL有效.js`（短语 `is valid→是否有效`）                           |
| `renderXMLToJSON.mjs` | `渲染XML到JSON.mjs`                                                    |
| `fileIDsParser.ts`    | `文件ID解析器.ts`（`IDs→ID` 通过归一/词典）                            |
| `e2eTest.spec.ts`     | `端到端测试.spec.ts`                                                   |
| `iOSVersion.md`       | `iOS版本.md`                                                           |

> 上面有几个需要你在**项目直译词典**里预置：
> `use form→使用表单`，`is valid→是否有效`，`render→渲染`，`to→到`，`parser→解析器`，`version→版本`，`file→文件`，`ids→ID`（或写规则把 `ids` 归一成 `id`）。

---

## AI 兜底如何“纠错”混排场景

- 当出现 `DEBUG_USEFORM_WARNING_ATTRIBUTION` 这类：

  - `DEBUG/WARNING/ATTRIBUTION` 会按普通词命中字典；
  - `USEFORM` 未命中 → 送 AI **只补词条**：`{ "useform": "useForm" }` 或你喜欢的中文；
  - 写回“直译学习词典（小写键）”，重建为 `调试_useForm_警告_归因.md`（**分隔符 `_` 保留**）。

---

### 小结

- **边界识别** + **白名单缩写** + **短语优先** 就是“小写+大写”混排的最佳解法；
- 结合你现有的“**直译+AI 兜底**”，第一次学到的词条会写回学习词典，之后**零请求**；
- 需要我把这份 `CaseAwareTokenizer.ts` 帮你接到现有 `LiteralPreserveWithAIFallback` 上，并顺手加几个项目词典样例吗？我可以直接给你“逐行补丁清单”。
