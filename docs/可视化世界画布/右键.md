没问题！我们把**入口**做成两条线：

1. 资源管理器右键：对**文件/文件夹**右键 → “在此打开蓝图”。
2. 你的 **AI 资源管理器** 左键：点任意节点**直接打开蓝图**。

下面给你**可落地的改动**（严格中文注释、每段代码首行写文件名），直接复制到你的仓库即可跑。

---

# 1) `package.json`：新增命令 + 右键菜单

```jsonc
// package.json
{
  "activationEvents": [
    "onCommand:workflow.openGraph",
    "onCommand:workflow.generateFromWorkspace",
    "onCommand:workflow.openBlueprintHere" // ✅ 新增：右键/左键统一入口
  ],
  "contributes": {
    "commands": [
      {
        "command": "workflow.openGraph",
        "title": "Open Workflow Graph (from current file)"
      },
      {
        "command": "workflow.generateFromWorkspace",
        "title": "Generate FileTree Blueprint (Workspace → Graph)"
      },
      {
        "command": "workflow.openBlueprintHere",
        "title": "Open Blueprint Here"
      } // ✅ 新增
    ],
    "menus": {
      "explorer/context": [
        {
          "command": "workflow.openBlueprintHere",
          "group": "navigation@100",
          "when": "resourceScheme == file && explorerResourceIsFolder == true" // ✅ 右键文件夹
        },
        {
          "command": "workflow.openBlueprintHere",
          "group": "navigation@101",
          "when": "resourceScheme == file && explorerResourceIsFolder != true" // ✅ 右键文件
        }
      ]
      // 若你想在命令面板隐藏这个命令，可加 "commandPalette": [{ "command": "workflow.openBlueprintHere", "when": "false" }]
    }
  }
}
```

---

# 2) 在入口注册：调用统一函数打开蓝图

```ts
// src/extension.ts
// 说明：保留你现有代码；只需引入并注册“文件树蓝图”模块与新命令。

import * as vscode from "vscode";
import {
  registerFileTreeBlueprint,
  openBlueprintAt,
} from "./features/filetree-blueprint/FileTreeBlueprint"; // ✅ 新增 openBlueprintAt

export function activate(context: vscode.ExtensionContext) {
  // 你已有的初始化...

  // 文件树蓝图模块（之前给你的）
  registerFileTreeBlueprint(context);

  // ✅ 右键/左键统一入口：workflow.openBlueprintHere
  context.subscriptions.push(
    vscode.commands.registerCommand(
      "workflow.openBlueprintHere",
      async (target?: unknown) => {
        // target 可能是 Uri、{resourceUri}、或多选数组
        let uri: vscode.Uri | undefined;

        if (Array.isArray(target) && target.length > 0) {
          const first = target[0];
          uri = first?.resourceUri ?? first; // 兼容多选
        } else if ((target as any)?.resourceUri) {
          uri = (target as any).resourceUri as vscode.Uri;
        } else if (target instanceof vscode.Uri) {
          uri = target;
        } else {
          // 若无上下文，fallback 到当前文件或工作区根
          uri =
            vscode.window.activeTextEditor?.document.uri ??
            vscode.workspace.workspaceFolders?.[0]?.uri;
        }

        if (!uri) {
          vscode.window.showWarningMessage(
            "未找到可用的目标路径。请在资源管理器中右键文件/文件夹重试。"
          );
          return;
        }

        await openBlueprintAt(context, uri);
      }
    )
  );
}

export function deactivate() {}
```

---

# 3) 蓝图模块：支持“指定文件/文件夹 URI 打开”

> 下面是在你已有 `FileTreeBlueprint.ts` 基础上，**新增/修改**的关键点：
>
> - 导出 `openBlueprintAt`（右键/左键统一入口）。
> - 传入**工作区根 + 相对路径**，打开对应目录的蓝图。
> - 若点到“文件”，则以**父目录**为焦点。

```ts
// src/features/filetree-blueprint/FileTreeBlueprint.ts
// 说明：新增 openBlueprintAt()；其余保持你已有功能（生成/下钻/回写等）。

import * as vscode from "vscode";
import * as path from "path";

// ……（这里保留你已有的类型定义与工具函数）……

export function registerFileTreeBlueprint(context: vscode.ExtensionContext) {
  // 保留之前的两个命令：workflow.openGraph / workflow.generateFromWorkspace
  // （此处略，和你之前一致）
}

// ✅ 新增：右键/左键统一入口
export async function openBlueprintAt(
  context: vscode.ExtensionContext,
  target: vscode.Uri
) {
  // 1) 找到所属工作区根（支持多根）
  const ws =
    vscode.workspace.getWorkspaceFolder(target) ??
    vscode.workspace.workspaceFolders?.[0];
  if (!ws) {
    vscode.window.showWarningMessage("请先打开一个工作区。");
    return;
  }

  // 2) 计算“焦点路径”（目录视图的根）
  const isFolder = await isDirectory(target);
  const focusUri = isFolder ? target : vscode.Uri.joinPath(target, "..");
  const focusPath = toPosix(path.relative(ws.uri.fsPath, focusUri.fsPath)); // 相对工作区根

  await openFileTreeGraphPanel(
    context,
    ws.uri,
    focusPath ? `/${focusPath}` : "/"
  );
}

// ========= 原有的文件树面板函数，保持不变（如你已有可直接复用） =========
async function openFileTreeGraphPanel(
  context: vscode.ExtensionContext,
  root: vscode.Uri,
  focusPath: string
) {
  // …（与之前相同：创建 webview、生成图、响应 drill / drill-up）
}

// ========= 工具函数（新增） =========
async function isDirectory(uri: vscode.Uri) {
  try {
    const stat = await vscode.workspace.fs.stat(uri);
    return (
      (stat.type & vscode.FileType.Directory) === vscode.FileType.Directory
    );
  } catch {
    return false;
  }
}
function toPosix(p: string) {
  return p.split(path.sep).join("/");
}
```

> 这样：
>
> - **资源管理器右键**文件/文件夹 → 直接打开该**目录层级**的蓝图；
> - 若右键的是“文件”，会自动切到**其父目录**的蓝图（更直观）。

---

# 4) AI 资源管理器：**左键直接打开**蓝图

你的“AI 资源管理器”是一个 `TreeView`。让**TreeItem 左键**就打开蓝图，只需给每个条目加一个 `command`。示例：

```ts
// src/features/ai-explorer/YourTreeProvider.ts
// 说明：在 getTreeItem() 里给 TreeItem 绑定 command，左键点击即触发。

import * as vscode from "vscode";

export class YourNode extends vscode.TreeItem {
  constructor(
    public readonly resourceUri: vscode.Uri,
    label: string,
    state: vscode.TreeItemCollapsibleState
  ) {
    super(label, state);
    this.resourceUri = resourceUri;

    // ✅ 左键点击：打开以该节点为焦点的文件树蓝图
    this.command = {
      command: "workflow.openBlueprintHere",
      title: "Open Blueprint",
      arguments: [this.resourceUri], // 传给 openBlueprintAt
    };
    // 可选：右键菜单也能用同一个命令（如果你在 view/item/context 自定义菜单）
  }
}
```

> 注意：如果这个节点是“文件”，蓝图会以其**父目录**为焦点；如果是“文件夹”，直接以该文件夹为焦点。
> 如果你想“单击只选中，双击才打开”，可去掉 `command`，改用 `onDidChangeSelection` 自己控制。

---

# 5) 样式 & 前端脚本（沿用之前提供的）

把这两个文件放入你的扩展包（如果已存在则跳过）：

```
media/workflow/
  ├── index.css
  └── graphView.js
```

> `FileTreeBlueprint.ts` 里用 `panel.webview.asWebviewUri` 已正确引用它们。

---

# 6) 验证清单

1. `npm run compile`（或 `pnpm run compile`）
2. F5 启动扩展开发宿主
3. 在资源管理器：

   - 右键文件夹 → “Open Blueprint Here” → 打开该目录蓝图
   - 右键文件 → “Open Blueprint Here” → 打开其**父目录**蓝图

4. 在你的 **AI 资源管理器**：

   - 左键任意节点 → 直接打开蓝图
   - 双击文件夹节点（在蓝图里）可**下钻**；工具栏“返回上一层”可上跳

---

# 7) 后续可无缝叠加

- **布局缓存**：每个 `focusPath` 写 `.vscode/workflow-layouts/<safePath>.json`，记住节点坐标与折叠状态。
- **依赖边（TS/Rust）**：解析 import/mod/use，画跨模块依赖；边抽稀与循环高亮。
- **视图切换**：在工具栏加按钮：`文件夹视图 | 模块视图 | 依赖视图 | UML`，都复用同一套缓存。
- **AI 入口**：在右栏给“摘要/建议/一键修复（预览 diff）”。

---

需要我**顺手把布局缓存**和**TS 依赖边**也接上吗？我可以基于这套入口直接加两三个文件就跑起来。
