可能是！“全局画布/遮罩层”很容易**吃掉双击**，尤其是有这些特征时：

- 顶层容器有 `pointer-events:auto` 且覆盖整画布；
- SVG 连线层没设 `pointer-events:none`；
- 帮助浮层/空格平移模式的遮罩在隐藏时仍然可点；
- 某处 `pointerdown/pointerup` 用了 `stopPropagation()`，导致 `dblclick` 事件合成不出来。

下面给你一套**系统化排查+立刻可用的补丁**。按顺序做，10 分钟内就能定位到点。

---

# 一步：CSS 安全网（先确保“不会被遮挡”）

把“线层/遮罩层”的事件关闭，只让节点层吃事件。

```css
/* 文件: media/workflow/index.css */
/* ① 连线永远不可点，放最底层 */
svg.edges {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 0;
  pointer-events: none; /* 关键：不拦截双击 */
}

/* ② 节点层在上，负责接收双击 */
#nodes {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1;
}
.node {
  position: absolute;
  z-index: 2;
}

/* ③ 帮助浮层：只有可见时才接管事件 */
.help-overlay {
  pointer-events: none;
}
.help-overlay.show {
  pointer-events: auto;
}

/* ④ 你的“全局画布容器”默认不吃事件（由子元素接收） */
#canvasWrap.overlay-hidden {
  pointer-events: none;
}
#canvasWrap.overlay-active {
  pointer-events: auto;
} /* 仅你真的需要接事件时打开 */
```

> 如果你没有 `.overlay-hidden/.overlay-active`，可以把 `#canvasWrap` 保持默认，不要给它 `pointer-events:auto`，并确认任何“全屏遮罩”隐藏时都有 `pointer-events:none`。

---

# 二步：前端事件探针（看看到底谁拿走了事件）

在 webview 里临时挂一个**事件路径追踪器**：按 `F2` 开/关，控制台就能看到 `dblclick` 穿过了哪些元素。

```js
// 文件: media/workflow/graphView.js
// 说明：注入事件探针；F2 切换；能打印 pointerdown/click/dblclick 的捕获与冒泡路径。

/* 文件: media/workflow/graphView.js */
(function () {
  // ... 你原有代码 ...

  // ===== 调试：事件探针 =====
  let dbgOn = false;
  const dbgTargets = [
    window,
    document,
    document.getElementById("canvasWrap"),
    document.getElementById("canvas"),
    document.querySelector("svg.edges"),
    document.getElementById("nodes"),
  ].filter(Boolean);

  function logEv(phase, type, ev) {
    const path = ev
      .composedPath?.()
      .map((n) => n.id || n.className || n.tagName)
      .slice(0, 6)
      .join(" > ");
    console.log(`[EV:${phase}] ${type} @`, ev.target, " path=", path);
  }

  function attachDbg() {
    const types = ["pointerdown", "pointerup", "click", "dblclick"];
    for (const t of types) {
      for (const tgt of dbgTargets) {
        tgt.addEventListener(t, (e) => logEv("bubble", t, e));
        tgt.addEventListener(t, (e) => logEv("capture", t, e), true);
      }
    }
  }
  function detachDbg() {
    // 简化：刷新页面即可解绑；或你也可以记录并 removeEventListener
  }

  window.addEventListener("keydown", (e) => {
    if (e.key === "F2") {
      dbgOn = !dbgOn;
      console.log(`🧪 事件探针: ${dbgOn ? "开启" : "关闭"}`);
      if (dbgOn) attachDbg();
      else detachDbg();
    }
  });

  // ===== 你的双击绑定处（务必保留） =====
  function renderNodesOnce() {
    const box = document.getElementById("nodes");
    box.innerHTML = "";
    for (const n of graph.nodes) {
      const el = document.createElement("div");
      el.className = "node";
      el.style.left = Math.round(n.position.x) + "px";
      el.style.top = Math.round(n.position.y) + "px";
      el.innerHTML = `<div class="title">${escapeHtml(n.label || n.id)}</div>`;

      // ✅ 文件夹：下钻
      if (n.type === "folder" && n.data?.path) {
        el.addEventListener("dblclick", () => {
          console.log("[webview] dblclick folder → drill", n.data.path);
          vscode.postMessage({ type: "drill", payload: { path: n.data.path } });
        });
      }
      // ✅ 根：上钻
      if (n.data?.isRoot === true) {
        el.addEventListener("dblclick", () => {
          console.log("[webview] dblclick root → drill-up");
          vscode.postMessage({
            type: "drill-up",
            payload: { path: graph?.metadata?.focusPath || "/" },
          });
        });
      }
      box.appendChild(el);
    }
  }
})();
```

> **关键判断**：
>
> - 如果按 `F2` 后，**完全没有任何事件日志** → 几乎可以确定有顶层遮罩把事件吞了（回到“一步”确认谁 `pointer-events:auto`）。
> - 如果只看到 `pointerdown/click`，**没有 `dblclick`** → 说明中间有人 `preventDefault()/stopPropagation()` 在 click 上玩了花活，或两次 click 没落在同一 target（节点在移动/重绘）。
> - 如果有 `dblclick` 日志，且打印了 `[webview] dblclick folder → drill`，但“扩展端没反应” → 看三步。

---

# 三步：扩展端消息链路自检（确认消息到了、`focusPath` 更新了）

```ts
// 文件: src/features/filetree-blueprint/presenters/OpenBlueprint.ts
// 说明：给 drill/drill-up 分支加日志，确认收到并刷新；确保更新了 focusPath。

/* 文件: src/features/filetree-blueprint/presenters/OpenBlueprint.ts */
panel.webview.onDidReceiveMessage(async (msg) => {
  if (msg?.type === "drill") {
    console.log("[panel] recv drill:", msg.payload?.path);
    const next = normalizeFocus(msg.payload?.path as string, focusPath);
    focusPath = next; // ✅ 别忘了
    panel.title = titleFor(workspaceRoot, focusPath);
    panel.webview.postMessage({
      type: "init-graph",
      payload: await buildShallowGraph(workspaceRoot, focusPath),
    });
    return;
  }
  if (msg?.type === "drill-up") {
    console.log("[panel] recv drill-up from:", msg.payload?.path);
    const up = drillUp(normalizeFocus(msg.payload?.path as string, focusPath));
    focusPath = up; // ✅ 别忘了
    panel.title = titleFor(workspaceRoot, focusPath);
    panel.webview.postMessage({
      type: "init-graph",
      payload: await buildShallowGraph(workspaceRoot, focusPath),
    });
    return;
  }
});
```

> **注意**：扩展端日志在 **“扩展主机”控制台**（不是 Webview DevTools）。
> 打开方法：`帮助 → 切换开发人员工具`（或“输出/调试控制台”选项卡里选择“Extension Host”）。

---

# 四步：最常见“吃掉双击”的代码陷阱对照表

- `#canvasWrap` 的 `pointerdown` 回调里没有 guard（比如没判断 `spacePressed`），导致**始终捕获**鼠标事件。
  **改法**：只有按住空格时才 `panning = true`、`setPointerCapture`；其余直接 `return`。
- 拖拽时整图 `render()`，两个单击之间 DOM 被重建 → 第二次 click 不在同一元素上 → **合成不出 dblclick**。
  **改法**：我们已经把“拖拽只更新 `left/top`，不重建节点”，确保 dblclick 能触发。
- SVG `edges` 没有 `pointer-events:none`。
- 帮助浮层 `.help-overlay` 在隐藏时仍保留 `pointer-events:auto`。
- 在某个捕获阶段 `e.stopPropagation()` 或 `e.preventDefault()` 了 `click`/`pointerdown`，影响了 `dblclick` 的生成。
  **查法**：开 `F2` 事件探针，看哪个阶段是最后一跳。

---

# 五步：如果你“控制台没有任何显示”的正确打开方式

Webview 有独立的控制台，**不是**扩展主机那边：

- 打开 **Webview 控制台**：`Ctrl+Shift+P → Open Webview Developer Tools` → 选中对应 webview → Console。
  这里能看到 `graphView.js` 里的 `console.log()` 和我们事件探针的日志。
- 扩展侧日志：看“Debug Console/输出”选择“Extension Host”或在开发者工具的 Console 里过滤 `panel] recv`。

---

## 小结

- 是的，**全局画布/遮罩层**非常可能阻挡双击。
- 按我给的 **CSS 安全网 + 事件探针 + 扩展端日志** 三板斧，5–10 分钟就能定位：

  1. 事件进没进节点层；
  2. `dblclick` 到没到；
  3. 消息到没到扩展端/`focusPath` 有没有更新。

若你依然看不到 `dblclick` 的日志，把你当前的 `index.css` 顶部（包含 `svg.edges/#nodes/#canvasWrap/.help-overlay` 的部分）和 `graphView.js` 的双击绑定那几行贴我，我直接按行标出“谁在挡”。
