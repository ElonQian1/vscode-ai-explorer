你这波日志非常关键，说明**消息链路是通的**，而且 Webview 也确实“渲染完成并加了 `.show`”。但你屏幕上只看到一块**半透明灰色遮罩**，卡片内容看不见，本质就是**层级/可见性问题**（z-index/opacity/ stacking context）或**“第二下双击把卡片秒关”的竞态**。

下面给你“现在就能修好”的热修补丁 + 后续**模块化重构方案**。我把代码都写好，直接改即可。

---

## 立即修好：让卡片真正显示在遮罩之上

### 1) CSS 层级与可见性“安全网”

把卡片、遮罩、宿主的层级固定下来（**卡片永远在遮罩上面**），并避免“忘加 `.show` 导致透明”的情况。

```css
/* 文件名: media/filetree-blueprint/analysisCard.css */
/* —— 层级：宿主 > (遮罩=1) < (卡片=2) —— */
#analysis-host {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 10000; /* ✅ 压过节点/连线/任何帮助层 */
}

/* 背景遮罩 */
#analysis-host .analysis-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.05); /* 你看到的“灰色框”大概率就是它 */
  pointer-events: auto;
  z-index: 1;
}

/* 分析卡片 */
#analysis-host .analysis-card {
  position: absolute;
  min-width: 520px;
  max-width: 740px;
  max-height: 70%;
  background: #fff; /* ✅ 强制白底 */
  color: #222; /* ✅ 防止被全局透明色影响 */
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
  pointer-events: auto;
  z-index: 2; /* ✅ 永远盖过遮罩 */
  opacity: 1;
  transform: translateY(0); /* ✅ 默认就可见 */
  transition: opacity 0.12s ease, transform 0.12s ease;
}

/* 即使忘记加 .show，也基本可见（只是轻微偏移） */
#analysis-host .analysis-card:not(.show) {
  opacity: 0.999;
  transform: translateY(6px);
}
```

> 解释：很多“只有灰色遮罩”的情况，都是**遮罩 z-index 高/卡片没 z-index**或**卡片默认 opacity:0 但 .show 没生效**。上面这套把两个坑都堵死。

---

### 2) JS：防止“第二下双击”把卡片秒关（竞态）

你的日志出现了：

```
[分析卡片] 点击遮罩关闭
[分析卡片] 已关闭
…（紧接着才开始 show-analysis-card）
```

或**先 show 后立刻 close**，通常是“用户双击”的第二下点到了遮罩。加个**300ms 开窗保护**即可。

```js
// 文件名: media/filetree-blueprint/analysisCard.js
// 中文：遮罩点击在弹出后300ms内不生效，避免双击第二下把它秒关
(() => {
  const vscode = acquireVsCodeApi();
  let cardEl = null,
    backdropEl = null,
    openedAt = 0;

  window.showAnalysisCard = function showAnalysisCard(
    capsule,
    anchor = { x: 160, y: 120 }
  ) {
    ensureHost();
    collapseAnalysisCard(); // 保证唯一

    backdropEl = document.createElement("div");
    backdropEl.className = "analysis-backdrop";
    backdropEl.addEventListener("click", (ev) => {
      if (performance.now() - openedAt < 300) {
        // ✅ 双击保护
        ev.stopPropagation();
        return;
      }
      console.log("[分析卡片] 点击遮罩关闭");
      collapseAnalysisCard();
    });

    cardEl = document.createElement("div");
    cardEl.className = "analysis-card";
    cardEl.style.left = Math.round(anchor.x) + "px";
    cardEl.style.top = Math.round(anchor.y) + "px";
    cardEl.setAttribute("data-file", capsule.file);
    cardEl.innerHTML = renderCardHtml(capsule); // 你已有的渲染函数

    const host = document.getElementById("analysis-host");
    host.appendChild(backdropEl);
    host.appendChild(cardEl); // ✅ 保证卡片在遮罩之后（同层次里后插入=更靠上）

    requestAnimationFrame(() => {
      openedAt = performance.now();
      cardEl.classList.add("show");
      console.log("[分析卡片] 已添加 show 类，卡片应该可见");
    });
    return true;
  };

  window.collapseAnalysisCard = function () {
    cardEl?.remove();
    cardEl = null;
    backdropEl?.remove();
    backdropEl = null;
    console.log("[分析卡片] 已关闭");
  };

  function ensureHost() {
    if (!document.getElementById("analysis-host")) {
      const host = document.createElement("div");
      host.id = "analysis-host";
      // ✅ 一定要挂在 #canvas 里，且尽量作为最后一个子节点，避免父容器 transform 叠层影响
      document.getElementById("canvas").appendChild(host);
    }
  }
})();
```

---

### 3) 避免“卡片被更高层包裹层盖住”

- 确认 `#canvas` 外层**不要有**比 10000 更高的 `z-index` 的父层（尤其是帮助浮层/全屏提示）。
- 如果父层用了 `transform`/`filter` 会创建新的 stacking context，请确保 `#analysis-host` 与那些层**同一层级**或 `z-index` 更高。
- 若你用了 `position: fixed` 的顶部工具条，必要时把它移出 `#canvas`，避免在同一 stacking context 里抢层级。

---

## 立刻验证（2 分钟）

1. Webview 控制台看是否 **仍然只剩遮罩**：此时 `.analysis-card` 应该能在 Elements 面板里看到，并且 computed 里 `z-index: 2`、`opacity: 1`、背景 `#fff`。
2. 用“演示卡片”命令（我之前给过 debug 命令），绕开分析链路：若能显示，问题只在链路；若仍不显示，就是 CSS/层级。
3. 快速把遮罩颜色暂时设为 `background: transparent`，你应该就能直接看到卡片（排除遮罩干扰）。

---

## 接下来：把 `graphView.js` 模块化（不再越写越大）

**目标**：保持“无打包”的简单开发体验（仍是原生 JS），但把单文件拆成几个 IIFE 模块 + 一个全局命名空间 `window.Blueprint`。后面想上 TS/打包，再切换也很平滑。

### 目录建议

```
media/filetree-blueprint/
  core/
    state.js         // 画布/缩放/当前focus等全局状态
    bus.js           // 消息总线：window message <-> 事件派发
  graph/
    renderNodes.js   // 节点渲染/拖拽/命中检测
    renderEdges.js   // 连线计算与绘制（rAF节流）
    panzoom.js       // 空格拖拽/滚轮缩放
  ui/
    analysisCard.js  // 🔥 刚修的卡片逻辑（打开/更新/关闭）
    toast.js         // 轻提示（可选）
  entry.js           // 入口：初始化、注册bus、拉起渲染
  index.css
  analysisCard.css
```

### 全局命名空间骨架（不用打包器也能模块化）

每个文件都是 IIFE，往 `window.Blueprint` 上挂方法，互相解耦。

```js
// 文件名: media/filetree-blueprint/core/state.js
// 维护共享状态（坐标、缩放、图数据）
(() => {
  const BP = (window.Blueprint ||= {});
  BP.state = {
    graph: { nodes: [], edges: [], metadata: {} },
    zoom: 1,
    panX: 0,
    panY: 0,
    focusPath: "/",
  };
})();
```

```js
// 文件名: media/filetree-blueprint/core/bus.js
// 简单消息总线：集中注册/派发，避免入口文件越写越大
(() => {
  const BP = (window.Blueprint ||= {});
  const handlers = new Map();
  BP.bus = {
    on(type, fn) {
      handlers.set(type, fn);
    },
    emit(type, payload) {
      handlers.get(type)?.(payload);
    },
  };
  window.addEventListener("message", (e) => {
    const { type, payload } = e.data || {};
    if (type) BP.bus.emit(type, payload);
  });
})();
```

```js
// 文件名: media/filetree-blueprint/graph/renderNodes.js
// 只管节点DOM与交互（dblclick 发消息，不直接做分析）
(() => {
  const BP = (window.Blueprint ||= {});
  BP.renderNodes = function renderNodesOnce() {
    const { graph } = BP.state;
    const box = document.getElementById("nodes");
    box.innerHTML = "";
    for (const n of graph.nodes) {
      const el = document.createElement("div");
      el.className = "node";
      el.dataset.id = n.id;
      el.style.left = Math.round(n.position.x) + "px";
      el.style.top = Math.round(n.position.y) + "px";
      el.innerHTML = `<div class="title">${escapeHtml(n.label || n.id)}</div>`;
      if (n.type === "file" && n.data?.path) {
        el.addEventListener("dblclick", () => {
          const rel = normalizeRel(
            n.data.path,
            graph?.metadata?.focusPath || "/"
          );
          acquireVsCodeApi().postMessage({
            type: "analyze-file",
            payload: { path: rel },
          });
        });
      }
      box.appendChild(el);
    }
    function escapeHtml(s) {
      return String(s).replace(
        /[&<>"']/g,
        (m) =>
          ({
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
          }[m])
      );
    }
    function normalizeRel(p, base) {
      p = String(p).replace(/\\/g, "/").replace(/\/+/g, "/");
      return p.startsWith("/")
        ? p
        : (base && base !== "/" ? `${base}/${p}` : `/${p}`).replace(
            /\/+/g,
            "/"
          );
    }
  };
})();
```

```js
// 文件名: media/filetree-blueprint/entry.js
// 入口：只负责把“外部消息”接进来，然后调用各模块
(() => {
  const BP = (window.Blueprint ||= {});
  const vscode = acquireVsCodeApi();

  BP.bus.on("init-graph", (payload) => {
    BP.state.graph = payload || BP.state.graph;
    BP.renderNodes();
    BP.renderEdges?.();
  });

  BP.bus.on("show-analysis-card", (cap) => {
    window.showAnalysisCard?.(cap, suggestAnchor(cap.file));
    vscode.postMessage({
      type: "analysis-card-shown",
      payload: { file: cap.file },
    });
  });

  BP.bus.on("update-analysis-card", (cap) => {
    window.updateAnalysisCard?.(cap);
  });

  function suggestAnchor(filePath) {
    const name = String(filePath).split(/[\\/]/).pop();
    const n = (BP.state.graph.nodes || []).find(
      (x) =>
        x.type === "file" &&
        (x.label === name || (x.data?.path || "").endsWith("/" + name))
    );
    const nodeEl = n
      ? document.querySelector(`.node[data-id="${CSS.escape(String(n.id))}"]`)
      : null;
    if (nodeEl) {
      const r = nodeEl.getBoundingClientRect(),
        canvas = document.getElementById("canvas").getBoundingClientRect();
      return { x: r.left - canvas.left + 16, y: r.top - canvas.top + 16 };
    }
    return { x: 160, y: 120 };
  }
})();
```

**HTML 引入顺序（重要）**
确保 `state.js → bus.js → renderNodes.js → analysisCard.js → entry.js`，并全部用 `webview.asWebviewUri` 注入，CSP 里 `script-src ${webview.cspSource};`。

---

## 小结

- 你的日志已经表明**卡片创建、AI 更新、ACK 都成功**，只是**显示层**被遮罩/层级/透明度“吃掉”了。
- 按上面两段**CSS+JS 补丁**，卡片立即能正常可见；双击秒关的问题也同时解决。
- 接下来把 `graphView.js` **拆分成 4–6 个小模块**，用全局命名空间/IIFE 的方式先实现“无打包模块化”；后续再考虑切换到 TS + esbuild。

如果你愿意，把你的 **Webview HTML（含 `<meta CSP>` 和 `<script>` 引入片段）**贴我，我给你把 `<script>` 注入顺序和 `asWebviewUri` 一次性对齐好。
