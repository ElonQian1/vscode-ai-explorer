看日志你这边**扩展端**已经收到了双击的 `analyze-file`，并且跑了**静态分析**和**AI 分析**：

```
[StaticAnalyzer] 分析完成: 1 APIs, 2 deps
[FileAnalysisService] 开始AI增强分析...
[LLMAnalyzer] 开始AI分析: ...
```

但界面“没有任何变化”，说明**Webview 没有及时收到/渲染卡片**。最常见的两个根因：

1. 你把“展示卡片”的逻辑放在 **AI 分析完成之后** 才发消息 ➜ 一旦 LLM 慢/失败，UI 就“毫无反馈”。
2. Webview 侧没有监听你发的消息（脚本没注入/事件名不匹配/卡片渲染函数未加载）。

下面给你一套**三步修复**，保证“**先秒出静态卡片**，AI 完成后**增量更新**”，并加上**消息 ACK**，5 分钟内就能定位&解决。

---

## ✅ 第一步：扩展端—“乐观渲染 + 增量更新 + ACK”

> 收到 `analyze-file` 后：
> ① 立即用**静态分析**结果发 `show-analysis-card`（带 `loading: true`）➜ UI 立刻有反馈；
> ② 背景跑 LLM，完成后发 `update-analysis-card`；
> ③ 任一路失败，发 `analysis-error`；
> ④ 等 Webview 收到后用一条 `analysis-card-shown` **回 ACK**，用于你在控制台确认消息链路通畅。

```ts
// 文件名: src/features/filetree-blueprint/panel/BlueprintPanel.ts
// 中文注释：analyze-file → 先发静态卡片；再发AI更新；加ACK日志。

import * as vscode from "vscode";
import {
  analyzeStatic,
  analyzeWithLLM,
  type FileCapsule,
} from "../../analysis/FileAnalysisService";

export function wireBlueprintPanel(
  panel: vscode.WebviewPanel,
  context: vscode.ExtensionContext,
  workspaceRoot: vscode.Uri
) {
  panel.webview.onDidReceiveMessage(async (msg) => {
    if (msg?.type === "analyze-file") {
      const rel = String(msg.payload?.path || "/")
        .replace(/\\/g, "/")
        .replace(/\/+/g, "/");
      const fileUri = rel.startsWith("/")
        ? vscode.Uri.joinPath(workspaceRoot, rel)
        : vscode.Uri.joinPath(workspaceRoot, `/${rel}`);

      try {
        console.log("[分析文件]", fileUri.fsPath, "force=false");

        // ① 静态分析（快）→ 立即渲染
        const staticCapsule: FileCapsule = await analyzeStatic(
          context,
          fileUri
        );
        (staticCapsule as any).loading = true;
        panel.webview.postMessage({
          type: "show-analysis-card",
          payload: staticCapsule,
        });
        console.log("[UI] 已发送 show-analysis-card(静态)…");

        // ② 背景AI增强（慢）→ 完成后增量更新
        analyzeWithLLM(context, fileUri, staticCapsule)
          .then((fullCapsule) => {
            panel.webview.postMessage({
              type: "update-analysis-card",
              payload: fullCapsule,
            });
            console.log("[UI] 已发送 update-analysis-card(AI完成)…");
          })
          .catch((err) => {
            panel.webview.postMessage({
              type: "analysis-error",
              payload: {
                file: staticCapsule.file,
                message: String(err?.message || err),
              },
            });
            console.warn("[UI] 分析错误:", err);
          });
      } catch (e: any) {
        panel.webview.postMessage({
          type: "analysis-error",
          payload: { file: rel, message: String(e?.message || e) },
        });
        vscode.window.showErrorMessage(`分析失败: ${e?.message || e}`);
      }
      return;
    }

    if (msg?.type === "analysis-card-shown") {
      console.log("[ACK] Webview 已显示卡片:", msg?.payload?.file);
      return;
    }

    if (msg?.type === "open-source") {
      // 省略：打开并高亮行号（你现有逻辑）
      return;
    }
  });
}
```

---

## ✅ 第二步：Webview—**保证脚本加载 + 监听所有消息 + 渲染/更新卡片 + ACK**

> 关键点：
>
> - `window.addEventListener('message', …)` 里**同时**处理 `show-analysis-card` / `update-analysis-card` / `analysis-error`；
> - 渲染完**立刻回 ACK** 到扩展端；
> - 若你单独放了 `analysisCard.js`，**确认已在 HTML 中 `<script>` 引入**（CSP 允许）。

```js
// 文件名: media/filetree-blueprint/graphView.js
// 中文注释：接收并渲染卡片；支持AI更新；回ACK；打印调试日志。
(function () {
  const vscode = acquireVsCodeApi();
  let graph = {
    nodes: [],
    edges: [],
    metadata: { focusPath: "/", graphType: "filetree" },
  };

  // —— 统一消息入口 —— //
  window.addEventListener("message", (e) => {
    const msg = e.data;
    if (!msg?.type) return;
    console.log("[webview] recv:", msg.type);

    if (msg.type === "init-graph") {
      graph = msg.payload || graph;
      renderNodesOnce();
      initEdgesLayerOnce();
      drawEdges();
      return;
    }
    if (msg.type === "show-analysis-card") {
      const cap = msg.payload;
      ensureAnalysisInfra();
      window.showAnalysisCard
        ? window.showAnalysisCard(cap, suggestAnchor(cap.file))
        : console.warn("showAnalysisCard 未注册");
      vscode.postMessage({
        type: "analysis-card-shown",
        payload: { file: cap.file },
      }); // ✅ ACK
      return;
    }
    if (msg.type === "update-analysis-card") {
      const cap = msg.payload;
      window.updateAnalysisCard
        ? window.updateAnalysisCard(cap)
        : window.showAnalysisCard?.(cap, suggestAnchor(cap.file));
      return;
    }
    if (msg.type === "analysis-error") {
      const { file, message } = msg.payload || {};
      window.showToast?.(`分析失败: ${message || "未知错误"}`); // 可选
      return;
    }
  });

  // 提示：根据文件名找到对应节点，计算卡片默认位置
  function suggestAnchor(filePath) {
    const id = findNodeIdByFile(filePath);
    const nodeEl = id
      ? document.querySelector(`.node[data-id="${CSS.escape(String(id))}"]`)
      : null;
    if (nodeEl) {
      const r = nodeEl.getBoundingClientRect();
      const canvas = document.getElementById("canvas").getBoundingClientRect();
      return { x: r.left - canvas.left + 16, y: r.top - canvas.top + 16 };
    }
    return { x: 160, y: 120 };
  }
  function findNodeIdByFile(filePath) {
    const name = String(filePath).split(/[\\/]/).pop();
    const hit = (graph.nodes || []).find(
      (n) =>
        n.type === "file" &&
        (n.label === name || n.data?.path?.endsWith("/" + name))
    );
    return hit?.id;
  }

  function ensureAnalysisInfra() {
    // 确保 analysisCard.js/analysisCard.css 已注入；若你是单文件可忽略。
    // 如果你把卡片逻辑拆成 analysisCard.js，请确认 HTML 里 <script src=".../analysisCard.js"></script> 已存在。
  }

  // —— 你已有的 renderNodesOnce / drawEdges 保持不变 —— //
})();
```

> **请务必确认**：你的 Webview HTML 里**真的引入了**卡片脚本/样式（比如 `analysisCard.js` / `analysisCard.css`）。
> 如果没引入，`window.showAnalysisCard` 就是 `undefined`，消息到了也**渲染不出来**。

---

## ✅ 第三步：快速“自检断点”——两分钟定位

1. **看扩展端控制台**（Extension Host）

   - 预期看到：

     - `[UI] 已发送 show-analysis-card(静态)…`
     - （稍后）`[UI] 已发送 update-analysis-card(AI完成)…` 或“分析错误”
     - `[ACK] Webview 已显示卡片: /xxx.ts`

   - **若没有 ACK** ➜ Webview 侧脚本没加载/没监听 or CSP 阻拦

2. **看 Webview 控制台**（`Open Webview Developer Tools`）

   - 双击后**必须**出现：`[webview] recv: show-analysis-card`
   - 若没有任何日志：

     - 说明**message 没送达该 webview**（发到了错误的 `panel`、或者 panel 刚被销毁/重建）
     - 或**脚本报错**提前崩溃（顶部红色 error）

3. **兜底测试命令**：加一个“**演示卡片**”命令，绕过分析链路，直接发一张假数据卡片：

   - 如果能显示 ➜ 问题在分析/发送路径
   - 如果仍不显示 ➜ 问题在 webview 脚本/HTML/CSP

```ts
// 文件名: src/commands/DebugShowCard.ts
// 中文注释：一键发一张假的 FileCapsule 到当前蓝图面板，验证渲染链路。
export function debugShowCard(panel: vscode.WebviewPanel) {
  const fake = {
    fileCapsuleVersion: "1",
    file: "/src/demo.ts",
    lang: "ts",
    contentHash: "sha256:demo",
    summary: { zh: "演示：这是一段示例文件摘要。" },
    api: [
      {
        name: "hello",
        signature: "(name: string) => string",
        evidence: ["e1"],
      },
    ],
    deps: { out: [{ module: "./util", count: 1, evidence: ["e2"] }] },
    evidence: {
      e1: { file: "/src/demo.ts", lines: [1, 3], sha256: "x" },
      e2: { file: "/src/demo.ts", lines: [5, 5], sha256: "y" },
    },
  };
  panel.webview.postMessage({ type: "show-analysis-card", payload: fake });
}
```

---

## 常见坑再提醒一遍

- **消息名不一致**：扩展端发 `show-analysis-card`，Webview 却监听 `show-analysis`（差一个单词也不行）。
- **发给了错误的 panel**：你的代码里如果每次都 `new WebviewPanel`，老 panel 的监听还在，但**新 panel 收不到历史消息**。建议维持**单例 panel**，重复使用。
- **CSP 阻拦脚本**：HTML 里 `<meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src ${webview.cspSource} blob:; style-src ${webview.cspSource} 'unsafe-inline'; script-src ${webview.cspSource};">`，并用 `webview.asWebviewUri` 引入脚本/样式。
- **AI 卡住**：即使没 API Key，也应该**先把静态卡片发出去**，按钮显示“正在用 AI 增强…(可重试)”。

---

## 小结（你现在遇到的症状对应的修复）

- 你已经**触发了分析**（有扩展端日志），但**页面无反馈**。
- 把“展示卡片”改为**先静态、后 AI 更新**，并确保 Webview 监听 `show-analysis-card / update-analysis-card`；
- 加上 **ACK 回传** 和“演示卡片”命令，两分钟定位到底是**消息没发出**还是**脚本没加载**。

需要的话，把你**Webview HTML 生成**那段贴我（包含 CSP、`<script>` 标签），我帮你检查脚本/样式是否正确注入。
