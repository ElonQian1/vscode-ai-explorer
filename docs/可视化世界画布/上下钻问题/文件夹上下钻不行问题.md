你现在“双击文件夹没下钻”，99% 是这几处之一出了问题（按命中率排好序）：

1. **前端没真正发出 `drill` 消息**

   * 常见原因 A：双击处理里还在 `executeCommand('…从路径生成蓝图…')`，而不是 `postMessage({type:'drill'})`。
   * 常见原因 B：`if (graph.metadata.graphType === 'filetree')` 这个条件不成立（你的 `graphType` 不是 `filetree`），导致没绑定 `dblclick`。
   * 常见原因 C：`n.data.path` 不是**以 `/` 开头的相对 POSIX 路径**（而是空、绝对盘符或反斜杠），于是扩展端算 URI 失败。

2. **扩展端没有处理 `drill` / `drill-up`**（或处理了但**没有更新 `focusPath`** 就刷新）

   * 常见：`panel.webview.onDidReceiveMessage` 里没有 `case 'drill'|'drill-up'`，或异步完成后没改 `focusPath`，下一次仍用旧路径渲染，看起来“没反应”。

3. **路径规范化丢了**

   * Webview 发的是 `debug`，扩展端用字符串拼接，变成 `d:\rootd:\root\debug`；或发的是 `D:\…` 绝对路径，扩展端再 `joinPath(root, abs)`，也会错。
   * 必须“消息用相对 POSIX，磁盘访问时再 `joinPath(root, rel)`”。

4. **有层叠元素拦截了双击**

   * 最常见是 **SVG 线层** 或 **帮助浮层**。线层要 `pointer-events: none`；帮助浮层收起时要 `pointer-events: none`（只有 `.show` 状态才 `auto`）。

---

下面给你一套**对症补丁**（可直接替换；中文注释；每段写明文件名）。按这个落地后，下钻/上钻一定能工作。

---

### ① 前端：确保双击=发送 `drill`，根节点双击=发送 `drill-up`

```js
// 文件: media/workflow/graphView.js
// 作用: 给“文件夹节点”绑定 dblclick -> postMessage({type:'drill', path:相对POSIX})
//      给“当前层根节点”绑定 dblclick -> postMessage({type:'drill-up'})

(function () {
  const vscode = acquireVsCodeApi();
  let graph = { nodes: [], edges: [], metadata: { graphType: 'filetree', focusPath: '/' } };

  window.addEventListener('message', (e) => {
    if (e.data?.type === 'init-graph') {
      graph = e.data.payload;
      renderNodesOnce();
      // drawEdges() 等维持你当前实现
    }
  });

  function renderNodesOnce() {
    const box = document.getElementById('nodes');
    box.innerHTML = '';
    for (const n of graph.nodes) {
      const el = document.createElement('div');
      el.className = 'node';
      el.style.left = Math.round(n.position.x) + 'px';
      el.style.top  = Math.round(n.position.y) + 'px';
      el.innerHTML = `<div class="title">${escapeHtml(n.label || n.id)}</div>`;

      // ✅ 文件夹 → 下钻
      if (n.type === 'folder' && n.data?.path) {
        el.addEventListener('dblclick', () => {
          // n.data.path 必须是类似 "/docs/architecture" 的相对 POSIX
          console.log('[webview] dblclick folder → drill', n.data.path);
          vscode.postMessage({ type: 'drill', payload: { path: n.data.path } });
        });
      }
      // ✅ 当前层根节点 → 上钻
      if (n.data?.isRoot === true) {
        el.addEventListener('dblclick', () => {
          console.log('[webview] dblclick root → drill-up');
          vscode.postMessage({ type: 'drill-up', payload: { path: graph?.metadata?.focusPath || '/' } });
        });
      }

      box.appendChild(el);
    }
  }

  function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}
})();
```

> 请确认你**没有**在双击里调用 `vscode.commands.executeCommand('从路径生成蓝图', …)`，否则会绕回“命令入口+弹窗”那条老路。

---

### ② CSS：线层与帮助层不拦截点击

```css
/* 文件: media/workflow/index.css */
svg.edges { pointer-events: none; z-index: 0; }
#nodes     { position:absolute; z-index: 1; }
.node      { position:absolute; z-index: 2; }

/* 帮助浮层：只有 .show 时才接管事件 */
.help-overlay{ pointer-events: none; }
.help-overlay.show{ pointer-events: auto; }
```

---

### ③ 扩展端：在**同一个面板**处理 `drill` / `drill-up`，并更新 `focusPath`

```ts
// 文件: src/features/filetree-blueprint/presenters/OpenBlueprint.ts
// 作用: 收到 drill/drill-up 后，在同一个 panel 内刷新；不要再执行“从路径生成蓝图”命令。

import * as vscode from 'vscode';
import * as path from 'path';

export async function openBlueprintAt(context: vscode.ExtensionContext, workspaceRoot: vscode.Uri, start: string = '/') {
  let focusPath = normalizeFocus(start, '/');

  const panel = vscode.window.createWebviewPanel(
    'workflowGraph',
    titleFor(workspaceRoot, focusPath),
    vscode.ViewColumn.Beside,
    { enableScripts: true, retainContextWhenHidden: true,
      localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow')]}
  );

  // ... 注入 HTML 省略
  panel.webview.postMessage({ type: 'init-graph', payload: await buildShallowGraph(workspaceRoot, focusPath) });

  panel.webview.onDidReceiveMessage(async (msg) => {
    if (msg?.type === 'drill') {
      const next = normalizeFocus(msg.payload?.path as string, focusPath);
      console.log('[panel] drill to', next);
      focusPath = next; // ✅ 一定要更新
      panel.title = titleFor(workspaceRoot, focusPath);
      panel.webview.postMessage({ type: 'init-graph', payload: await buildShallowGraph(workspaceRoot, focusPath) });
      return;
    }
    if (msg?.type === 'drill-up') {
      const up = drillUp(normalizeFocus(msg.payload?.path as string, focusPath));
      console.log('[panel] drill-up to', up);
      focusPath = up; // ✅ 一定要更新
      panel.title = titleFor(workspaceRoot, focusPath);
      panel.webview.postMessage({ type: 'init-graph', payload: await buildShallowGraph(workspaceRoot, focusPath) });
      return;
    }
    // 其它消息按需处理/忽略
  });
}

function titleFor(root: vscode.Uri, p: string) {
  return `文件树蓝图: ${p === '/' ? path.basename(root.fsPath) : p}`;
}

function normalizeFocus(input: string, current: string): string {
  if (!input) return current || '/';
  let p = input.replace(/\\/g, '/').replace(/\/+/g, '/');
  // 若误传了盘符绝对路径，剪成相对（兜底）
  if (/^[a-zA-Z]:\//.test(p)) {
    const parts = p.split(':')[1].replace(/^\/+/, '');
    p = '/' + parts; // /dir/sub
  }
  if (p.startsWith('/')) return p;
  const base = current && current !== '/' ? current : '';
  return (base ? base + '/' + p : '/' + p).replace(/\/+/g, '/');
}

function drillUp(cur: string) {
  if (!cur || cur === '/') return '/';
  const parts = cur.split('/').filter(Boolean); parts.pop();
  return parts.length ? '/' + parts.join('/') : '/';
}

// 生成图：关键是 data.path & metadata
async function buildShallowGraph(root: vscode.Uri, focus: string) {
  const dir = focus === '/' ? root : vscode.Uri.joinPath(root, focus);
  const entries = await vscode.workspace.fs.readDirectory(dir);
  const nodes:any[] = [], edges:any[] = [];

  const rootId = focus === '/' ? 'workspace-root' : `folder_${safeId(focus)}`;
  nodes.push({
    id: rootId,
    label: focus === '/' ? path.basename(root.fsPath) : path.basename(focus),
    type: 'folder',
    position: { x: 20, y: 20 },
    data: { path: focus, isRoot: true } // ✅ isRoot + 相对 POSIX path
  });

  const grid = gridLayouter(entries.length, 200, 140, 80, 80);
  let i = 0;
  for (const [childUri, ft] of entries) {
    const base = childUri.path.split(/[\\/]/g).pop() || '';
    const rel  = path.posix.join(focus === '/' ? '' : focus, base); // ✅ 相对 POSIX
    const isDir = (ft & vscode.FileType.Directory) === vscode.FileType.Directory;
    const id = (isDir ? 'folder_' : 'file_') + safeId(rel);
    nodes.push({ id, label: base, type: isDir ? 'folder' : 'file', position: grid[i++], data: { path: rel } });
    edges.push({ id: `e_${safeId(rootId + '_' + id)}`, from: { node: rootId }, to: { node: id }, label: 'contains' });
  }

  return { id: `fs:${focus}`, title: `FileTree @ ${focus}`, nodes, edges,
           metadata: { graphType: 'filetree', focusPath: focus, generatedAt: new Date().toISOString() } };
}

function safeId(s:string){ return s.replace(/[^\w\-./]/g,'_'); }
function gridLayouter(n:number,w:number,h:number,ox:number,oy:number){ const cols=Math.max(1,Math.floor((1200-ox)/w)); return Array.from({length:n},(_,i)=>({x:ox+(i%cols)*w,y:oy+Math.floor(i/cols)*h})); }
```

---

### ④ 自检日志（定位到底哪一环没走到）

* 在 **graphView.js** 的双击回调里加：
  `console.log('[webview] dblclick folder → drill', n.data.path)`

  > 看 DevTools（F1 → *Open Webview Developer Tools*）是否打印：**如果没打印** → 事件没绑定或被遮挡；**有打印** → 看扩展端。

* 在 **OpenBlueprint.ts** 的 `onDidReceiveMessage` 里加：
  `console.log('[panel] recv', msg.type, msg.payload?.path)`

  > **没打印** → 消息没到扩展端（panel 没监听/被替换）；**有打印** 但不刷新 → 看 `focusPath` 是否更新与 `buildShallowGraph` 是否被 await。

---

### ⑤ 你代码里最可能的具体问题（结合你之前日志）

* 还在“双击时执行命令（从路径生成蓝图）”，而不是“同面板刷新”。
* `graph.metadata.graphType` 不是 `'filetree'`，导致你之前绑定双击用了 `if (… === 'filetree')` 的分支**从不生效**。
* `n.data.path` 不是 `/child` 形式（要么空字符串、要么 `D:\…`），扩展端 normalize 失败。
* `svg.edges` 没有 `pointer-events:none`，把双击吞了。
* 扩展端虽然收到了 `drill`，但没更新 `focusPath` 就刷新（视觉上“没变”）。

---

## 最后给你一个“10 秒判断表”

* 双击文件夹 → DevTools 是否打印“`dblclick folder → drill …`”？

  * 否 → 看 CSS 遮挡 / 事件是否绑定 / `graphType` 条件。
  * 是 → 扩展端是否打印“`[panel] drill to …`”？

    * 否 → panel 没监听或消息没路由到当前 panel。
    * 是 → 面板标题是否变化？

      * 否 → 没更新 `focusPath`。
      * 是 → but 内容没变化 → `buildShallowGraph` 读的还是旧目录（传参/normalize 出错）。

把上面四段补丁对齐后，你的“双击下钻 / 双击根上钻”就会稳定工作。如果你愿意，贴出你当前的 `graphView.js` 双击部分和 `onDidReceiveMessage` 部分，我按行帮你标哪里“还在走命令”或“路径没归一化”。
