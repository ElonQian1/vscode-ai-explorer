这是**层级（z-index/堆叠上下文）问题**：SVG 线条层和卡片层不在同一“可控”的堆叠上下文里，或 SVG 在 DOM/层级上方，导致“线盖住卡片”。再加上我们给画布用了 `transform: scale(...)`，浏览器会为子元素创建合成层，默认层级更容易乱。

给你两档修复：

---

# 方案 A（推荐，立刻见效）：把“线层”放到卡片“下面”

**要点**

1. 让 `#canvas` 成为独立堆叠上下文（`isolation: isolate`）。
2. 明确层级：`svg.edges` z-index 更低；`#nodes` 更高；`.node` 再更高。
3. 禁止线条拦截交互：`pointer-events: none`。

### 代码补丁

```css
/* 文件名: media/filetree-blueprint/index.css */
/* —— 新增/修改：控制层级 —— */
#canvas {
  position: absolute;
  left: 0;
  top: 0;
  transform-origin: 0 0;
  isolation: isolate; /* ✅ 让 #canvas 自成堆叠上下文，内部 z-index 可控 */
}
svg.edges {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 0; /* ✅ 最底层：连线在下面绘制 */
  pointer-events: none; /* ✅ 不阻挡鼠标 */
}
#nodes {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1; /* ✅ 卡片容器在上面 */
}
.node {
  position: absolute;
  z-index: 2; /* ✅ 单个卡片最高，确保盖住线条 */
}
```

```html
<!-- 文件名: （由 TS 模板生成的）Webview HTML 结构（确保顺序：edges 在前，nodes 在后） -->
<div id="canvas">
  <svg class="edges"></svg>
  <!-- ✅ 线层在前（DOM更“底”） -->
  <div id="nodes"></div>
  <!-- ✅ 卡片层在后（DOM更“上”） -->
</div>
```

> 如果你的模板里顺序反了，改回**上面这种顺序**；配合 CSS 层级，连线就永远在卡片下方了。

---

# 方案 B（更精致，可选）：把“线条穿过卡片”的部分裁掉

即使线在下面，**视觉上线还是会从卡片下方经过**。如果你想**卡片边缘把线“切掉”**（就像专业流程图工具），用 **SVG mask**：

### 代码补丁（在前端绘线处增加 mask）

```js
// 文件名: media/filetree-blueprint/graphView.js
// 在 drawEdges() 里，把所有边放进一个 <g>，并给它加 mask，mask 用“白底+卡片黑洞”实现遮挡

function drawEdges() {
  edgeSvg.innerHTML = "";

  // 1) 先建遮罩：白色=可见，黑色=隐藏（把卡片矩形涂黑）
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
  mask.setAttribute("id", "mask-out-nodes");

  const whiteBg = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "rect"
  );
  whiteBg.setAttribute("x", "0");
  whiteBg.setAttribute("y", "0");
  whiteBg.setAttribute("width", "5000");
  whiteBg.setAttribute("height", "5000");
  whiteBg.setAttribute("fill", "white"); // 全部可见
  mask.appendChild(whiteBg);

  // 把每个卡片的矩形涂黑 → 线在这些区域会被“挖掉”
  for (const n of graph.nodes) {
    const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    r.setAttribute("x", Math.round(n.position.x));
    r.setAttribute("y", Math.round(n.position.y));
    r.setAttribute("width", "160"); // 和你的 .node 宽度一致
    r.setAttribute("height", "64"); // 和你的 .node 高度一致
    r.setAttribute("rx", "10"); // 圆角和卡片一致
    r.setAttribute("ry", "10");
    r.setAttribute("fill", "black"); // 黑=隐藏
    mask.appendChild(r);
  }

  defs.appendChild(mask);
  edgeSvg.appendChild(defs);

  // 2) 把所有边放到一个组里，并应用 mask
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  g.setAttribute("mask", "url(#mask-out-nodes)");
  edgeSvg.appendChild(g);

  // 3) 接下来把原来画 path/text 的逻辑，改为 append 到 g 上
  for (const e of graph.edges) {
    const from = graph.nodes.find((n) => n.id === e.from?.node);
    const to = graph.nodes.find((n) => n.id === e.to?.node);
    if (!from || !to) continue;

    const fromPt = {
      x: Math.round(from.position.x + 160),
      y: Math.round(from.position.y + 24),
    };
    const toPt = {
      x: Math.round(to.position.x),
      y: Math.round(to.position.y + 24),
    };

    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("class", "edge");
    const dx = Math.max(40, (toPt.x - fromPt.x) * 0.5);
    path.setAttribute(
      "d",
      `M ${fromPt.x} ${fromPt.y} C ${fromPt.x + dx} ${fromPt.y}, ${
        toPt.x - dx
      } ${toPt.y}, ${toPt.x} ${toPt.y}`
    );
    g.appendChild(path);

    if (e.label) {
      const midx = Math.round((fromPt.x + toPt.x) / 2);
      const midy = Math.round((fromPt.y + toPt.y) / 2);
      const text = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "text"
      );
      text.setAttribute("class", "edge-label");
      text.setAttribute("x", midx);
      text.setAttribute("y", midy - 6);
      text.textContent = e.label;
      g.appendChild(text);
    }
  }
}
```

> 这样**线条在卡片下方且被卡片“切断”**，视觉非常干净。
> 注意：卡片尺寸（160×64、圆角 10）要与你的 `.node` 样式一致；如果你允许自适应宽高，记得同步。

---

## 额外小优化（任选）

- **边的透明度**：`svg .edge { opacity: .7; }`，弱化对视觉的干扰。
- **边的点击**：如果未来要点击 edge，给 `g` 之外再加一层“交互层”并只画**粗透明 hit 边**，渲染层仍 `pointer-events:none`。
- **端口锚点**：把连线起止点定位在卡片边中点（或四周端口），减少穿越卡片的概率。

---

## 自测步骤

1. 修改 CSS 层级后，重载窗口 → 线应永远在卡片之下，不影响拖拽/点击。
2. 启用 **方案 B** 后，线条与卡片相交处应被“切掉”。
3. 放大/缩小时观察遮挡是否仍正确（我们对坐标做了 `Math.round`，抖动不会回来）。

如果你愿意，我可以把 **方案 B 的 mask** 封装成一个小函数 `applyNodeMask(edgeSvg, graph)`，并在节点位置变化时自动调用，保证与你的 rAF 边重绘节流逻辑一起稳定工作。
