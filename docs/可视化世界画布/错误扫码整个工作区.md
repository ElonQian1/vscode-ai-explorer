看日志就能判断两件事：

1. 入口把**扫描根目录传成了工作区根**（`employeeGUI`），而不是你点击的 `docs/architecture`；
2. 扫描器用了**递归全仓**（还没正确排除 `target/` 等目录），所以一下子跑到了 **62,791 个节点**。

马上修：把“从路径生成蓝图”入口改成**以选中项为焦点的“浅层视图”**（只读取该目录的**直接子项**），并**强力排除**构建产物；如果点的是文件，自动切到其父目录。

---

# 一、关键修复点（TL;DR）

- 入口命令要传 **工作区根 `root` + 选中目录的 `focusPath`**；展示时只渲染 `focusPath` 的**一层**。
- 扫描函数改为**非递归**（只 `readDirectory`），避免一次性全仓。
- 默认 **exclude**：`**/target/**`、`**/src-tauri/**/target/**`、`**/node_modules/**`、`**/.git/**`、`**/dist/**`、`**/out/**`、`**/build/**`、`**/.vscode/**`。
- 标题与面包屑显示你点的真实目录（如 `/docs/architecture`），便于确认没跑偏。

---

# 二、直接可用的补丁

> 每段代码**第一行**是文件名注释；都带中文注释。把它们替换/新增进你的项目即可。

```ts
// src/extension.ts
// 修复：统一入口，确保以“选中路径”为焦点打开“浅层蓝图”
import * as vscode from "vscode";
import {
  registerFileTreeBlueprint,
  openBlueprintAt,
} from "./features/filetree-blueprint/FileTreeBlueprint";

export function activate(context: vscode.ExtensionContext) {
  registerFileTreeBlueprint(context);

  // 资源管理器右键 & 自定义视图左键都会走这个命令
  context.subscriptions.push(
    vscode.commands.registerCommand(
      "workflow.openBlueprintHere",
      async (target?: unknown) => {
        let uri: vscode.Uri | undefined;

        if (Array.isArray(target) && target.length)
          uri = (target[0] as any).resourceUri ?? target[0];
        else if ((target as any)?.resourceUri)
          uri = (target as any).resourceUri as vscode.Uri;
        else if (target instanceof vscode.Uri) uri = target;
        else uri = vscode.window.activeTextEditor?.document.uri;

        if (!uri) {
          vscode.window.showWarningMessage(
            "未找到可用路径：请在资源管理器中右键文件/文件夹。"
          );
          return;
        }
        await openBlueprintAt(context, uri);
      }
    )
  );
}

export function deactivate() {}
```

```jsonc
// package.json
// 修复：新增命令并挂到资源管理器右键菜单
{
  "activationEvents": ["onCommand:workflow.openBlueprintHere"],
  "contributes": {
    "commands": [
      {
        "command": "workflow.openBlueprintHere",
        "title": "Open Blueprint Here"
      }
    ],
    "menus": {
      "explorer/context": [
        {
          "command": "workflow.openBlueprintHere",
          "group": "navigation@100",
          "when": "resourceScheme == file"
        }
      ]
    },
    "configuration": {
      "properties": {
        "workflowBlueprint.excludes": {
          "type": "array",
          "default": [
            "**/.git/**",
            "**/node_modules/**",
            "**/dist/**",
            "**/out/**",
            "**/build/**",
            "**/.vscode/**",
            "**/target/**",
            "**/src-tauri/**/target/**"
          ],
          "description": "从蓝图扫描中排除的路径（glob）"
        }
      }
    }
  }
}
```

```ts
// src/features/filetree-blueprint/FileTreeBlueprint.ts
// 修复：以“选中目录”为焦点的【浅层】蓝图；点文件则切父目录；强力排除构建产物。
// 说明：这里的构建器只读“当前层级”的直接子项（非递归！）

import * as vscode from "vscode";
import * as path from "path";

type Position = { x: number; y: number };
type Node = {
  id: string;
  label: string;
  type?: "folder" | "file";
  position: Position;
  data?: Record<string, any>;
};
type Edge = {
  id: string;
  label?: string;
  from: { node: string };
  to: { node: string };
  data?: Record<string, any>;
};
type Graph = {
  id: string;
  title: string;
  nodes: Node[];
  edges: Edge[];
  metadata?: any;
};

export function registerFileTreeBlueprint(context: vscode.ExtensionContext) {
  // 你原有的命令可保留；右键入口走 extension.ts 里注册的 openBlueprintHere
}

export async function openBlueprintAt(
  context: vscode.ExtensionContext,
  target: vscode.Uri
) {
  // 1) 工作区根
  const ws =
    vscode.workspace.getWorkspaceFolder(target) ??
    vscode.workspace.workspaceFolders?.[0];
  if (!ws) {
    vscode.window.showWarningMessage("请先打开一个工作区。");
    return;
  }
  const root = ws.uri;

  // 2) 焦点目录：点“文件”则转到其父目录
  const stat = await vscode.workspace.fs.stat(target).catch(() => undefined);
  const isDir =
    !!stat &&
    (stat.type & vscode.FileType.Directory) === vscode.FileType.Directory;
  const focusUri = isDir ? target : vscode.Uri.joinPath(target, "..");

  // 3) 相对路径（用于面包屑/标题）
  const rel = toPosix(path.relative(root.fsPath, focusUri.fsPath));
  const focusPath = rel ? `/${rel}` : "/";

  // 4) 打开面板 + 构建“浅层图”
  const panel = createPanel(
    context,
    `文件树蓝图: ${rel || path.basename(root.fsPath)}`
  );
  const jsUri = panel.webview.asWebviewUri(
    vscode.Uri.joinPath(
      context.extensionUri,
      "media",
      "workflow",
      "graphView.js"
    )
  );
  const cssUri = panel.webview.asWebviewUri(
    vscode.Uri.joinPath(context.extensionUri, "media", "workflow", "index.css")
  );
  panel.webview.html = htmlTemplate(jsUri, cssUri);

  const graph = await buildShallowGraph(root, focusPath);
  panel.webview.postMessage({ type: "init-graph", payload: graph });

  panel.webview.onDidReceiveMessage(async (msg) => {
    if (msg?.type === "drill") {
      const next = msg.payload?.path as string;
      const g2 = await buildShallowGraph(root, next);
      panel.title = `文件树蓝图: ${
        next === "/" ? path.basename(root.fsPath) : next
      }`;
      panel.webview.postMessage({ type: "init-graph", payload: g2 });
    } else if (msg?.type === "drill-up") {
      const cur = msg.payload?.path as string;
      const up = drillUp(cur);
      const g2 = await buildShallowGraph(root, up);
      panel.title = `文件树蓝图: ${
        up === "/" ? path.basename(root.fsPath) : up
      }`;
      panel.webview.postMessage({ type: "init-graph", payload: g2 });
    }
  });
}

// —— 仅“当前层级”的【非递归】扫描 —— //
async function buildShallowGraph(
  root: vscode.Uri,
  focusPath: string
): Promise<Graph> {
  const excludes: string[] =
    vscode.workspace.getConfiguration("workflowBlueprint").get("excludes") ??
    [];
  const dirUri =
    focusPath === "/" ? root : vscode.Uri.joinPath(root, focusPath);
  let entries: [vscode.Uri, vscode.FileType][] = [];

  try {
    entries = await vscode.workspace.fs.readDirectory(dirUri);
  } catch {
    // 如果传入的是文件路径或不存在，回退到上一级
    return buildShallowGraph(root, drillUp(focusPath));
  }

  // 过滤排除项（只对当前层级生效）
  const shouldSkip = (p: string) =>
    excludes.some((glob) =>
      minimatch(p, glob, { dot: true, nocase: true, nocomment: true })
    );

  const nodes: Node[] = [];
  const edges: Edge[] = [];

  const rootNodeId =
    focusPath === "/" ? "workspace-root" : `folder_${safeId(focusPath)}`;
  nodes.push({
    id: rootNodeId,
    label:
      focusPath === "/"
        ? path.basename(root.fsPath) || "workspace"
        : path.basename(focusPath),
    type: "folder",
    position: { x: 20, y: 20 },
    data: { path: focusPath, isRoot: true },
  });

  // 网格定位
  const visible = entries
    .map(([uri, ft]) => {
      const base = uri.path.split(/[\\/]/g).pop() || "";
      const rel = toPosix(
        path.posix.join(focusPath === "/" ? "" : focusPath, base)
      );
      return { base, rel, type: ft };
    })
    .filter((x) => !shouldSkip(x.rel));

  const grid = gridLayouter(visible.length, 200, 140, 80, 80);
  let i = 0;

  for (const e of visible) {
    const isFolder =
      (e.type & vscode.FileType.Directory) === vscode.FileType.Directory;
    const id = (isFolder ? "folder_" : "file_") + safeId(e.rel);
    const data: Record<string, any> = { path: e.rel };

    if (isFolder) {
      try {
        const sub = await vscode.workspace.fs.readDirectory(
          vscode.Uri.joinPath(root, e.rel)
        );
        data.childrenCount = sub.length;
      } catch {}
    } else {
      data.ext = path.extname(e.base);
      try {
        const stat = await vscode.workspace.fs.stat(
          vscode.Uri.joinPath(root, e.rel)
        );
        data.size = stat.size;
      } catch {}
    }

    nodes.push({
      id,
      label: e.base,
      type: isFolder ? "folder" : "file",
      position: grid[i++],
      data,
    });
    edges.push({
      id: `e_${safeId(rootNodeId + "_" + id)}`,
      from: { node: rootNodeId },
      to: { node: id },
      label: "contains",
      data: { kind: "containment" },
    });
  }

  return {
    id: `fs:${focusPath}`,
    title: `FileTree @ ${focusPath}`,
    nodes,
    edges,
    metadata: {
      graphType: "filetree",
      focusPath,
      generatedAt: new Date().toISOString(),
    },
  };
}

// —— Webview/排版工具 —— //
function createPanel(context: vscode.ExtensionContext, title: string) {
  return vscode.window.createWebviewPanel(
    "workflowGraph",
    title,
    vscode.ViewColumn.Beside,
    {
      enableScripts: true,
      retainContextWhenHidden: true,
      localResourceRoots: [
        vscode.Uri.joinPath(context.extensionUri, "media", "workflow"),
      ],
    }
  );
}

function toPosix(p: string) {
  return p.split(path.sep).join("/");
}
function drillUp(cur: string) {
  if (cur === "/" || !cur) return "/";
  const parts = cur.split("/").filter(Boolean);
  parts.pop();
  return parts.length ? "/" + parts.join("/") : "/";
}
function safeId(s: string) {
  return s.replace(/[^\w\-./]/g, "_");
}
function gridLayouter(
  n: number,
  w: number,
  h: number,
  ox: number,
  oy: number
): Position[] {
  const cols = Math.max(1, Math.floor((1200 - ox) / w));
  return Array.from({ length: n }, (_, i) => ({
    x: ox + (i % cols) * w,
    y: oy + Math.floor(i / cols) * h,
  }));
}

// 简化：用最小版 minimatch；你也可改用 vscode 自带 glob 匹配
import minimatch = require("minimatch");

function htmlTemplate(jsUri: vscode.Uri, cssUri: vscode.Uri) {
  return `<!doctype html><html lang="zh-CN"><head>
<meta charset="UTF-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src https: data:; style-src 'unsafe-inline' ${cssUri}; script-src 'unsafe-eval' 'unsafe-inline' ${jsUri};">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link href="${cssUri}" rel="stylesheet" />
<title>Workflow Blueprint</title></head>
<body>
  <div class="toolbar"><strong>Workflow</strong>
    <span style="margin-left:6px;color:#999">双击文件夹=进入；滚轮缩放；空格+拖拽=平移</span>
  </div>
  <div id="canvasWrap"><div id="canvas"><svg class="edges"></svg><div id="nodes"></div></div></div>
  <script src="${jsUri}"></script>
</body></html>`;
}
```

---

# 三、为什么你会看到 62,791 个节点？

- 入口把**扫描根**传成了 `employeeGUI`，日志也印证了：

  - `开始生成蓝图: d:\...\employeeGUI`
  - 扫描时命中 `target/debug/build/tauri-.../autogenerated/...` 等构建目录；

- 扫描器是**递归**的（有“最大递归深度(10)”提示），且**排除规则不全**；
- 结果就是全仓巨图：62,791 节点 / 62,790 边。

**现在的修复**会让它只渲染“你点的目录”的**一层**，并默认排除 `target/**` 等产物目录。

---

# 四、建议的调试检查（快速自检）

1. 右键 `docs/architecture` → Open Blueprint Here

   - 面板标题应显示：`文件树蓝图: /docs/architecture`
   - 面包屑（若你启用）或右上角信息应显示当前焦点路径

2. 节点数量应 ≈“该目录直接子项数量”
3. 日志里不应再出现 `target/**` 等路径（被 excludes 排掉）
4. 双击文件夹可进入下一级，返回上一层按钮可回退

---

# 五、可选增强（稍后叠加）

- **阈值保护**：当单层子项 > 500 时提示是否继续/启用聚合；
- **布局缓存**：`.vscode/workflow-layouts/<focusPath>.json` 记住坐标；
- **依赖边（TS/Rust）**：解析 import / mod/use，把跨模块依赖画出来；
- **视图切换**：文件夹视图 / 模块视图 / 依赖视图 / UML。

---

如果你按上面的补丁改完，还是出现“全仓递归”，把你当前的“从路径生成蓝图”的处理函数贴出来（或日志里打印的**传入路径**），我帮你再对症定位。
