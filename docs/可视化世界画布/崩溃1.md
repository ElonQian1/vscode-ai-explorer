看明白了，这是**入口拿到的 URI 不是文件系统 `file:` 协议**导致的。你是从命令面板或某个“非文件编辑器”（比如 Output 面板“任务”频道）触发的，所以 fallback 拿到的是 **`output:tasks`**，扫描器再去 `fs.stat(output:tasks)` 就报：

> 无法解析具有相对文件路径 "output:tasks" 的文件系统提供程序

同时日志里也能看到你传入的是 `tasks`（不是绝对路径/不是 file 协议）。

下面给出**两处修复**：

1. **入口统一把任意目标解析为 `file:` URI**（不行就弹“选择文件/文件夹”对话框）；
2. **浅层扫描**保持非递归，只看当前层；并继续使用排除规则。

---

# 修复思路（TL;DR）

- 任何地方触发命令 → 先调用 `resolveTargetToFileUri()`：

  - 如果 target 是 `Uri` 且 `scheme !== 'file'` → 忽略，转向**选择对话框**或**工作区根**；
  - 如果是字符串（如 `tasks`）→ 相对工作区根拼出 `file:`；
  - 若是文件 → 焦点改为**其父目录**；
  - 记录 `workspaceRoot` 与 `focusPath`（相对路径，前面加 `/`）。

- 然后再调用你的 `buildShallowGraph(workspaceRoot, focusPath)`。

---

## ① 入口：把任何 target 解析为文件系统 URI

```ts
// src/features/filetree-blueprint/utils/resolveTarget.ts
// 中文注释：把各种“入口上下文”解析成 file: URI（若拿不到，则提示用户选择）。
import * as vscode from "vscode";
import * as path from "path";

export interface ResolvedTarget {
  ws: vscode.WorkspaceFolder; // 工作区根
  folderUri: vscode.Uri; // 用于渲染的“焦点目录”（始终是 folder 的 file: URI）
  focusPath: string; // 以 / 开头的相对路径，例：/docs/architecture
}

export async function resolveTargetToFileUri(
  raw?: unknown
): Promise<ResolvedTarget | undefined> {
  // 1) 优先从 raw 解析 URI
  let uri: vscode.Uri | undefined;
  if (Array.isArray(raw) && raw.length) {
    uri = (raw[0] as any).resourceUri ?? (raw[0] as vscode.Uri);
  } else if ((raw as any)?.resourceUri) {
    uri = (raw as any).resourceUri as vscode.Uri;
  } else if (raw instanceof vscode.Uri) {
    uri = raw;
  } else {
    // 来自命令面板/快捷键 → 不要用 activeTextEditor（可能是 output:tasks）
    uri = undefined;
  }

  // 2) 选定工作区
  const ws =
    (uri && vscode.workspace.getWorkspaceFolder(uri)) ??
    vscode.workspace.workspaceFolders?.[0];
  if (!ws) {
    vscode.window.showWarningMessage("请先打开一个工作区再生成蓝图。");
    return;
  }

  // 3) 若不是 file: 或没有 uri → 让用户选一个文件/文件夹
  if (!uri || uri.scheme !== "file") {
    const picked = await vscode.window.showOpenDialog({
      canSelectFolders: true,
      canSelectFiles: true,
      canSelectMany: false,
      defaultUri: ws.uri,
      title: "选择要作为蓝图起点的文件或文件夹",
    });
    if (!picked || !picked[0]) return;
    uri = picked[0];
  }

  // 4) 统一成“文件夹”焦点：如果点到文件 → 切父目录
  const st = await vscode.workspace.fs.stat(uri).catch(() => undefined);
  const isDir =
    !!st && (st.type & vscode.FileType.Directory) === vscode.FileType.Directory;
  const folderUri = isDir ? uri : vscode.Uri.joinPath(uri, "..");

  // 5) 相对路径（用于标题/面包屑）→ 形如 /docs/architecture
  const rel = path
    .relative(ws.uri.fsPath, folderUri.fsPath)
    .split(path.sep)
    .join("/");
  const focusPath = rel ? `/${rel}` : "/";

  return { ws, folderUri, focusPath };
}
```

把它用于你的入口命令：

```ts
// src/extension.ts
// 中文注释：从任何入口调用，确保拿到 file: 目录焦点
import * as vscode from "vscode";
import { buildShallowGraphPanel } from "./features/filetree-blueprint/presenters/OpenBlueprint";
import { resolveTargetToFileUri } from "./features/filetree-blueprint/utils/resolveTarget";

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand(
      "workflow.openBlueprintHere",
      async (raw?: unknown) => {
        const resolved = await resolveTargetToFileUri(raw);
        if (!resolved) return;
        await buildShallowGraphPanel(
          context,
          resolved.ws.uri,
          resolved.focusPath
        );
      }
    )
  );
}
```

> 这样即使你在 **Output 面板**里按命令，依然会弹“选择文件/文件夹”，不会再把 `output:tasks` 当成路径去 `fs.stat`。

---

## ② 打开面板（浅层扫描），保持非递归 + 排除构建产物

```ts
// src/features/filetree-blueprint/presenters/OpenBlueprint.ts
// 中文注释：仅构建“当前层”的文件树蓝图；双击下钻、返回上层；继续使用 excludes。
import * as vscode from "vscode";
import * as path from "path";
import minimatch = require("minimatch");

type Position = { x: number; y: number };
type Node = {
  id: string;
  label: string;
  type: "folder" | "file";
  position: Position;
  data?: Record<string, any>;
};
type Edge = {
  id: string;
  from: { node: string };
  to: { node: string };
  label?: string;
  data?: Record<string, any>;
};
type Graph = {
  id: string;
  title: string;
  nodes: Node[];
  edges: Edge[];
  metadata: any;
};

export async function buildShallowGraphPanel(
  context: vscode.ExtensionContext,
  workspaceRoot: vscode.Uri,
  focusPath: string
) {
  const panel = vscode.window.createWebviewPanel(
    "workflowGraph",
    `文件树蓝图: ${
      focusPath === "/" ? path.basename(workspaceRoot.fsPath) : focusPath
    }`,
    vscode.ViewColumn.Beside,
    {
      enableScripts: true,
      retainContextWhenHidden: true,
      localResourceRoots: [
        vscode.Uri.joinPath(context.extensionUri, "media", "workflow"),
      ],
    }
  );
  const jsUri = panel.webview.asWebviewUri(
    vscode.Uri.joinPath(
      context.extensionUri,
      "media",
      "workflow",
      "graphView.js"
    )
  );
  const cssUri = panel.webview.asWebviewUri(
    vscode.Uri.joinPath(context.extensionUri, "media", "workflow", "index.css")
  );
  panel.webview.html = html(jsUri, cssUri);

  const graph = await buildShallowGraph(workspaceRoot, focusPath);
  panel.webview.postMessage({ type: "init-graph", payload: graph });

  panel.webview.onDidReceiveMessage(async (msg) => {
    if (msg?.type === "drill") {
      const next = msg.payload?.path as string;
      panel.webview.postMessage({
        type: "init-graph",
        payload: await buildShallowGraph(workspaceRoot, next),
      });
      panel.title = `文件树蓝图: ${
        next === "/" ? path.basename(workspaceRoot.fsPath) : next
      }`;
    } else if (msg?.type === "drill-up") {
      const cur = msg.payload?.path as string;
      const up = drillUp(cur);
      panel.webview.postMessage({
        type: "init-graph",
        payload: await buildShallowGraph(workspaceRoot, up),
      });
      panel.title = `文件树蓝图: ${
        up === "/" ? path.basename(workspaceRoot.fsPath) : up
      }`;
    }
  });
}

async function buildShallowGraph(
  root: vscode.Uri,
  focusPath: string
): Promise<Graph> {
  const excludes: string[] = vscode.workspace
    .getConfiguration("workflowBlueprint")
    .get("excludes") ?? [
    "**/.git/**",
    "**/node_modules/**",
    "**/dist/**",
    "**/out/**",
    "**/build/**",
    "**/.vscode/**",
    "**/target/**",
    "**/src-tauri/**/target/**",
  ];

  const dirUri =
    focusPath === "/" ? root : vscode.Uri.joinPath(root, focusPath);
  let entries: [vscode.Uri, vscode.FileType][] = [];
  try {
    entries = await vscode.workspace.fs.readDirectory(dirUri);
  } catch {
    return buildShallowGraph(root, drillUp(focusPath));
  }

  const shouldSkip = (rel: string) =>
    excludes.some((glob) => minimatch(rel, glob, { dot: true, nocase: true }));
  const nodes: Node[] = [];
  const edges: Edge[] = [];
  const rootNodeId =
    focusPath === "/" ? "workspace-root" : `folder_${safeId(focusPath)}`;

  nodes.push({
    id: rootNodeId,
    label:
      focusPath === "/" ? path.basename(root.fsPath) : path.basename(focusPath),
    type: "folder",
    position: { x: 20, y: 20 },
    data: { path: focusPath, isRoot: true },
  });

  const visible = entries
    .map(([uri, ft]) => {
      const base = uri.path.split(/[\\/]/g).pop() || "";
      const rel = path.posix.join(focusPath === "/" ? "" : focusPath, base);
      return { base, rel, ft };
    })
    .filter((x) => !shouldSkip(x.rel));

  const grid = gridLayouter(visible.length, 200, 140, 80, 80);
  let i = 0;
  for (const e of visible) {
    const isFolder =
      (e.ft & vscode.FileType.Directory) === vscode.FileType.Directory;
    const data: Record<string, any> = { path: e.rel };
    if (isFolder) {
      try {
        data.childrenCount = (
          await vscode.workspace.fs.readDirectory(
            vscode.Uri.joinPath(root, e.rel)
          )
        ).length;
      } catch {}
    } else {
      data.ext = path.extname(e.base);
      try {
        data.size = (
          await vscode.workspace.fs.stat(vscode.Uri.joinPath(root, e.rel))
        ).size;
      } catch {}
    }
    const id = (isFolder ? "folder_" : "file_") + safeId(e.rel);
    nodes.push({
      id,
      label: e.base,
      type: isFolder ? "folder" : "file",
      position: grid[i++],
      data,
    });
    edges.push({
      id: `e_${safeId(rootNodeId + "_" + id)}`,
      from: { node: rootNodeId },
      to: { node: id },
      label: "contains",
      data: { kind: "containment" },
    });
  }

  return {
    id: `fs:${focusPath}`,
    title: `FileTree @ ${focusPath}`,
    nodes,
    edges,
    metadata: {
      graphType: "filetree",
      focusPath,
      generatedAt: new Date().toISOString(),
    },
  };
}

function drillUp(cur: string) {
  if (cur === "/" || !cur) return "/";
  const parts = cur.split("/").filter(Boolean);
  parts.pop();
  return parts.length ? "/" + parts.join("/") : "/";
}
function safeId(s: string) {
  return s.replace(/[^\w\-./]/g, "_");
}
function gridLayouter(
  n: number,
  w: number,
  h: number,
  ox: number,
  oy: number
): Position[] {
  const cols = Math.max(1, Math.floor((1200 - ox) / w));
  return Array.from({ length: n }, (_, i) => ({
    x: ox + (i % cols) * w,
    y: oy + Math.floor(i / cols) * h,
  }));
}
function html(js: vscode.Uri, css: vscode.Uri) {
  return `<!doctype html><html><head>
<meta charset="utf-8"/>
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; img-src https: data:; style-src 'unsafe-inline' ${css}; script-src 'unsafe-eval' 'unsafe-inline' ${js};">
<link href="${css}" rel="stylesheet"/></head>
<body>
  <div class="toolbar"><strong>Workflow</strong><span style="margin-left:6px;color:#999">双击文件夹=进入；滚轮缩放；空格+拖拽=平移</span></div>
  <div id="canvasWrap"><div id="canvas"><svg class="edges"></svg><div id="nodes"></div></div></div>
  <script src="${js}"></script>
</body></html>`;
}
```

> 这段与我们之前的“浅层图”一致，只是集中到了一个 presenter 文件里，便于你现有架构接入。

---

## ③（可选）在 UseCase/Scanner 里再加一道保险

如果你已经有 `GenerateBlueprintUseCase.ts` 或 `FileTreeScanner.ts`，建议**入口第一行**就校验：

```ts
// FileTreeScanner.ts 顶部
if (uri.scheme !== "file") {
  throw vscode.FileSystemError.Unavailable(
    `仅支持 file: 协议，当前为 ${uri.scheme}: ${uri.toString()}`
  );
}
```

这样即使未来有人绕过入口，也会得到**清晰可理解**的错误，而不是“无法解析 output:tasks”。

---

# 自测步骤

1. 在**资源管理器**右键 `docs/architecture` → “Open Blueprint Here”

   - ✅ 面板标题展示 `文件树蓝图: /docs/architecture`
   - ✅ 节点数量 ≈ 该目录**直接子项数**

2. 在 **Output** 面板激活、命令面板执行“Open Blueprint Here”

   - ✅ 弹出“选择文件/文件夹”对话框（不再拿到 `output:tasks`）

3. 右键**单个文件** → 会打开其**父目录**的蓝图
4. 双击文件夹可下钻；“返回上一层”按纽正常

---

# 额外建议

- 继续保留 `workflowBlueprint.excludes`（默认含 `target/**`、`node_modules/**` 等），防止误扫构建产物。
- 如果单层子项过多（比如 > 500），可以弹窗提示是否聚合/分页显示，避免卡顿。

---

有了这两个补丁，你这次的报错就会消失；而且从**任何入口**触发都会落在正确的**file:** 目录焦点上。需要我把这套改动对接到你现有的 usecase / domain 分层里吗？我可以按你当前的文件结构把路径贴得更精确。
