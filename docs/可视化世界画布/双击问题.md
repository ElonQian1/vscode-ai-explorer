很可能就是**双击事件根本没“绑上去”或者被上层遮罩吃掉了**。你刚才说“调试控制台没有任何显示”，基本等于：

* 既没有 `[webview] dblclick …` 的日志；
* 也没有扩展端 `[panel] recv drill …` 的日志。

这通常表示：**节点的 dblclick 没被绑定**（DOM 被重建/选择器没命中），或**有全局层在拦截**（`pointer-events`、遮罩、SVG 线层）。

下面给你一套**一次到位的“保险方案”**：

1. 前端改成**事件委托**绑定一次（不怕节点被重渲染）；
2. CSS 做**事件安全网**，杜绝遮挡；
3. 扩展端加**日志与路径规范化**，确保消息到了就刷新。

---

## 1) 前端：用“事件委托”绑定一次 `dblclick`（不怕节点重渲染）

> 把“给每个节点单独 `el.addEventListener('dblclick', …)`”改为**给 `#nodes` 容器绑定一次**，通过 `.closest('.node')` 找到被双击的节点；这样就算你重建了节点 DOM，也**不会丢绑定**。

```js
// 文件名: media/filetree-blueprint/graphView.js
// 中文注释：事件委托处理下钻/上钻；只绑定一次；保证n.data.path是相对POSIX；根节点用isRoot标记。

(function () {
  const vscode = acquireVsCodeApi();
  let graph = { nodes: [], edges: [], metadata: { graphType: 'filetree', focusPath: '/' } };
  let dblDelegationBound = false;

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (msg?.type === 'init-graph') {
      graph = msg.payload || graph;
      renderNodesOnce();     // 你已有的节点渲染
      initEdgesLayerOnce();  // 你已有的边层初始化
      drawEdges();           // 你已有的绘边
      bindDblclickDelegationOnce(); // ✅ 确保只绑定一次委托
    }
  });

  function bindDblclickDelegationOnce() {
    if (dblDelegationBound) return;
    const box = document.getElementById('nodes');
    if (!box) return; // 首次DOM还没准备好，再下一轮init-graph会重试
    box.addEventListener('dblclick', (ev) => {
      const nodeEl = ev.target && (ev.target as HTMLElement).closest?.('.node');
      if (!nodeEl) return;
      const id = (nodeEl as HTMLElement).dataset.id;
      if (!id) return;

      const n = graph.nodes.find(x => String(x.id) === String(id));
      if (!n) return;

      // 根节点：上钻
      if (n?.data?.isRoot === true) {
        console.log('[webview] dblclick root → drill-up');
        vscode.postMessage({ type: 'drill-up', payload: { path: graph?.metadata?.focusPath || '/' } });
        return;
      }

      // 文件夹：下钻（要求相对POSIX路径）
      if (n.type === 'folder' && n?.data?.path) {
        const rel = String(n.data.path).replace(/\\/g,'/').replace(/\/+/g,'/');
        if (!rel.startsWith('/')) {
          // 若传来的是相对名（如 'debug'），拼到当前层
          const base = graph?.metadata?.focusPath && graph.metadata.focusPath !== '/' ? graph.metadata.focusPath : '';
          const fixed = (base ? base + '/' + rel : '/' + rel).replace(/\/+/g,'/');
          console.log('[webview] dblclick folder → drill', fixed);
          vscode.postMessage({ type: 'drill', payload: { path: fixed } });
        } else {
          console.log('[webview] dblclick folder → drill', rel);
          vscode.postMessage({ type: 'drill', payload: { path: rel } });
        }
      }
    }, false);
    dblDelegationBound = true;
  }

  // —— 你原有的渲染与拖拽函数保留，不再给每个节点单独绑定 dblclick —— //
})();
```

> 这样即使你在别处重建了节点 DOM，**委托绑定仍然有效**，不会出现“偶尔没反应”的情况。

---

## 2) CSS：给“线层/遮罩层”加**事件安全网**（绝不拦截双击）

```css
/* 文件名: media/filetree-blueprint/index.css */
/* 中文注释：线层禁止接收事件；帮助浮层隐藏时不接事件；节点层始终在上。 */

svg.edges {
  position: absolute; left: 0; top: 0;
  z-index: 0;
  pointer-events: none; /* ✅ 不吃事件，dblclick必达节点 */
}

#nodes {
  position: absolute; left: 0; top: 0;
  z-index: 1;
}
.node {
  position: absolute;
  z-index: 2;
}

/* 帮助浮层默认不吃事件，只有展示状态才开启 */
.help-overlay { pointer-events: none; }
.help-overlay.show { pointer-events: auto; }
```

> 这一步能**直接排除**“全局画布/遮罩把事件吃掉”的可能。

---

## 3) 扩展端：接收 `drill/drill-up` → **更新 focusPath 后刷新**（加日志）

```ts
// 文件名: src/features/filetree-blueprint/presenters/OpenBlueprint.ts
// 中文注释：同面板内切换层级；规范化路径；日志可在 Extension Host 控制台看到。

panel.webview.onDidReceiveMessage(async (msg) => {
  if (msg?.type === 'drill') {
    const next = normalizeFocus(msg.payload?.path as string, focusPath);
    console.log('[panel] recv drill →', next);
    focusPath = next; // ✅ 别忘了更新
    panel.title = titleFor(workspaceRoot, focusPath);
    panel.webview.postMessage({ type:'init-graph', payload: await buildShallowGraph(workspaceRoot, focusPath) });
    return;
  }
  if (msg?.type === 'drill-up') {
    const up = drillUp(normalizeFocus(msg.payload?.path as string, focusPath));
    console.log('[panel] recv drill-up →', up);
    focusPath = up; // ✅ 别忘了更新
    panel.title = titleFor(workspaceRoot, focusPath);
    panel.webview.postMessage({ type:'init-graph', payload: await buildShallowGraph(workspaceRoot, focusPath) });
    return;
  }
});
```

> 若这里都没有日志，说明**消息根本没从 webview 发出**（回到第 1 步排查）。

---

## 4) 10 分钟“系统检查”清单（照做就能定位）

1. **打开 Webview 控制台**：`Ctrl+Shift+P → Open Webview Developer Tools → Console`。

   * 双击任意文件夹节点，是否看到：`[webview] dblclick folder → drill …`？

     * 看不到 → **前端没绑定/被遮挡**；回到步骤 1、2。
2. **扩展主机日志**（输出/调试控制台里选 Extension Host）：

   * 是否看到：`[panel] recv drill → /xxx`？

     * 看不到 → 消息没到扩展端；检查 `onDidReceiveMessage` 是否注册在**当前 panel**。
3. **标题是否变化**：面板标题应变为 `文件树蓝图: /xxx`。

   * 不变 → 你没更新 `focusPath` 或 `title`。
4. **路径是否相对 POSIX**：`node.data.path` 必须类似 `/docs/architecture`；

   * 若是 `D:\...` 或 `debug`，会触发 normalize 分支处理；把**生成节点**那步改成一律产出相对 POSIX 更稳。
5. **SVG 线层/帮助层** 是否已按上文 CSS 设置 `pointer-events`。
6. **拖拽/重绘** 是否会在两次点击之间**重建节点 DOM**（我们用了事件委托就不怕了）。

---

## 5) 额外调试利器（可选，强烈推荐）

在 `graphView.js` 暂时加一个**全局事件探针**（按 F2 开关），能看到 `pointerdown/click/dblclick` 的捕获/冒泡路径，快速判断是谁吃了事件：

```js
// 文件名: media/filetree-blueprint/graphView.js
// 中文注释：F2 开关事件探针，协助定位“谁吃了事件”。

(function(){
  let __probeOn = false;
  function __attachProbe(){
    const targets = [window, document, document.getElementById('canvasWrap'),
      document.getElementById('canvas'), document.querySelector('svg.edges'), document.getElementById('nodes')].filter(Boolean);
    const types = ['pointerdown','pointerup','click','dblclick'];
    for (const t of types) for (const tg of targets) {
      tg.addEventListener(t, e => console.log(`[EV bubble] ${t}`, e.target), false);
      tg.addEventListener(t, e => console.log(`[EV capture] ${t}`, e.target), true);
    }
  }
  window.addEventListener('keydown', (e)=>{ if (e.key==='F2'){ __probeOn=!__probeOn; console.log('事件探针', __probeOn?'开启':'关闭'); if(__probeOn)__attachProbe(); }});
})();
```

---

### 结论

* **是的，全局画布/遮罩很可能阻碍双击**；加上 CSS “事件安全网”后，基本断绝遮挡。
* 把双击改成**事件委托**，即便节点 DOM 被重建也不会丢失绑定。
* 扩展端加日志与 `focusPath` 更新，确保消息链路打通。

照上面三块补丁做完 → 双击文件夹**必定下钻**，双击根**必定上钻**。
如果还是没反应，把你当前的 `#nodes` 容器 HTML 结构（面板里最终生成的 DOM）和 `metadata.focusPath`、`node.data.path` 的实际值贴我，我按值定位具体哪一步没对齐。
