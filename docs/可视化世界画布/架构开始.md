太好了，我们就从你这个仓库里**落地“文件树蓝图”功能**，把“VS Code 资源管理器的树形文件 → 可拖拽蓝图（可下钻）”做成一个**独立模块**，并与现有“UML-Canvas”并存（后面再把依赖边/布局缓存/React Flow 豪华版接上）。

> 我已经看了你仓库的结构（`src/extension.ts` 作为入口、`src/features/*` 做功能模块）以及 README 中的模块化说明，下面的集成路径就是按你现在的分层来做的。([GitHub][1])

---

# 一键集成指南（从零到“能跑”）

## 第 0 步：在 `package.json` 加命令与激活事件

```jsonc
// package.json 片段（在 "contributes" 和 "activationEvents" 中新增或合并）
// 文件名: package.json
{
  "activationEvents": [
    "onCommand:workflow.openGraph",
    "onCommand:workflow.generateFromWorkspace"
  ],
  "contributes": {
    "commands": [
      { "command": "workflow.openGraph", "title": "Open Workflow Graph (from current file)" },
      { "command": "workflow.generateFromWorkspace", "title": "Generate FileTree Blueprint (Workspace → Graph)" }
    ]
  }
}
```

---

## 第 1 步：在入口 `src/extension.ts` 里注册新模块

```ts
// src/extension.ts
// 中文注释：插件入口，增加对“文件树蓝图”模块的注册调用。

import * as vscode from 'vscode';
// 新增 ↓↓↓
import { registerFileTreeBlueprint } from './features/filetree-blueprint/FileTreeBlueprint';

export function activate(context: vscode.ExtensionContext) {
  // 你原有的初始化...

  // 注册“文件树蓝图”功能模块
  registerFileTreeBlueprint(context);
}

export function deactivate() {
  // 你原有的清理...
}
```

---

## 第 2 步：新增功能模块目录与核心逻辑

### 2.1 模块入口（扫描工作区 → 生成蓝图 → Webview 可下钻/拖拽；亦支持打开你自有 JSON/MD）

````ts
// src/features/filetree-blueprint/FileTreeBlueprint.ts
// 功能：
// 1) workflow.generateFromWorkspace：扫描工作区 -> 生成“文件树蓝图”，支持双击文件夹下钻、返回上一层。
// 2) workflow.openGraph：从当前编辑器解析 JSON 或 Markdown 中 ```flowjson 段渲染（便于你打开自定义架构图）。
// 3) 仅“手写图”支持回写节点坐标；“文件树蓝图”不把拖拽位置写回。

import * as vscode from 'vscode';
import * as path from 'path';

type Position = { x: number; y: number };
type Node = {
  id: string;
  label: string;
  type?: 'folder'|'file'|'module';
  position: Position;
  data?: Record<string, any>;
};
type Endpoint = { node: string; port?: string };
type Edge = { id: string; label?: string; from: Endpoint; to: Endpoint; data?: Record<string, any>; };
type Graph = { id: string; title: string; nodes: Node[]; edges: Edge[]; metadata?: any };

const EXCLUDES = [
  '**/.git/**','**/node_modules/**','**/dist/**','**/out/**','**/target/**','**/build/**',
  '**/.vscode/**','**/.idea/**','**/.DS_Store'
];

export function registerFileTreeBlueprint(context: vscode.ExtensionContext) {
  // 1) 打开“手写图”（JSON/MD）
  context.subscriptions.push(
    vscode.commands.registerCommand('workflow.openGraph', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) { vscode.window.showWarningMessage('请先打开包含工作流数据的文件（.json/.jsonc/含 ```flowjson 的 .md）'); return; }
      const doc = editor.document;
      const parsed = parseGraphFromDocument(doc.getText(), doc.languageId, doc.fileName);
      if (!parsed.ok) { vscode.window.showErrorMessage(`解析失败：${parsed.error}`); return; }

      const panel = createPanel(context, `Workflow: ${parsed.graph.title || parsed.graph.id || 'Untitled'}`);
      const jsUri  = panel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow', 'graphView.js'));
      const cssUri = panel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow', 'index.css'));
      panel.webview.html = htmlTemplate(jsUri, cssUri);

      panel.webview.postMessage({ type: 'init-graph', payload: parsed.graph });

      // “手写图”拖拽回写
      panel.webview.onDidReceiveMessage(async (msg) => {
        if (msg?.type !== 'node-moved') return;
        const { nodeId, position } = msg.payload as { nodeId: string; position: Position };
        const g = parsed.graph;
        const idx = g.nodes.findIndex(n => n.id === nodeId);
        if (idx < 0) return;
        g.nodes[idx].position = position;

        // 回写到打开的文档
        try {
          const updated = writeBackGraphIntoDocument(doc.getText(), parsed, g);
          const edit = new vscode.WorkspaceEdit();
          edit.replace(doc.uri, new vscode.Range(doc.positionAt(0), doc.positionAt(doc.getText().length)), updated);
          await vscode.workspace.applyEdit(edit);
          await doc.save();
        } catch (e: any) {
          vscode.window.showErrorMessage(`写回失败：${e?.message || e}`);
        }
      });
    })
  );

  // 2) 工作区 → 文件树蓝图
  context.subscriptions.push(
    vscode.commands.registerCommand('workflow.generateFromWorkspace', async () => {
      const folders = vscode.workspace.workspaceFolders;
      if (!folders || folders.length === 0) { vscode.window.showWarningMessage('请先打开一个工作区。'); return; }
      const root = folders[0].uri;
      await openFileTreeGraphPanel(context, root, '/');
    })
  );
}

/** ========== 文件树蓝图（生成 + 下钻） ========== */
async function openFileTreeGraphPanel(context: vscode.ExtensionContext, root: vscode.Uri, focusPath: string) {
  const panel = createPanel(context, `FS Blueprint: ${focusPath === '/' ? 'Workspace Root' : focusPath}`);
  const jsUri  = panel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow', 'graphView.js'));
  const cssUri = panel.webview.asWebviewUri(vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow', 'index.css'));
  panel.webview.html = htmlTemplate(jsUri, cssUri);

  const graph = await buildFileTreeGraph(root, focusPath);
  panel.webview.postMessage({ type: 'init-graph', payload: graph });

  panel.webview.onDidReceiveMessage(async (msg) => {
    if (msg?.type === 'drill') {
      const p = msg.payload?.path as string;
      const sub = await buildFileTreeGraph(root, p);
      panel.title = `FS Blueprint: ${p}`;
      panel.webview.postMessage({ type: 'init-graph', payload: sub });
    } else if (msg?.type === 'drill-up') {
      const cur = msg.payload?.path as string;
      const up = drillUp(cur);
      const sub = await buildFileTreeGraph(root, up);
      panel.title = `FS Blueprint: ${up}`;
      panel.webview.postMessage({ type: 'init-graph', payload: sub });
    }
  });
}

function createPanel(context: vscode.ExtensionContext, title: string) {
  return vscode.window.createWebviewPanel(
    'workflowGraph',
    title,
    vscode.ViewColumn.Beside,
    { enableScripts: true, retainContextWhenHidden: true,
      localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media', 'workflow')] }
  );
}

async function buildFileTreeGraph(root: vscode.Uri, focusPath: string): Promise<Graph> {
  // 仅渲染“当前层级”的直接子项，避免一次性几千节点
  const dirUri = focusPath === '/' ? root : vscode.Uri.joinPath(root, focusPath);
  let entries: [vscode.Uri, vscode.FileType][];
  try { entries = await vscode.workspace.fs.readDirectory(dirUri); }
  catch { return buildFileTreeGraph(root, drillUp(focusPath)); }

  const nodes: Node[] = [];
  const edges: Edge[] = [];
  const rootNodeId = focusPath === '/' ? 'workspace-root' : `folder_${safeId(focusPath)}`;

  nodes.push({
    id: rootNodeId,
    label: focusPath === '/' ? path.basename(root.fsPath) || 'workspace' : path.basename(focusPath),
    type: 'folder',
    position: { x: 20, y: 20 },
    data: { path: focusPath, isRoot: true }
  });

  const grid = gridLayouter(entries.length, 200, 140, 80, 80);
  let i = 0;

  for (const [child, type] of entries) {
    const base = child.path.split(/[\\/]/g).pop() || '';
    const rel = path.posix.join(focusPath === '/' ? '' : focusPath, base);
    const isFolder = (type & vscode.FileType.Directory) === vscode.FileType.Directory;

    const id = (isFolder ? 'folder_' : 'file_') + safeId(rel);
    const pos = grid[i++];

    const data: Record<string, any> = { path: rel };
    if (!isFolder) {
      data.ext = path.extname(base);
      try { data.size = (await vscode.workspace.fs.stat(vscode.Uri.joinPath(root, rel))).size; } catch {}
    } else {
      try { data.childrenCount = (await vscode.workspace.fs.readDirectory(vscode.Uri.joinPath(root, rel))).length; } catch {}
    }

    nodes.push({ id, label: base, type: isFolder ? 'folder' : 'file', position: pos, data });
    edges.push({ id: `e_${safeId(rootNodeId+'_'+id)}`, from: { node: rootNodeId }, to: { node: id }, label: 'contains', data: { kind: 'containment' } });
  }

  return {
    id: `fs:${focusPath}`,
    title: `FileTree @ ${focusPath}`,
    nodes, edges,
    metadata: { graphType: 'filetree', focusPath, generatedAt: new Date().toISOString() }
  };
}

/** ========== 解析/回写“手写图” ========== */
function parseGraphFromDocument(text: string, languageId: string, fileName: string):
  | { ok: true; graph: Graph; kind: 'json'|'md'; range?: {start:number; end:number} }
  | { ok: false; error: string } {
  try {
    if (fileName.endsWith('.json') || fileName.endsWith('.jsonc') || languageId === 'json') {
      const g = JSON.parse(stripJsonComments(text)) as Graph;
      ensurePositions(g);
      return { ok: true, graph: g, kind: 'json' };
    }
    const re = /```flowjson\s+([\s\S]*?)```/im; // Markdown 中的 flowjson 代码块
    const m = re.exec(text);
    if (m && m[1]) {
      const jsonStart = m.index + m[0].indexOf(m[1]);
      const jsonEnd = jsonStart + m[1].length;
      const g = JSON.parse(m[1]) as Graph;
      ensurePositions(g);
      return { ok: true, graph: g, kind: 'md', range: { start: jsonStart, end: jsonEnd } };
    }
    return { ok: false, error: '未找到 JSON / JSONC 或 ```flowjson 代码块' };
  } catch (e: any) {
    return { ok: false, error: e?.message || String(e) };
  }
}

function writeBackGraphIntoDocument(original: string, parsed:
  { ok: true; kind: 'json'|'md'; range?: {start:number; end:number} }, graph: Graph): string {
  const pretty = JSON.stringify(graph, null, 2);
  if (parsed.kind === 'json') return pretty;
  if (!parsed.range) return original;
  return original.slice(0, parsed.range.start) + pretty + original.slice(parsed.range.end);
}

function ensurePositions(g: Graph) {
  g.nodes.forEach((n, i) => { if (!n.position) n.position = { x: 100 + i * 160, y: 100 }; });
}

/** ========== 小工具 ========== */
function gridLayouter(n: number, w: number, h: number, ox: number, oy: number): Position[] {
  const cols = Math.max(1, Math.floor((1200 - ox) / w));
  const res: Position[] = [];
  for (let i = 0; i < n; i++) { const r = Math.floor(i / cols), c = i % cols; res.push({ x: ox + c*w, y: oy + r*h }); }
  return res;
}
function safeId(s: string) { return s.replace(/[^\w\-./]/g, '_'); }
function drillUp(cur: string) { if (cur === '/' || cur === '') return '/'; const parts = cur.split('/').filter(Boolean); parts.pop(); return parts.length ? '/' + parts.join('/') : '/'; }
function stripJsonComments(input: string) { return input.replace(/^\s*\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, ''); }
````

---

### 2.2 Webview 前端脚本（拖拽、缩放、下钻/返回上一层、手写图回写移动）

```js
// media/workflow/graphView.js
// 中文说明：
// - 文件树蓝图：双击 folder 下钻；工具栏“返回上一层”；拖拽仅前端移动，不写回。
// - 手写图：拖拽后 postMessage('node-moved')，由扩展把 position 写回 JSON/MD。

(function(){
  const vscode = acquireVsCodeApi();

  let graph = { nodes: [], edges: [], id: 'g', title: 'untitled', metadata: {} };
  const wrap  = document.getElementById('canvasWrap');
  const canvas= document.getElementById('canvas');
  const nodeContainer = document.getElementById('nodes');
  const edgeSvg = document.querySelector('svg.edges');

  // 工具栏
  const toolbar = document.querySelector('.toolbar');
  toolbar.insertAdjacentHTML('beforeend', `
    <span id="breadcrumb" style="margin-left:12px;color:#666"></span>
    <button id="btnUp" style="margin-left:8px;padding:4px 8px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer">返回上一层</button>
  `);
  const breadcrumb = document.getElementById('breadcrumb');
  const btnUp = document.getElementById('btnUp');
  btnUp.addEventListener('click', () => {
    if (graph?.metadata?.graphType === 'filetree') {
      vscode.postMessage({ type: 'drill-up', payload: { path: graph.metadata.focusPath } });
    }
  });

  let scale = 1, offset = { x: 0, y: 0 }, panning = false, panStart = { x:0, y:0 }, originAtPanStart = { x:0, y:0 }, spacePressed = false;

  window.addEventListener('message', (e) => {
    const msg = e.data;
    if (msg?.type === 'init-graph') {
      graph = msg.payload;
      if (graph?.metadata?.graphType === 'filetree') {
        breadcrumb.textContent = `当前位置：${graph.metadata.focusPath}`;
        btnUp.style.display = 'inline-block';
      } else { breadcrumb.textContent = ''; btnUp.style.display = 'none'; }
      render();
    }
  });

  function render() {
    edgeSvg.setAttribute('width', 5000); edgeSvg.setAttribute('height', 5000);
    nodeContainer.innerHTML = ''; edgeSvg.innerHTML = '';

    graph.nodes.forEach(n => {
      const el = document.createElement('div');
      el.className = 'node';
      el.style.left = `${n.position.x}px`; el.style.top = `${n.position.y}px`;
      el.dataset.id = n.id;

      const subtitle = (n.type === 'folder' && n.data?.childrenCount != null)
        ? `子项：${n.data.childrenCount}`
        : (n.type === 'file' && n.data?.ext ? `类型: ${n.data.ext}` : '');

      el.innerHTML = `<div class="title">${escapeHtml(n.label || n.id)}</div><div class="desc">${subtitle}</div>`;

      if (n.type === 'folder' && n.data?.path && graph?.metadata?.graphType === 'filetree') {
        el.addEventListener('dblclick', () => vscode.postMessage({ type: 'drill', payload: { path: n.data.path } }));
      }

      makeDraggable(el, n);
      nodeContainer.appendChild(el);
    });

    graph.edges.forEach(e => {
      const from = graph.nodes.find(n => n.id === e.from?.node);
      const to   = graph.nodes.find(n => n.id === e.to?.node);
      if (!from || !to) return;

      const fromPt = { x: from.position.x + 160, y: from.position.y + 24 };
      const toPt   = { x: to.position.x,        y: to.position.y   + 24 };

      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('class','edge');
      const dx = Math.max(40, (toPt.x - fromPt.x) * 0.5);
      path.setAttribute('d', `M ${fromPt.x} ${fromPt.y} C ${fromPt.x+dx} ${fromPt.y}, ${toPt.x-dx} ${toPt.y}, ${toPt.x} ${toPt.y}`);
      edgeSvg.appendChild(path);

      if (e.label) {
        const midx = (fromPt.x + toPt.x) / 2; const midy = (fromPt.y + toPt.y) / 2;
        const text = document.createElementNS('http://www.w3.org/2000/svg','text');
        text.setAttribute('class','edge-label'); text.setAttribute('x', midx); text.setAttribute('y', midy - 6);
        text.textContent = e.label; edgeSvg.appendChild(text);
      }
    });

    applyTransform();
  }

  function makeDraggable(el, node) {
    let dragging = false; let start = { x:0, y:0 }; let nodeStart = { x:0, y:0 };
    el.addEventListener('pointerdown', (ev) => {
      if (ev.button !== 0) return; if (spacePressed) return;
      dragging = true; el.setPointerCapture(ev.pointerId);
      start = { x: ev.clientX, y: ev.clientY }; nodeStart = { x: node.position.x, y: node.position.y };
    });
    el.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      const dx = (ev.clientX - start.x) / scale, dy = (ev.clientY - start.y) / scale;
      node.position.x = nodeStart.x + dx; node.position.y = nodeStart.y + dy;
      el.style.left = `${node.position.x}px`; el.style.top = `${node.position.y}px`;
      render();
    });
    el.addEventListener('pointerup', (ev) => {
      if (!dragging) return; dragging = false; el.releasePointerCapture(ev.pointerId);
      if (graph?.metadata?.graphType !== 'filetree') {
        vscode.postMessage({ type: 'node-moved', payload: { nodeId: node.id, position: node.position } });
      }
    });
  }

  wrap.addEventListener('wheel', (ev) => {
    ev.preventDefault();
    const prev = scale, delta = Math.sign(ev.deltaY) * -0.1;
    scale = Math.min(2.5, Math.max(0.3, scale + delta));
    const rect = wrap.getBoundingClientRect(); const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
    offset.x = mx - ((mx - offset.x) * (scale / prev)); offset.y = my - ((my - offset.y) * (scale / prev));
    applyTransform();
  }, { passive: false });

  window.addEventListener('keydown', e => { if (e.code === 'Space') spacePressed = true; });
  window.addEventListener('keyup',   e => { if (e.code === 'Space') spacePressed = false; });

  wrap.addEventListener('pointerdown', (ev) => {
    if (!spacePressed) return; panning = true; panStart = { x: ev.clientX, y: ev.clientY }; originAtPanStart = { ...offset }; wrap.setPointerCapture(ev.pointerId);
  });
  wrap.addEventListener('pointermove', (ev) => {
    if (!panning) return; const dx = ev.clientX - panStart.x, dy = ev.clientY - panStart.y; offset = { x: originAtPanStart.x + dx, y: originAtPanStart.y + dy }; applyTransform();
  });
  wrap.addEventListener('pointerup', () => { panning = false; });

  function applyTransform(){ canvas.style.transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`; }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
})();
```

### 2.3 Webview HTML+样式（简洁干净，可直接用）

```html
<!-- media/workflow/index.html (不必单独文件：下面的 htmlTemplate 会内联生成；若你想独立维护，也可以放这个文件) -->
<!-- 文件名: media/workflow/index.css -->
/* 画布与节点的基础样式（中文注释） */
body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Noto Sans SC; }
.toolbar { height:40px; border-bottom:1px solid #eee; display:flex; align-items:center; padding:0 10px; gap:8px; }
#canvasWrap { position:relative; height: calc(100vh - 40px); overflow:hidden; background:#fafafa; }
#canvas { position:absolute; left:0; top:0; transform-origin: 0 0; }
.node { position:absolute; width:160px; height:64px; border-radius:10px; background:#fff; box-shadow: 0 2px 6px rgba(0,0,0,0.06); border:1px solid #e8e8e8; padding:8px 10px; cursor:grab; user-select:none; }
.node .title { font-weight:600; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.node .desc  { margin-top:4px; font-size:12px; color:#666; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
svg.edges { position:absolute; left:0; top:0; pointer-events:none; }
svg .edge { fill:none; stroke:#8ea1b3; stroke-width:1.6; }
svg .edge-label { font-size:11px; fill:#6b7280; }
```

> 上面的 CSS 文件路径是 `media/workflow/index.css`。
> **HTML 模板**在 TS 里内联生成（避免多文件读写），代码如下：

```ts
// src/features/filetree-blueprint/FileTreeBlueprint.ts 末尾追加
function htmlTemplate(jsUri: vscode.Uri, cssUri: vscode.Uri) {
  return `<!DOCTYPE html>
  <html lang="zh-CN"><head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy"
      content="default-src 'none'; img-src https: data:; style-src 'unsafe-inline' ${cssUri}; script-src 'unsafe-eval' 'unsafe-inline' ${jsUri};">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link href="${cssUri}" rel="stylesheet" />
    <title>Workflow Blueprint</title>
  </head>
  <body>
    <div class="toolbar">
      <strong>Workflow</strong>
      <span style="margin-left:6px;color:#999">拖拽节点，滚轮缩放；空格+拖拽=平移；双击文件夹=进入</span>
    </div>
    <div id="canvasWrap">
      <div id="canvas">
        <svg class="edges"></svg>
        <div id="nodes"></div>
      </div>
    </div>
    <script src="${jsUri}"></script>
  </body></html>`;
}
```

---

## 第 3 步：把静态资源放到扩展包里

新建目录并放文件：

```
media/workflow/
  ├── graphView.js   ← 上面 JS
  └── index.css      ← 上面 CSS
```

> 这类静态文件会随扩展一起打包；`panel.webview.asWebviewUri` 会把它们映射到安全的资源 URL。

---

## 第 4 步：运行与验证

1. **编译**：`npm run compile`（或 `pnpm run compile`）
2. **启动调试**：F5 → 选择“运行整个插件”
3. 打开任意工作区 → `Ctrl/Cmd+Shift+P` → 运行

   * `Generate FileTree Blueprint (Workspace → Graph)`：生成工作区根层级蓝图，**双击文件夹可下钻**，点击“返回上一层”。
   * `Open Workflow Graph (from current file)`：在当前编辑器打开 `.json/.jsonc` 或含有 ```flowjson 的 `.md` 文件即可渲染手写图（**拖拽节点会回写坐标**）。

---

# 说明与后续扩展

* **为什么做成 `src/features/filetree-blueprint/*` 的模块？**
  因为你项目已经采用“功能模块层”的结构（`src/features/…`，入口在 `src/extension.ts` 做统一注册），新模块与现有 `uml-canvas` 并行，更易维护与替换。([GitHub][1])

* **和 “UML-Canvas (图表生成)” 的关系**
  这个“文件树蓝图”是**最原始视图**（从资源管理器出发）。等你需要时，我们再把：

  1. **TS/Rust 导入依赖边**（跨模块依赖、循环、分层违规）；
  2. **布局缓存**（`.vscode/workflow-layouts/<focusPath>.json` 保存坐标）；
  3. **React Flow + 自动布局（ELK/Dagre）豪华版**
     按模块化接到本视图里，实现“模块/文件夹/依赖/时序/UML”的**多视图切换**。

* **JSON/Markdown 的“手写图”**
  仍然支持，你可以把 AI 产出的架构 JSON（或在 `.md` 里的 ```flowjson）直接可视化；拖拽节点后会**写回原文件**，便于版本化保存你的布局。

---

# 小结（你现在就可以“开始”）

* 已提供**可直接运行**的：命令注册、工作区扫描→蓝图生成、Webview 拖拽/缩放/下钻、手写图回写。
* 放置路径与调用方式完全**贴合你现有仓库结构**（`src/extension.ts` + `src/features/*` + `media/*`）。([GitHub][1])

要不要我**再顺手补上布局缓存**（记住每个目录层级的坐标），或者**接入 TS/Rust 依赖边**（把 import/mod/use 画出来）？我可以在这个基础上直接加一版“依赖层”。

[1]: https://github.com/ElonQian1/vscode-ai-explorer "GitHub - ElonQian1/vscode-ai-explorer: vscode-ai-explorer 中文资源管理器"
