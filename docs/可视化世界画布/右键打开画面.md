我发现我现在的 右键打开蓝图 都有问题。 
它不是直接打开 我在 自己的 ai资源管理器  右键所选的文件夹， 而是又弹出一个窗口让我选择。

你说的现象＝**命令拿不到 file: URI**，所以走了“兜底弹窗选路径”。
要彻底解决：确保**AI 资源管理器的 TreeItem 右键/左键都把 `file:` URI 作为参数传给命令**，并且**命令本身不要再弹选择框**（除非从命令面板空调用）。

下面是最小补丁，直接复制即可跑（都带中文注释 & 文件名注释）。

---

### 1) 在你的 AI 资源管理器 TreeItem 上绑定 `resourceUri` + 直接传参

```ts
// src/features/ai-explorer/YourTreeProvider.ts
// 中文：确保每个节点都携带“文件系统 URI”，右键/左键都把它传给命令。

import * as vscode from 'vscode';
import * as path from 'path';

export class ExplorerNode extends vscode.TreeItem {
  constructor(public readonly resourceUri: vscode.Uri, label: string, collapsible: vscode.TreeItemCollapsibleState) {
    super(label, collapsible);

    // ✅ 关键：标注这是文件/文件夹（可用于菜单 when 条件）
    this.contextValue = 'aiExplorer.node.' + (
      resourceUri.path.endsWith('/') ? 'folder' : 'item'
    );

    // ✅ 左键打开蓝图（如果你想单击只选中、双击才打开，可去掉这段）
    this.command = {
      command: 'workflow.openBlueprintAtUri',
      title: 'Open Blueprint',
      arguments: [this.resourceUri]  // ⬅️ 直接传 file: URI
    };
  }
}

// 生成节点时，请务必用 file: 协议：
// new ExplorerNode(vscode.Uri.file(absPath), label, vscode.TreeItemCollapsibleState.Collapsed)
```

> 重点：**必须是 `vscode.Uri.file(absPath)`**。不要传字符串、不要传 output:、untitled: 等 scheme。

---

### 2) 为你的自定义视图加“右键菜单”并直传参数

```jsonc
// package.json
// 中文：给自定义视图（请把 yourViewId 替换成你的真实 viewId）加右键菜单；命令就是我们马上注册的那个。
{
  "activationEvents": [
    "onCommand:workflow.openBlueprintAtUri"
  ],
  "contributes": {
    "commands": [
      { "command": "workflow.openBlueprintAtUri", "title": "Open Blueprint Here" }
    ],
    "menus": {
      "view/item/context": [
        {
          "command": "workflow.openBlueprintAtUri",
          "when": "view == yourViewId && viewItem == aiExplorer.node.item",
          "group": "navigation@100"
        },
        {
          "command": "workflow.openBlueprintAtUri",
          "when": "view == yourViewId && viewItem == aiExplorer.node.folder",
          "group": "navigation@100"
        }
      ],
      "explorer/context": [
        {
          "command": "workflow.openBlueprintAtUri",
          "when": "resourceScheme == file",
          "group": "navigation@100"
        }
      ]
    }
  }
}
```

> `yourViewId` 请换成你在 `contributes.views` 里注册 AI 资源管理器的 **实际 id**。
> `contextValue` 我上面写的是 `aiExplorer.node.item/folder`，你可以按需改成你项目里已用的值。

---

### 3) 注册一个**只接受 URI**的命令处理器（不弹选择框）

```ts
// src/extension.ts
// 中文：新的命令 handler：拿到任何“像 URI 的对象”→ 抽取为 file: URI；没有参数时才弹选择框。

import * as vscode from 'vscode';
import { openBlueprintAt } from './features/filetree-blueprint/FileTreeBlueprint'; // 你已有的函数

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('workflow.openBlueprintAtUri', async (arg?: unknown) => {
      const uri = extractFileUri(arg);
      if (uri) {
        await openBlueprintAt(context, uri); // ⬅️ 不弹窗，直接打开
        return;
      }

      // 仅在“没有参数”的情况下（如命令面板直接执行）才给用户选
      const ws = vscode.workspace.workspaceFolders?.[0]?.uri;
      const picked = await vscode.window.showOpenDialog({
        canSelectFiles: true, canSelectFolders: true, canSelectMany: false,
        title: '选择要作为蓝图起点的文件或文件夹',
        defaultUri: ws
      });
      if (picked && picked[0]) await openBlueprintAt(context, picked[0]);
    })
  );
}

function extractFileUri(input?: unknown): vscode.Uri | undefined {
  // 情况 1：直接就是 Uri
  if (input instanceof vscode.Uri) return input.scheme === 'file' ? input : undefined;

  // 情况 2：来自 TreeView 的节点对象（带 resourceUri）
  const asAny = input as any;
  if (asAny?.resourceUri instanceof vscode.Uri) {
    return asAny.resourceUri.scheme === 'file' ? asAny.resourceUri : undefined;
  }

  // 情况 3：资源管理器多选：Uri[]
  if (Array.isArray(input) && input.length) {
    const first = input[0];
    if (first instanceof vscode.Uri) return first.scheme === 'file' ? first : undefined;
    if ((first as any)?.resourceUri instanceof vscode.Uri) {
      const u = (first as any).resourceUri as vscode.Uri;
      return u.scheme === 'file' ? u : undefined;
    }
  }

  // 情况 4：传了个“长得像路径的字符串”
  if (typeof input === 'string' && input.trim()) {
    try { return vscode.Uri.file(input); } catch { /* ignore */ }
  }

  return undefined;
}
```

> 这个 handler **绝不主动弹窗**，除非你真的没传任何参数（命令面板空调用）。
> 这样，从“AI 资源管理器右键”就不会再弹选择框了。

---

### 4)（可选）把旧的“解析并弹窗”的工具保留给命令面板

如果你之前有一个 `resolveTargetToFileUri()`，容易误判导致总弹窗。建议：

* **不要在右键/左键入口里调用它**；
* 只在**命令面板**空调用时使用。

---

### 5) 自检清单

1. 在 AI 资源管理器里**打印节点的 `resourceUri`**（一次性日志）确认是 `file:`：

   * `console.log('[AIExplorer] node uri:', node.resourceUri.toString());`
2. 右键你自己的视图节点 → “Open Blueprint Here”

   * ✅ 不应再弹选择框
   * ✅ 面板标题显示选中的目录层级
3. VS Code 内置资源管理器右键也可用（因为我们在 `explorer/context` 也挂了）
4. 如果仍弹窗：加个临时日志看 handler 收到的 `arg` 是什么类型（很可能不是 Uri 或没有 `resourceUri`）

---

### 为什么会弹窗（原理回顾）

你之前的命令是这么判断的：**“如果 arg 为空或 scheme 不是 file 就弹窗”。**
当你在 AI 资源管理器里右键时，**如果 TreeItem 没有 `resourceUri` 或传的不是 Uri**，handler 就把它当“没传参数”，自然会走“弹窗”分支。
**这次补丁**从两头修：

* **TreeItem 一定传 `file:` URI**；
* **命令 handler** 仅在**真的没有参数**时才弹窗。

---

需要我帮你把 `yourViewId`、TreeProvider 的文件路径、以及 `openBlueprintAt` 的导入路径**对齐到你仓库的真实结构**吗？你贴一下这三处的实际位置，我给你按行改。
