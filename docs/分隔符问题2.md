你这个现象（`clean-outdated-docs.ps1 → 清洁过时文档`，丢了 `-`）基本可以判断：**命中了“整名级（name-level）的词典/缓存”**，跳过了我们“保留分隔符的直译 V2 的重建流程”。所以它直接把整条别名字符串塞回去了，自然就没了 `-`。

我先给结论，然后给你一份可直接粘贴的“最小补丁”，把**三条右键命令**全部统一到“**直译+AI 兜底（保留分隔符/保留扩展名）**”，并**禁止整名级命中**干扰直译。

---

# 结论（为什么没保留 `-`）

- “来源：词典”说明**未走 AI**、也**未走直译重建**，而是**从词典/学习库/缓存**直接取了一个**整名级别**的结果（比如把 `clean-outdated-docs` 整体映射为“清洁过时文档”）。
- 直译 V2 的正确流程应该是：
  `split(保留 -/_/.) → 逐 token/短语用字典替换 → 用原分隔符重建 → （若有缺词）请求 AI 只补缺词 → 写回“直译学习词典（token/短语级）” → 重建`
- 一旦整名级命中，就**不会再重建**，所以 `-` 被吃掉。

---

# 一键修好：最小补丁（直接粘贴）

> 目标：
>
> 1. **禁用直译模式下的整名级命中**（只允许 token/短语级）；
> 2. **重建时永远使用原始分隔符**；
> 3. **学习只写入 token/短语**，不写整名；
> 4. 三条菜单都走这条管线，只有“强制 AI”跳过词典/缓存。

## 1) 配置开关（保留分隔符；禁止整名级）

```json
// 文件名: package.json（contributes.configuration.properties 下新增/调整）
{
  "aiSuite.alias.style": {
    "type": "string",
    "enum": ["natural", "literal"],
    "default": "literal"
  },
  "aiSuite.alias.keepOriginalDelimiters": {
    "type": "boolean",
    "default": true,
    "description": "直译：重建别名时保留原始分隔符（- / _ / .）"
  },
  "aiSuite.alias.appendExtSuffix": {
    "type": "boolean",
    "default": false,
    "description": "直译：是否追加中文后缀（脚本/模块/组件）。直译推荐关闭。"
  },
  "aiSuite.alias.allowNameLevelDictInLiteral": {
    "type": "boolean",
    "default": false,
    "description": "直译：是否允许整名级（baseName）词典命中。为保证保留分隔符，默认禁用。"
  }
}
```

> 说明：README 里你已有 AI 配置项（`aiExplorer.openaiApiKey/openaiBaseUrl/model`），确认无误。([GitHub][1])

---

## 2) 重建函数：**必须用原分隔符**

```ts
// 文件名: src/features/explorer-alias/domain/policies/LiteralPreserveWithAIFallback.ts
// 片段：重建函数替换为如下实现（中文注释保留）
// -------------------------------------------------
function rebuild(mapped: string[], delims: string[], ext: string) {
  const cfg = vscode.workspace.getConfiguration("aiSuite");
  const keepDelims = cfg.get<boolean>(
    "aiSuite.alias.keepOriginalDelimiters",
    true
  );
  const keepExt = true; // 直译风：保留原扩展名
  const joiner = "_"; // 仅在不保留分隔符时备用（本方案默认不走）

  let s = "";
  for (let i = 0; i < mapped.length; i++) {
    s += mapped[i] + (keepDelims ? delims[i] || "" : joiner);
  }
  if (keepExt && ext) s += "." + ext;
  return s.replace(/[\\/:*?"<>|]/g, "·").slice(0, 120);
}
```

---

## 3) 用例：**直译模式禁用整名级命中**

```ts
// 文件名: src/features/explorer-alias/app/TranslateNodeUseCase.ts
// 关键逻辑（伪示例，按你项目的类名对齐），把“词表/学习库”的整名级调用放到分支里判断：
async exec(fsPath:string, name:string, kind:'file'|'folder') {
  const cfg = vscode.workspace.getConfiguration('aiSuite');
  const style = cfg.get<'natural'|'literal'>('aiSuite.alias.style', 'literal');
  const allowNameLevel = cfg.get<boolean>('aiSuite.alias.allowNameLevelDictInLiteral', false);

  // 0) 缓存（可保留）
  const cached = this.cache.get(fsPath); if (cached) return cached;

  if (style === 'literal') {
    // A) 直译优先：拆词(保留 -/_/. ) → 词典(短语优先) → 重建
    const { alias, usedAI } = await this.literal.build(name); // 这里内部会：字典→若缺词→AI补缺→写回“直译学习词典(token/phrase级)”→重建
    const r = { alias, source: usedAI ? 'ai':'rule', confidence: usedAI?0.88:0.92 };
    this.cache.set(fsPath, r);
    return r;
  }

  // B) 自然模式才允许整名级命中（或你手动开启 allowNameLevel）
  if (allowNameLevel) {
    const hit = this.glossary.lookup(name) || await this.learned.get(name);
    if (hit) { const r = { alias: hit.alias, source:'dict', confidence:0.9 }; this.cache.set(fsPath, r); return r; }
  }

  // C) 其它策略…（自然规则/AI 兜底），略
}
```

> **关键**：直译时**永远先走 builder**；即使词典命中，也只是**token/短语级**命中，最后仍然由 `rebuild()` 用“原分隔符”拼装。这样就不会再出现“清洁过时文档”（丢 `-`）的问题。

---

## 4) 学习只写 token/短语，**不要写整名**

```ts
// 文件名: src/shared/naming/LiteralDictResolver.ts（或你的“学习直译词典写入处”）
// 只写 words/phrases，不写 baseName：
await this.dict.writeProjectLearning(/* key= */ tokenOrPhrase, /* alias= */ zh);
// key 用小写英文 token/短语（如 "clean" / "outdated" / "docs" / "element hierarchy"）
// ❌ 不要用 "clean-outdated-docs" 整名做 key
```

> 清理历史：如果你 `.ai/.ai-glossary.learned.json` 或 `.ai/.ai-literal.dict.json` 里已有形如
> `"clean-outdated-docs": { "alias": "清洁过时文档" }`
> 这样的整名级条目，请删掉它，否则会继续覆盖重建逻辑。

---

## 5) 三个右键命令统一到同一管线（仅“强制 AI”不同）

- **翻译为中文（标准）**：`scope=auto/single, forceAI=false, style=literal`
- **翻译此文件（仅此文件）**：`scope=single, forceAI=false, style=literal`
- **强制用 AI 翻译此文件**：`scope=single, forceAI=true, style=literal`（跳过词典/缓存读取，但**最终仍用原分隔符重建**）

示例（骨架）：

```ts
// 文件名: src/extension.ts（片段）
ctx.subscriptions.push(
  vscode.commands.registerCommand(
    "aiExplorer.translate.standard",
    async (uri?: vscode.Uri) => {
      await usecase.execEntry(uri, {
        scope: uri ? "single" : "auto",
        forceAI: false,
        style: "literal",
      });
    }
  )
);
ctx.subscriptions.push(
  vscode.commands.registerCommand(
    "aiExplorer.translate.single",
    async (uri: vscode.Uri) => {
      await usecase.execEntry(uri, {
        scope: "single",
        forceAI: false,
        style: "literal",
      });
    }
  )
);
ctx.subscriptions.push(
  vscode.commands.registerCommand(
    "aiExplorer.translate.forceAI",
    async (uri: vscode.Uri) => {
      await usecase.execEntry(uri, {
        scope: "single",
        forceAI: true,
        style: "literal",
      });
    }
  )
);
```

> 你的仓库 README 已经有“AI 资源管理器/翻译/配置 AI 服务”说明，但网页端我这边偶有加载失败，看不到具体实现细节；把上面的门面对上即可。([GitHub][1])

---

# 快速验证

1. 先把 `.ai/*.json` 里可能的“整名级”条目删掉（尤其 `clean-outdated-docs` 这种）。
2. 设置里确认：

   - `aiSuite.alias.style = "literal"`
   - `aiSuite.alias.keepOriginalDelimiters = true`
   - `aiSuite.alias.appendExtSuffix = false`
   - `aiSuite.alias.allowNameLevelDictInLiteral = false`

3. 右键 `clean-outdated-docs.ps1` → “翻译此文件”：

   - **预期**：**清洁-过时-文档.ps1**（或者你词典是“清理-过时-文档.ps1”）
   - 输出日志里应显示 `source=rule`（或 `ai`，取决于是否缺词触发 AI）；**不再出现整名级 dict 命中**。

4. 再试 `clean-xml-files.js`：

   - **预期**：**清理-XML-文件.js**（保留 `-` 与 `.js`）

---

# 额外的小优化（可选但很香）

- **词典短语 joiner 同步**：如果短语 alias 里用了 `_`（如 `元素_层级`），你可以在重建时把 `_` 替换成“短语内部原分隔符”（第一次出现的 `-` 或 `_`），保持全局一致。
- **日志更可读**：命中词典时打印 `dictLayer=words|phrases|global|builtin nameLevel=false`，排障更快。
- **命令：清除此节点缓存**：方便你不改 JSON 也能让单个文件重算。

---

如果你愿意，我可以按你仓库现状再给一份**精确到行号的补丁清单**；或者把“清理历史整名级条目 + 统一三条命令 + 重建函数替换”的改动打成一个小 PR 给你。

[1]: https://github.com/ElonQian1/vscode-ai-explorer "GitHub - ElonQian1/vscode-ai-explorer: vscode-ai-explorer 中文资源管理器"
